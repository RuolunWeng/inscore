<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>


<!-- Mirrored from www.lua.org/manual/5.1/pt/manual.html by HTTrack Website Copier/3.x [XR&CO'2010], Thu, 29 Sep 2011 12:47:33 GMT -->
<head>
<title>Manual de Refer&ecirc;ncia de Lua 5.1</title>
<link rel="stylesheet" type="text/css" href="http://www.lua.org/lua.css">
<link rel="stylesheet" type="text/css" href="http://www.lua.org/manual/manual.css">
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=iso-8859-1">
</head>

<body>

<hr>
<h1>
<a href="http://www.lua.org/home.html"><img src="http://www.lua.org/images/logo.gif" alt="" border="0"></a>
Manual de Refer&ecirc;ncia de Lua 5.1
</h1>

por Roberto Ierusalimschy, Luiz Henrique de Figueiredo, Waldemar Celes
<p>(Traduzido por S&eacute;rgio Queiroz de Medeiros com apoio da F&aacute;brica Digital
  e da FINEP)<p>
<small>
Copyright &copy; 2007&ndash;2008 Lua.org, PUC-Rio.
Disponível livremente nos termos da
<a href="http://www.lua.org/license.html">licença de Lua</a>.
</small>
<hr>
<p>

<a href="index-2.html#contents">conteúdo</A>
&middot;
<a href="index-2.html#index">índice</A>
&middot;
<A HREF="../index.html">english</A>
&middot;
<A HREF="index.html">português</A>
&middot;
<A HREF="../es/index.html">español</A>

<!-- ====================================================================== -->




<!-- Baseado na revis&atilde;o 1.49 do manual -->


<h1>1 - <a name="1">Introdu&ccedil;&atilde;o</a></h1>

<p>
Lua &eacute; uma linguagem de programa&ccedil;&atilde;o de extens&atilde;o projetada para
dar suporte &agrave; programa&ccedil;&atilde;o procedimental em geral e que oferece
facilidades para a descri&ccedil;&atilde;o de dados.
A linguagem tamb&eacute;m oferece um bom suporte para programa&ccedil;&atilde;o
orientada a objetos, programa&ccedil;&atilde;o funcional e programa&ccedil;&atilde;o
orientada a dados.
Lua foi planejada para ser utilizada por qualquer aplica&ccedil;&atilde;o
que necessite de uma linguagem de script leve e poderosa.
Lua &eacute; implementada como uma biblioteca, escrita em C <em>limpo</em>
(isto &eacute;, no subconjunto comum de ANSI&nbsp;C e C++).


<p>
Por ser uma linguagem de extens&atilde;o, Lua n&atilde;o possui a no&ccedil;&atilde;o de um
programa principal: ela somente funciona <em>embarcada</em> em um
programa cliente anfitri&atilde;o, chamado de <em>programa hospedeiro</em> ou simplesmente
de <em>hospedeiro</em>.
Esse programa hospedeiro pode invocar fun&ccedil;&otilde;es para executar um peda&ccedil;o
de c&oacute;digo Lua, pode escrever e ler vari&aacute;veis Lua e pode registrar
fun&ccedil;&otilde;es&nbsp;C para serem chamadas pelo c&oacute;digo Lua. 
Atrav&eacute;s do uso de fun&ccedil;&otilde;es&nbsp;C, Lua pode ser estendida para lidar
de maneira apropriada com uma ampla variedade de dom&iacute;nios,
permitindo assim a cria&ccedil;&atilde;o de linguagems de programa&ccedil;&atilde;o personalizadas
que compartilham um arcabou&ccedil;o sint&aacute;tico.
A distribui&ccedil;&atilde;o Lua inclui um exemplo de um programa hospedeiro chamado
<code>lua</code>, o qual usa a biblioteca de Lua para oferecer um interpretador
de linha de comando Lua completo.


<p>
Lua &eacute; um software livre e, como de praxe, &eacute; fornecido sem garantias,
conforme dito na sua licen&ccedil;a.
A implementa&ccedil;&atilde;o descrita neste manual est&aacute; dispon&iacute;vel
no s&iacute;tio web oficial de Lua, <code>www.lua.org</code>.


<p>
Como qualquer outro manual de refer&ecirc;ncia,
este documento &eacute; &aacute;rido em algumas partes.
Para uma discuss&atilde;o das decis&otilde;es por tr&aacute;s do projeto de Lua,
veja os artigos t&eacute;cnicos dispon&iacute;veis no s&iacute;tio web oficial de Lua.
Para uma introdu&ccedil;&atilde;o detalhada &agrave; programa&ccedil;&atilde;o em Lua,
veja o livro de Roberto Ierusalimschy, <em>Programming in Lua (Segunda Edi&ccedil;&atilde;o)</em>.



<h1>2 - <a name="2">A Linguagem</a></h1>

<p>
Esta se&ccedil;&atilde;o descreve os aspectos l&eacute;xicos, sint&aacute;ticos e sem&acirc;nticos de Lua.
Em outras palavras,
esta se&ccedil;&atilde;o descreve
quais <em>itens l&eacute;xicos</em> s&atilde;o v&aacute;lidos,
como eles s&atilde;o combinados,
e qual o significado da sua combina&ccedil;&atilde;o.


<p>
As constru&ccedil;&otilde;es da linguagem ser&atilde;o explicadas usando a nota&ccedil;&atilde;o BNF estendida usual,
na qual
{<em>a</em>}&nbsp;significa&nbsp;0 ou mais <em>a</em>'s e
[<em>a</em>]&nbsp;significa um <em>a</em> opcional.
N&atilde;o-terminais s&atilde;o mostrados como non-terminal,
palavras-chave s&atilde;o mostradas como <b>kword</b>
e outros s&iacute;mbolos terminais s&atilde;o mostrados como `<b>=</b>&acute;.
A sintaxe completa de Lua pode ser encontrada em <a href="#8">&sect;8</a> no
fim deste manual.



<h2>2.1 - <a name="2.1">Conven&ccedil;&otilde;es L&eacute;xicas</a></h2>

<p>
Em Lua, <em>Nomes</em> (tamb&eacute;m chamados de <em>identificadores</em>)
podem ser qualquer cadeia de letras,
d&iacute;gitos, e sublinhados
que n&atilde;o come&ccedil;am com um d&iacute;gito.
Esta defini&ccedil;&atilde;o est&aacute; de acordo com a defini&ccedil;&atilde;o de nomes na maioria das linguagens.
(A defini&ccedil;&atilde;o de letras depende de qual &eacute; o idioma (<em>locale</em>):
qualquer caractere considerado alfab&eacute;tico pelo idioma corrente
pode ser usado como um identificador.)
Identificadores s&atilde;o usados para nomear vari&aacute;veis e campos de tabelas.


<p>
As seguintes <em>palavras-chave</em> s&atilde;o reservadas
e n&atilde;o podem ser utilizadas como nomes:


<pre>
     and       break     do        else      elseif
     end       false     for       function  if
     in        local     nil       not       or
     repeat    return    then      true      until     while
</pre>

<p>
Lua &eacute; uma linguagem que diferencia min&uacute;sculas de mai&uacute;sculas:
<code>and</code> &eacute; uma palavra reservada, mas <code>And</code> e <code>AND</code>
s&atilde;o dois nomes v&aacute;lidos diferentes.
Como conven&ccedil;&atilde;o, nomes que come&ccedil;am com um sublinhado seguido por
letras mai&uacute;sculas (tais como <a href="#pdf-_VERSION"><code>_VERSION</code></a>)
s&atilde;o reservados para vari&aacute;veis globais internas usadas por Lua.


<p>
As seguintes cadeias denotam outros itens l&eacute;xicos:

<pre>
     +     -     *     /     %     ^     #
     ==    ~=    &lt;=    &gt;=    &lt;     &gt;     =
     (     )     {     }     [     ]
     ;     :     ,     .     ..    ...
</pre>

<p>
<em>Cadeias de caracteres literais</em>
podem ser delimitadas atrav&eacute;s do uso de aspas simples ou aspas duplas,
e podem conter as seguintes seq&uuml;&ecirc;ncias de escape no estilo de C:
'<code>\a</code>' (campainha),
'<code>\b</code>' (backspace),
'<code>\f</code>' (alimenta&ccedil;&atilde;o de formul&aacute;rio),
'<code>\n</code>' (quebra de linha),
'<code>\r</code>' (retorno de carro),
'<code>\t</code>' (tabula&ccedil;&atilde;o horizontal),
'<code>\v</code>' (tabula&ccedil;&atilde;o vertical),
'<code>\\</code>' (barra invertida),
'<code>\"</code>' (cita&ccedil;&atilde;o [aspa dupla])
e '<code>\'</code>' (ap&oacute;strofo [aspa simples]).
Al&eacute;m disso, uma barra invertida seguida por uma quebra de linha real
resulta em uma quebra de linha na cadeia de caracteres.
Um caractere em uma cadeia de caracteres tamb&eacute;m pode ser especificado pelo seu valor num&eacute;rico
usando a seq&uuml;&ecirc;ncia de escape <code>\<em>ddd</em></code>,
onde <em>ddd</em> &eacute; uma seq&uuml;&ecirc;ncia de at&eacute; tr&ecirc;s d&iacute;gitos decimais.
(Note que se um caractere num&eacute;rico representado como um seq&uuml;&ecirc;ncia de escape for
seguido por um d&iacute;gito, a seq&uuml;&ecirc;ncia de escape deve possuir exatamente tr&ecirc;s d&iacute;gitos.)
Cadeias de caracteres em Lua podem conter qualquer valor de 8 bits, incluindo zeros dentro delas,
os quais podem ser especificados como '<code>\0</code>'.


<p>
Cadeias literais longas tamb&eacute;m podem ser definidas usando um formato longo
delimitado por <em>colchetes longos</em>.
Definimos uma <em>abertura de colchete longo de n&iacute;vel <em>n</em></em> como um
abre colchete seguido por <em>n</em> sinais de igual seguido por outro
abre colchete.
Dessa forma, uma abertura de colchete longo de n&iacute;vel&nbsp;0 &eacute; escrita como <code>[[</code>,
uma abertura de colchete longo de n&iacute;vel&nbsp;1 &eacute; escrita como <code>[=[</code>
e assim por diante.	
Um <em>fechamento de colchete longo</em> &eacute; definido de maneira similar;
por exemplo, um fechamento de colchete longo de n&iacute;vel&nbsp;4 &eacute; escrito como <code>]====]</code>.
Uma cadeia de caracteres longa come&ccedil;a com uma abertura de colchete longo de qualquer n&iacute;vel e
termina no primeiro fechamento de colchete longo do mesmo n&iacute;vel.
Literais expressos desta forma podem se estender por v&aacute;rias linhas,
n&atilde;o interpretam nenhuma seq&uuml;&ecirc;ncia de escape
e ignoram colchetes longos de qualquer outro n&iacute;vel.
Estes literais podem conter qualquer coisa, exceto um fechamento de colchete longo de
n&iacute;vel igual ao da abertura.


<p>
Por conveni&ecirc;ncia,
quando uma abertura de colchete longo &eacute; imediatamente seguida por uma quebra de linha,
a quebra de linha n&atilde;o &eacute; inclu&iacute;da na cadeia de caracteres.
Como exemplo, em um sistema usando ASCII
(no qual '<code>a</code>' &eacute; codificado como&nbsp;97,
quebra de linha &eacute; codificado como&nbsp;10 e '<code>1</code>' &eacute; codificado como&nbsp;49),
as cinco cadeias literais abaixo denotam a mesma cadeia:

<pre>
     a = 'alo\n123"'
     a = "alo\n123\""
     a = '\97lo\10\04923"'
     a = [[alo
     123"]]
     a = [==[
     alo
     123"]==]
</pre>

<p>
Uma <em>constante num&eacute;rica</em> pode ser escrita com uma parte decimal opcional
e com um expoente decimal opcional.
Lua tamb&eacute;m aceita constantes hexadecimais inteiras, atrav&eacute;s do uso do
prefixo <code>0x</code>.
Exemplos de constantes num&eacute;ricas v&aacute;lidas s&atilde;o:

<pre>
     3   3.0   3.1416   314.16e-2   0.31416E1   0xff   0x56
</pre>

<p>
Um <em>coment&aacute;rio</em> come&ccedil;a com um h&iacute;fen duplo (<code>--</code>)
em qualquer lugar, desde que fora de uma cadeia de caracteres.
Se o texto imediatamente depois de <code>--</code> n&atilde;o &eacute; uma abertura de colchete longo,
o coment&aacute;rio &eacute; um <em>coment&aacute;rio curto</em>,
o qual se estende at&eacute; o fim da linha.
Caso contr&aacute;rio, ele &eacute; um <em>coment&aacute;rio longo</em>,
que se estende at&eacute; o fechamento de colchete longo correspondente.
Coment&aacute;rios longos s&atilde;o freq&uuml;entemente usados para desabilitar c&oacute;digo temporariamente.





<h2>2.2 - <a name="2.2">Valores e Tipos</a></h2>

<p>
Lua &eacute; uma <em>linguagem dinamicamente tipada</em>.
Isto significa que
vari&aacute;veis n&atilde;o possuem tipos; somente valores possuem tipos.
N&atilde;o existe defini&ccedil;&atilde;o de tipos na linguagem.
Todos os valores carregam o seu pr&oacute;prio tipo.


<p>
Todos os valores em Lua s&atilde;o <em>valores de primeira classe</em>.
Isto significa que todos os valores podem ser armazenados em vari&aacute;veis,
passados como argumentos para outras fun&ccedil;&otilde;es e retornados como resultados.


<p>
Existem oito tipos b&aacute;sicos em Lua:
<em>nil</em>, <em>boolean</em>, <em>number</em>,
<em>string</em>, <em>function</em>, <em>userdata</em>,
<em>thread</em> e <em>table</em>.
<em>Nil</em> &eacute; o tipo do valor <b>nil</b>,
cuja propriedade principal &eacute; ser diferente de qualquer outro valor;
ele geralmente representa a aus&ecirc;ncia de um valor &uacute;til.
<em>Boolean</em> &eacute; o tipo dos valores <b>false</b> e <b>true</b>.
Tanto <b>nil</b> como <b>false</b> tornam uma condi&ccedil;&atilde;o falsa;
qualquer outro valor torna a condi&ccedil;&atilde;o verdadeira.
<em>Number</em> representa n&uacute;meros reais (ponto flutuante de precis&atilde;o dupla).
(&Eacute; f&aacute;cil construir interpretadores Lua que usem outra
representa&ccedil;&atilde;o interna para n&uacute;meros,
tais como precis&atilde;o simples de ponto flutuante ou inteiros longos;
veja o arquivo <code>luaconf.h</code>.)
O tipo <em>string</em> representa cadeias de caracteres.

Em Lua,
cadeias de caracteres podem conter qualquer caractere de 8 bits,
incluindo zeros ('<code>\0</code>') dentro dela (ver <a href="#2.1">&sect;2.1</a>). 


<p>
Lua pode chamar (e manipular) fun&ccedil;&otilde;es escritas em Lua e
fun&ccedil;&otilde;es escritas em C
(ver <a href="#2.5.8">&sect;2.5.8</a>).


<p>
O tipo <em>userdata</em> permite que
dados&nbsp;C arbitr&aacute;rios possam ser armazenados em vari&aacute;veis Lua.
Este tipo corresponde a um bloco de mem&oacute;ria e n&atilde;o tem opera&ccedil;&otilde;es
pr&eacute;-definidas em Lua,
exceto atribui&ccedil;&atilde;o e teste de identidade.
Contudo, atrav&eacute;s do uso de <em>metatables</em>,
o programador pode definir opera&ccedil;&otilde;es para valores userdata
(ver <a href="#2.8">&sect;2.8</a>).
Valores userdata n&atilde;o podem ser criados ou modificados em Lua,
somente atrav&eacute;s da API&nbsp;C.
Isto garante a integridade dos dados que pertencem ao programa
hospedeiro.


<p>
O tipo <em>thread</em> representa fluxos de execu&ccedil;&atilde;o independentes
e &eacute; usado para implementar co-rotinas (ver <a href="#2.11">&sect;2.11</a>).
N&atilde;o confunda o tipo thread de Lua com processos leves do sistema operacional.
Lua d&aacute; suporte a co-rotinas em todos os sistemas,
at&eacute; mesmo naqueles que n&atilde;o d&atilde;o suporte a processos leves.


<p>
O tipo <em>table</em> implementa arrays associativos,
isto &eacute;, arrays que podem ser indexados n&atilde;o apenas por n&uacute;meros,
mas por qualquer valor (exceto <b>nil</b>).
Tabelas podem ser <em>heterog&ecirc;neas</em>;
isto &eacute;, elas podem conter valores de todos os tipos (exceto <b>nil</b>).
Tabelas s&atilde;o o &uacute;nico mecanismo de estrutura&ccedil;&atilde;o de dados em Lua;
elas podem ser usadas para representar arrays comuns,
tabelas de s&iacute;mbolos, conjuntos, registros, grafos, &aacute;rvores, etc.
Para representar registros, Lua usa o nome do campo como um &iacute;ndice.
A linguagem d&aacute; suporte a esta representa&ccedil;&atilde;o oferecendo <code>a.name</code> como
um a&ccedil;&uacute;car sint&aacute;tico para <code>a["name"]</code>.
Existem v&aacute;rias maneiras convenientes de se criar tabelas em Lua
(ver <a href="#2.5.7">&sect;2.5.7</a>).


<p>
Da mesma forma que os &iacute;ndices,
o valor de um campo da tabela pode possuir qualquer tipo (exceto <b>nil</b>).
Em particular,
dado que fun&ccedil;&otilde;es s&atilde;o valores de primeira classe,
campos de tabela podem conter fun&ccedil;&otilde;es.
Portanto, tabelas podem tamb&eacute;m possuir <em>met&oacute;dos</em> (ver <a href="#2.5.9">&sect;2.5.9</a>).


<p>
Valores do tipo table, function, thread e userdata (completo) s&atilde;o <em>objetos</em>:
vari&aacute;veis n&atilde;o <em>cont&ecirc;m</em> realmente estes valores,
somente <em>refer&ecirc;ncias</em> para eles.
Atribui&ccedil;&atilde;o, passagem de par&acirc;metro, e retorno de fun&ccedil;&otilde;es
sempre lidam com refer&ecirc;ncias para tais valores;
estas opera&ccedil;&otilde;es n&atilde;o implicam em qualquer esp&eacute;cie de c&oacute;pia.


<p>
A fun&ccedil;&atilde;o <a href="#pdf-type"><code>type</code></a> retorna uma cadeia de caracteres descrevendo o tipo
de um dado valor.



<h3>2.2.1 - <a name="2.2.1">Coer&ccedil;&atilde;o</a></h3>

<p>
Lua prov&ecirc; convers&atilde;o autom&aacute;tica entre
valores do tipo string e do tipo number em tempo de execu&ccedil;&atilde;o.
Qualquer opera&ccedil;&atilde;o aritm&eacute;tica aplicada a uma cadeia de caracteres tenta converter
esta cadeia para um n&uacute;mero, seguindo as regras de convers&atilde;o usuais.
De forma an&aacute;loga, sempre que um n&uacute;mero &eacute; usado onde uma cadeia de caracteres &eacute; esperada,
o n&uacute;mero &eacute; convertido para uma cadeia, em um formato razo&aacute;vel.
Para um controle completo sobre como n&uacute;meros s&atilde;o convertidos para cadeias,
use a fun&ccedil;&atilde;o <code>format</code> da biblioteca string (ver <a href="#pdf-string.format"><code>string.format</code></a>).







<h2>2.3 - <a name="2.3">Vari&aacute;veis</a></h2>

<p>
Vari&aacute;veis s&atilde;o lugares usados para armazenar valores.



<p>
Existem tr&ecirc;s tipos de vari&aacute;veis em Lua:
vari&aacute;veis globais, vari&aacute;veis locais e campos de tabelas.


<p>
Um nome simples pode denotar uma vari&aacute;vel global ou uma vari&aacute;vei local
(ou um par&acirc;metro formal de uma fun&ccedil;&atilde;o, que &eacute; um caso particular de vari&aacute;vel local):

<pre>
	var ::= Nome
</pre><p>
Nome denota identificadores, como definido em <a href="#2.1">&sect;2.1</a>.


<p>
Assume-se que toda vari&aacute;vel &eacute; uma vari&aacute;vel global a menos que ela seja explicitamente declarada
como uma vari&aacute;vel local (ver <a href="#2.4.7">&sect;2.4.7</a>).
Vari&aacute;veis locais possuem <em>escopo l&eacute;xico</em>:
vari&aacute;veis locais podem ser livremente acessadas por fun&ccedil;&otilde;es
definidas dentro do seu escopo (ver <a href="#2.6">&sect;2.6</a>).


<p>
Antes da vari&aacute;vel receber a sua primeira atribui&ccedil;&atilde;o, o seu valor &eacute; <b>nil</b>.


<p>
Colchetes s&atilde;o usados para indexar uma tabela:

<pre>
	var ::= expprefixo `<b>[</b>&acute; exp `<b>]</b>&acute;
</pre><p>
A sem&acirc;ntica de acessos a vari&aacute;veis globais
e a campos de tabelas pode ser mudada atrav&eacute;s do uso de metatabelas.
Um acesso a uma vari&aacute;vel indexada <code>t[i]</code> &eacute; equivalente a
uma chamada <code>gettable_event(t,i)</code>.
(Veja <a href="#2.8">&sect;2.8</a> para uma descri&ccedil;&atilde;o completa da
fun&ccedil;&atilde;o <code>gettable_event</code>.
Esta fun&ccedil;&atilde;o n&atilde;o &eacute; definida nem pode ser chamada em Lua.
Ela &eacute; usada aqui somente para fins did&aacute;ticos.)


<p>
A sintaxe <code>var.Nome</code> &eacute; apenas um a&ccedil;&uacute;car sint&aacute;tico para
<code>var["Nome"]</code>:

<pre>
	var ::= expprefixo `<b>.</b>&acute; Nome
</pre>

<p>
Todas as vari&aacute;veis globais s&atilde;o mantidas como campos em tabelas Lua comuns,
chamadas de <em>tabelas de ambiente</em> ou simplesmente
de <em>ambientes</em> (ver <a href="#2.9">&sect;2.9</a>).
Cada fun&ccedil;&atilde;o tem sua pr&oacute;pria refer&ecirc;ncia para um ambiente,
de forma que todas as vari&aacute;veis globais dentro de uma fun&ccedil;&atilde;o
ir&atilde;o se referir para esta tabela de ambiente.
Quando uma fun&ccedil;&atilde;o &eacute; criada,
ela herda o ambiente da fun&ccedil;&atilde;o que a criou.
Para obter a tabela de ambiente de uma fun&ccedil;&atilde;o Lua,
voc&ecirc; deve chamar <a href="#pdf-getfenv"><code>getfenv</code></a>.
Para trocar a tabela de ambiente,
voc&ecirc; deve chamar <a href="#pdf-setfenv"><code>setfenv</code></a>.
(A &uacute;nica maneira de tratar o ambiente de fun&ccedil;&otilde;es&nbsp;C
&eacute; atrav&eacute;s da a biblioteca de depura&ccedil;&atilde;o; (ver <a href="#5.9">&sect;5.9</a>).)


<p>
Um acesso a uma vari&aacute;vel global <code>x</code>
&eacute; equivalente a <code>_env.x</code>,
que por sua vez &eacute; equivalente a

<pre>
     gettable_event(_env, "x")
</pre><p>
onde <code>_env</code> &eacute; o ambiente da fun&ccedil;&atilde;o corrente.
(Veja <a href="#2.8">&sect;2.8</a> para uma descri&ccedil;&atilde;o completa da
fun&ccedil;&atilde;o <code>gettable_event</code>.
Esta fun&ccedil;&atilde;o n&atilde;o &eacute; definida nem pode ser chamada em Lua.
De modo an&aacute;logo, a vari&aacute;vel <code>_env</code> n&atilde;o &eacute; definida em Lua.
Elas foram usadas aqui somente para fins did&aacute;ticos.)





<h2>2.4 - <a name="2.4">Comandos</a></h2>

<p>
Lua oferece um conjunto quase convencional de comandos,
similar ao conjunto de comandos dispon&iacute;veis em Pascal ou C.
Este conjunto inclui
atribui&ccedil;&otilde;es, estruturas de controle, chamadas de fun&ccedil;&otilde;es
e declara&ccedil;&otilde;es de vari&aacute;veis.



<h3>2.4.1 - <a name="2.4.1">Trechos</a></h3>

<p>
A unidade de execu&ccedil;&atilde;o de Lua &eacute; denominada de <em>trecho</em>.
Um trecho &eacute; simplesmente uma seq&uuml;&ecirc;ncia de comandos,
os quais s&atilde;o executados sequencialmente.
Cada comando pode opcionalmente ser seguido por um ponto-e-v&iacute;rgula:

<pre>
	trecho ::= {comando [`<b>;</b>&acute;]}
</pre><p>
N&atilde;o existem comandos vazios e portanto a constru&ccedil;&atilde;o '<code>;;</code>' n&atilde;o &eacute; v&aacute;lida.


<p>
Lua trata um trecho como o corpo de uma fun&ccedil;&atilde;o an&ocirc;nima
com um n&uacute;mero vari&aacute;vel de argumentos
(ver <a href="#2.5.9">&sect;2.5.9</a>).
Desta forma, trechos podem definir vari&aacute;veis locais,
receber argumentos e retornar valores.


<p>
Um trecho pode ser armazenado em um arquivo ou em uma cadeia de caracteres dentro do programa hospedeiro.
Para executar um trecho,
Lua primeiro pr&eacute;-compila o trecho em instru&ccedil;&otilde;es para uma m&aacute;quina virtual
e depois executa o c&oacute;digo compilado
com um interpretador para a m&aacute;quina virtual.


<p>
Trechos tamb&eacute;m podem ser pr&eacute;-compilados em uma forma bin&aacute;ria;
veja o programa <code>luac</code> para mais detalhes.
Programas na forma de c&oacute;digo fonte e na forma de um arquivo fonte j&aacute; compilado s&atilde;o intercambi&aacute;veis;
Lua automaticamente determina qual &eacute; o tipo do arquivo e age em conformidade com ele.






<h3>2.4.2 - <a name="2.4.2">Blocos</a></h3><p>
Um bloco &eacute; uma lista de comandos;
sintaticamente, um bloco &eacute; a mesma coisa que um trecho:

<pre>
	bloco ::= trecho
</pre>

<p>
Um bloco pode ser explicitamente delimitado para produzir um &uacute;nico comando:

<pre>
	comando ::= <b>do</b> bloco <b>end</b>
</pre><p>
Blocos expl&iacute;citos s&atilde;o &uacute;teis
para controlar o escopo de declara&ccedil;&otilde;es de vari&aacute;veis.
Blocos expl&iacute;citos s&atilde;o tamb&eacute;m usados &agrave;s vezes para
adicionar um comando <b>return</b> ou <b>break</b> no meio
de outro bloco (ver <a href="#2.4.4">&sect;2.4.4</a>).





<h3>2.4.3 - <a name="2.4.3">Atribui&ccedil;&atilde;o</a></h3>

<p>
Lua permite atribui&ccedil;&otilde;es m&uacute;ltiplas.
Em virtude disto, a sintaxe para atribui&ccedil;&atilde;o
define uma lista de vari&aacute;veis no lado esquerdo
e uma lista de express&otilde;es no lado direito.
Os elementos em ambos os lados s&atilde;o separados por v&iacute;rgulas:

<pre>
	comando ::= listavar `<b>=</b>&acute; listaexp
	listavar ::= var {`<b>,</b>&acute; var}
	listaexp ::= exp {`<b>,</b>&acute; exp}
</pre><p>
Express&otilde;es s&atilde;o discutidas em <a href="#2.5">&sect;2.5</a>.


<p>
Antes da atribui&ccedil;&atilde;o ser realizada,
a lista de valores &eacute; <em>ajustada</em> para o comprimento da
lista de vari&aacute;veis.
Se h&aacute; mais valores do que o necess&aacute;rio,
os valores em excesso s&atilde;o descartados.
Se h&aacute; menos valores do que o necess&aacute;rio,
a lista &eacute; estendida com tantos <b>nil</b>'s quantos sejam necess&aacute;rios.
Se a lista de express&otilde;es termina com uma chamada de fun&ccedil;&atilde;o,
ent&atilde;o todos os valores retornados por esta chamada entram na lista de valores,
antes do ajuste ser realizado
(exceto quando a chamada &eacute; delimitada por par&ecirc;nteses; veja <a href="#2.5">&sect;2.5</a>).


<p>
Um comando de atribui&ccedil;&atilde;o primeiro avalia todas as suas express&otilde;es
e somente depois &eacute; que a atribui&ccedil;&atilde;o &eacute; realizada.
Desta forma, o c&oacute;digo

<pre>
     i = 3
     i, a[i] = i+1, 20
</pre><p>
atribui 20 a <code>a[3]</code>, sem afetar <code>a[4]</code>
porque o <code>i</code> em <code>a[i]</code> &eacute; avaliado (para 3)
antes de receber o valor&nbsp;4.
De modo similar, a linha

<pre>
     x, y = y, x
</pre><p>
troca os valores de <code>x</code> e <code>y</code>
e

<pre>
     x, y, z = y, z, x
</pre><p>
permuta de maneira c&iacute;clica os valores de <code>x</code>, <code>y</code> e <code>z</code>.


<p>
A sem&acirc;ntica de atribui&ccedil;&otilde;es para vari&aacute;veis globais
e campos de tabelas pode ser mudada atrav&eacute;s do uso de metatabelas.
Uma atribui&ccedil;&atilde;o para uma vari&aacute;vel indexada <code>t[i] = val</code> &eacute; equivalente a
<code>settable_event(t,i,val)</code>.
(Veja <a href="#2.8">&sect;2.8</a> para uma descri&ccedil;&atilde;o completa da
fun&ccedil;&atilde;o <code>settable_event</code>.
Esta fun&ccedil;&atilde;o n&atilde;o &eacute; definida nem pode ser chamada em Lua.
Ela foi usada aqui somente para fins did&aacute;ticos.)


<p>
Uma atribui&ccedil;&atilde;o a uma vari&aacute;vel global <code>x = val</code>
&eacute; equivalente &agrave; atribui&ccedil;&atilde;o
<code>_env.x = val</code>,
que por sua vez &eacute; equivalente a

<pre>
     settable_event(_env, "x", val)
</pre><p>
onde <code>_env</code> &eacute; o ambiente da fun&ccedil;&atilde;o sendo executada.
(A vari&aacute;vel <code>_env</code> n&atilde;o &eacute; definida em Lua.
Ela foi usada aqui somente para fins did&aacute;ticos.)





<h3>2.4.4 - <a name="2.4.4">Estruturas de Controle</a></h3><p>
As estruturas de controle
<b>if</b>, <b>while</b> e <b>repeat</b> possuem o significado usual e
a sintaxe familiar:




<pre>
	comando ::= <b>while</b> exp <b>do</b> bloco <b>end</b>
	comando ::= <b>repeat</b> bloco <b>until</b> exp
	comando ::= <b>if</b> exp <b>then</b> bloco {<b>elseif</b> exp <b>then</b> bloco} [<b>else</b> bloco] <b>end</b>
</pre><p>
Lua tamb&eacute;m possui um comando <b>for</b>, o qual possui duas varia&ccedil;&otilde;es (ver <a href="#2.4.5">&sect;2.4.5</a>).


<p>
A express&atilde;o da condi&ccedil;&atilde;o de uma
estrutura de controle pode retornar qualquer valor.
Tanto <b>false</b> como <b>nil</b> s&atilde;o considerados um valor falso.
Todos os valores diferentes de <b>nil</b> e <b>false</b> s&atilde;o considerados como verdadeiros
(em particular, o n&uacute;mero 0 e a cadeia de caracteres vazia tamb&eacute;m s&atilde;o considerados valores verdadeiros).


<p>
No la&ccedil;o <b>repeat</b>&ndash;<b>until</b>,
o bloco mais interno n&atilde;o termina na palavra-chave <b>until</b>,
mas somente depois da condi&ccedil;&atilde;o.
Desta forma, a condi&ccedil;&atilde;o pode referenciar vari&aacute;veis locais
declaradas dentro do bloco do la&ccedil;o.


<p>
O comando <b>return</b> &eacute; usado para retornar valores
de uma fun&ccedil;&atilde;o ou de um trecho (que nada mais &eacute; do que uma fun&ccedil;&atilde;o).

Fun&ccedil;&otilde;es e trechos podem retornar mais de um valor,
de modo que a sintaxe para o comando <b>return</b> &eacute;

<pre>
	comando ::= <b>return</b> [listaexp]
</pre>

<p>
O comando <b>break</b> &eacute; usado para terminar a execu&ccedil;&atilde;o de um
la&ccedil;o <b>while</b>, <b>repeat</b> ou <b>for</b>,
pulando para o pr&oacute;ximo comando depois do la&ccedil;o:


<pre>
	comando ::= <b>break</b>
</pre><p>
Um <b>break</b> termina a execu&ccedil;&atilde;o do la&ccedil;o mais interno.


<p>
Os comandos <b>return</b> e <b>break</b>
somente podem ser escritos como o <em>&uacute;ltimo</em> comando de um bloco.
Se &eacute; realmente necess&aacute;rio ter um <b>return</b> ou <b>break</b> no
meio de um bloco,
ent&atilde;o um bloco interno expl&iacute;cito pode ser usado,
como nas express&otilde;es idiom&aacute;ticas
<code>do return end</code> e <code>do break end</code>,
pois agora tanto o <b>return</b> como o <b>break</b> s&atilde;o os &uacute;ltimos comandos
em seus respectivos blocos (internos).





<h3>2.4.5 - <a name="2.4.5">Comando for</a></h3>

<p>

O comando <b>for</b> possui duas varia&ccedil;&otilde;es:
uma num&eacute;rica e outra gen&eacute;rica.


<p>
O la&ccedil;o <b>for</b> num&eacute;rico repete um bloco de c&oacute;digo enquanto uma
vari&aacute;vel de controle varia de acordo com uma progress&atilde;o aritm&eacute;tica.
Ele possui a seguinte sintaxe:

<pre>
	comando ::= <b>for</b> nome `<b>=</b>&acute; exp `<b>,</b>&acute; exp [`<b>,</b>&acute; exp] <b>do</b> bloco <b>end</b>
</pre><p>
O <em>bloco</em> &eacute; repetido para <em>nome</em> come&ccedil;ando com o valor da
primeira <em>exp</em>, at&eacute; que ele passe o valor da segunda <em>exp</em> atrav&eacute;s de
seguidos passos, sendo que a cada passo o valor da terceira <em>exp</em> &eacute; somado a <em>nome</em>.
De forma mais precisa, um comando <b>for</b> como

<pre>
     for v = <em>e1</em>, <em>e2</em>, <em>e3</em> do <em>bloco</em> end
</pre><p>
&eacute; equivalente ao c&oacute;digo:

<pre>
     do
       local <em>var</em>, <em>limite</em>, <em>passo</em> = tonumber(<em>e1</em>), tonumber(<em>e2</em>), tonumber(<em>e3</em>)
       if not (<em>var</em> and <em>limite</em> and <em>passo</em>) then error() end
       while (<em>passo</em> &gt; 0 and <em>var</em> &lt;= <em>limite</em>) or (<em>passo</em> &lt;= 0 and <em>var</em> &gt;= <em>limite</em>) do
         local v = <em>var</em>
         <em>bloco</em>
         <em>var</em> = <em>var</em> + <em>passo</em>
       end
     end
</pre><p>
Note o seguinte:

<ul>

<li>
Todas as tr&ecirc;s express&otilde;es de controle s&atilde;o avaliadas um &uacute;nica vez,
antes do la&ccedil;o come&ccedil;ar.
Elas devem obrigatoriamente produzir n&uacute;meros.
</li>

<li>
<code><em>var</em></code>, <code><em>limite</em></code> e <code><em>passo</em></code> s&atilde;o vari&aacute;veis invis&iacute;veis.
Os nomes foram utilizados aqui somente para fins did&aacute;ticos.
</li>

<li>
Se a terceira express&atilde;o (o passo) est&aacute; ausente,
ent&atilde;o um passo de&nbsp;tamanho&nbsp;1 &eacute; usado.
</li>

<li>
&Eacute; poss&iacute;vel usar <b>break</b> para sair de um la&ccedil;o <b>for</b>.
</li>

<li>
A vari&aacute;vel de la&ccedil;o <code>v</code> &eacute; local ao la&ccedil;o;
n&atilde;o &eacute; poss&iacute;vel usar o valor desta vari&aacute;vel ap&oacute;s o fim do <b>for</b> ou depois
do <b>for</b> ter sido interrompido pelo uso de um <b>break</b>.
Se voc&ecirc; precisa do valor desta vari&aacute;vel,
atribua-o a outra vari&aacute;vel antes de interromper ou sair do la&ccedil;o.
</li>

</ul>

<p>
O comando <b>for</b> gen&eacute;rico funciona utilizando fun&ccedil;&otilde;es,
chamadas de <em>iteradoras</em>.
A cada itera&ccedil;&atilde;o, a fun&ccedil;&atilde;o iteradora &eacute; chamada para produzir um novo valor,
parando quando este novo valor &eacute; <b>nil</b>.
O la&ccedil;o <b>for</b> gen&eacute;rico possui a seguinte sintaxe:

<pre>
	comando ::= <b>for</b> listadenomes <b>in</b> listaexp <b>do</b> bloco <b>end</b>
	listadenomes ::= Nome {`<b>,</b>&acute; Nome}
</pre><p>
Um comando <b>for</b> como

<pre>
     for <em>var_1</em>, &middot;&middot;&middot;, <em>var_n</em> in <em>explist</em> do <em>block</em> end
</pre><p>
&eacute; equivalente ao c&oacute;digo:

<pre>
     do
       local <em>f</em>, <em>s</em>, <em>var</em> = <em>explist</em>
       while true do
         local <em>var_1</em>, &middot;&middot;&middot;, <em>var_n</em> = <em>f</em>(<em>s</em>, <em>var</em>)
         <em>var</em> = <em>var_1</em>
         if <em>var</em> == nil then break end
         <em>block</em>
       end
     end
</pre><p>
Note o seguinte:

<ul>

<li>
<code><em>explist</em></code> &eacute; avaliada somente uma vez.
Os seus resultados s&atilde;o uma fun&ccedil;&atilde;o <em>iteradora</em>,
um <em>estado</em>
e um valor inicial para a primeira <em>vari&aacute;vel iteradora</em>.
</li>

<li>
<code><em>f</em></code>, <code><em>s</em></code> e <code><em>var</em></code> s&atilde;o vari&aacute;veis invis&iacute;veis.
Os nomes foram utilizados aqui somente para fins did&aacute;ticos.
</li>

<li>
&Eacute; poss&iacute;vel usar <b>break</b> para sair de um la&ccedil;o <b>for</b>.
</li>

<li>
As vari&aacute;veis de la&ccedil;o <code><em>var_i</em></code> s&atilde;o locais ao la&ccedil;o;
n&atilde;o &eacute; poss&iacute;vel usar os valores delas ap&oacute;s o t&eacute;rmino do <b>for</b>.
Se voc&ecirc; precisa destes valores,
voc&ecirc; deve atribu&iacute;-los a outras vari&aacute;veis antes de interromper o la&ccedil;o ou sair do mesmo.
</li>

</ul>




<h3>2.4.6 - <a name="2.4.6">Chamadas de Fun&ccedil;&atilde;o como Comandos</a></h3><p>
Para permitir poss&iacute;veis efeitos colaterais,
fun&ccedil;&otilde;es podem ser executadas como comandos:

<pre>
	comando ::= chamadadefuncao
</pre><p>
Neste caso, todos os valores retornados pela fun&ccedil;&atilde;o s&atilde;o descartados.
Chamadas de fun&ccedil;&atilde;o s&atilde;o explicadas em <a href="#2.5.8">&sect;2.5.8</a>.





<h3>2.4.7 - <a name="2.4.7">Declara&ccedil;&otilde;es Locais</a></h3><p>
Vari&aacute;veis locais podem ser declaradas em qualquer lugar dentro de um bloco.
A declara&ccedil;&atilde;o pode incluir uma atribui&ccedil;&atilde;o inicial:

<pre>
	comando ::= <b>local</b> listadenomes [`<b>=</b>&acute; listaexp]
</pre><p>
Caso ocorra uma atribui&ccedil;&atilde;o inicial, a sua sem&acirc;ntica &eacute; a mesma
de uma atribui&ccedil;&atilde;o m&uacute;ltipla (ver <a href="#2.4.3">&sect;2.4.3</a>).
Caso contr&aacute;rio, todas as vari&aacute;veis s&atilde;o inicializadas com <b>nil</b>.


<p>
Um trecho tamb&eacute;m &eacute; um bloco (ver <a href="#2.4.1">&sect;2.4.1</a>) e
portanto vari&aacute;veis locais podem ser declaradas em um trecho fora de qualquer bloco expl&iacute;cito.
O escopo de uma vari&aacute;vel declarada desta forma se estende at&eacute; o fim do trecho.


<p>
As regras de visibilidade para vari&aacute;veis locais s&atilde;o explicadas em <a href="#2.6">&sect;2.6</a>. 







<h2>2.5 - <a name="2.5">Express&otilde;es</a></h2>

<p>
As express&otilde;es b&aacute;sicas em Lua s&atilde;o as seguintes:

<pre>
	exp ::= expprefixo
	exp ::= <b>nil</b> | <b>false</b> | <b>true</b>
	exp ::= Numero
	exp ::= Cadeia
	exp ::= funcao
	exp ::= construtortabela
	exp ::= `<b>...</b>&acute;
	exp ::= exp opbin exp
	exp ::= opunaria exp
	expprefixo ::= var | chamadadefuncao | `<b>(</b>&acute; exp `<b>)</b>&acute;
</pre>

<p>
N&uacute;meros e cadeias literais s&atilde;o explicados em <a href="#2.1">&sect;2.1</a>;
vari&aacute;veis s&atilde;o explicadas em <a href="#2.3">&sect;2.3</a>;
defini&ccedil;&otilde;es de fun&ccedil;&otilde;es s&atilde;o explicadas em <a href="#2.5.9">&sect;2.5.9</a>;
chamadas de fun&ccedil;&otilde;es s&atilde;o explicadas em <a href="#2.5.8">&sect;2.5.8</a>;
construtores de tabelas s&atilde;o explicados em <a href="#2.5.7">&sect;2.5.7</a>.
Express&otilde;es <em>vararg</em>,
denotadas por tr&ecirc;s pontos ('<code>...</code>'), somente podem ser usadas quando
est&atilde;o imediatamente dentro de uma fun&ccedil;&atilde;o que possui um n&uacute;mero vari&aacute;vel de argumentos;
elas s&atilde;o explicadas em <a href="#2.5.9">&sect;2.5.9</a>.


<p>
Operadores bin&aacute;rios compreendem operadores aritm&eacute;ticos (ver <a href="#2.5.1">&sect;2.5.1</a>),
operadores relacionais (ver <a href="#2.5.2">&sect;2.5.2</a>), operadores l&oacute;gicos (ver <a href="#2.5.3">&sect;2.5.3</a>)
e o operador de concatena&ccedil;&atilde;o (ver <a href="#2.5.4">&sect;2.5.4</a>).
Operadores un&aacute;rios compreendem o menos un&aacute;rio (ver <a href="#2.5.1">&sect;2.5.1</a>),
o <b>not</b> un&aacute;rio (ver <a href="#2.5.3">&sect;2.5.3</a>)
e o <em>operador de comprimento</em> un&aacute;rio (ver <a href="#2.5.5">&sect;2.5.5</a>).


<p>
Tanto chamadas de fun&ccedil;&otilde;es como express&otilde;es vararg podem resultar em m&uacute;ltiplos valores.
Se uma express&atilde;o &eacute; usada como um comando
(o que somente &eacute; poss&iacute;vel para chamadas de fun&ccedil;&otilde;es (ver <a href="#2.4.6">&sect;2.4.6</a>)),
ent&atilde;o a sua lista de retorno &eacute; ajustada para zero elementos,
descartando portanto todos os valores retornados.
Se uma express&atilde;o &eacute; usada como o &uacute;ltimo (ou o &uacute;nico) elemento
de uma lista de express&otilde;es,
ent&atilde;o nenhum ajuste &eacute; feito
(a menos que a chamada seja delimitada por par&ecirc;nteses).
Em todos os demais contextos,
Lua ajusta a lista de resultados para um elemento,
descartando todos os valores exceto o primeiro.


<p>
Aqui est&atilde;o alguns exemplos:

<pre>
     f()                -- ajusta para 0 resultados
     g(f(), x)          -- f() &eacute; ajustado para 1 resultado
     g(x, f())          -- g recebe x mais todos os resultados de f()
     a,b,c = f(), x     -- f() &eacute; ajustado para 1 resultado (c recebe nil)
     a,b = ...          -- a recebe o primeiro par&acirc;metro da lista vararg,
                        -- b recebe o segundo (tanto a como b podem receber nil caso n&atilde;o
                        -- exista um par&acirc;metro correspondente na lista)
     
     a,b,c = x, f()     -- f() &eacute; ajustado para 2 resultados
     a,b,c = f()        -- f() &eacute; ajustado para 3 resultados
     return f()         -- retorna todos os resultados de f()
     return ...         -- retorna todos os resultados recebidos da lista vararg
     return x,y,f()     -- retorna x, y e todos os resultados de f()
     {f()}              -- cria uma lista com todos os resultados de f()
     {...}              -- cria uma lista com todos os par&acirc;metros da lista vararg
     {f(), nil}         -- f() &eacute; ajustado para 1 resultado
</pre>

<p>
Qualquer express&atilde;o delimitada por par&ecirc;nteses sempre resulta em um &uacute;nico valor.
Dessa forma,
<code>(f(x,y,z))</code> &eacute; sempre um &uacute;nico valor,
mesmo que <code>f</code> retorne m&uacute;ltiplos valores.
(O valor de <code>(f(x,y,z))</code> &eacute; o primeiro valor retornado por <code>f</code>,
ou <b>nil</b> se <code>f</code> n&atilde;o retorna nenhum valor.)



<h3>2.5.1 - <a name="2.5.1">Operadores Aritm&eacute;ticos</a></h3><p>
Lua prov&ecirc; os operadores aritm&eacute;ticos usuais:
os operadores bin&aacute;rios <code>+</code> (adi&ccedil;&atilde;o),
<code>-</code> (subtra&ccedil;&atilde;o), <code>*</code> (multiplica&ccedil;&atilde;o),
<code>/</code> (divis&atilde;o), <code>%</code> (m&oacute;dulo) e <code>^</code> (exponencia&ccedil;&atilde;o);
e o operador un&aacute;rio <code>-</code> (nega&ccedil;&atilde;o).
Se os operandos s&atilde;o n&uacute;meros ou cadeias de caracteres que podem ser convertidas para
n&uacute;meros (ver <a href="#2.2.1">&sect;2.2.1</a>),
ent&atilde;o todas as opera&ccedil;&otilde;es possuem o seu significado usual.
A exponencia&ccedil;&atilde;o funciona para qualquer expoente.
Por exemplo, <code>x^(-0.5)</code> calcula o inverso da raiz quadrada de <code>x</code>.
M&oacute;dulo &eacute; definido como

<pre>
     a % b == a - math.floor(a/b)*b
</pre><p>
Ou seja, &eacute; o resto de uma divis&atilde;o arredondada
em dire&ccedil;&atilde;o a menos infinito.





<h3>2.5.2 - <a name="2.5.2">Operadores Relacionais</a></h3><p>
Os operadores relacionais em Lua s&atilde;o

<pre>
     ==    ~=    &lt;     &gt;     &lt;=    &gt;=
</pre><p>
Estes operadores sempre possuem como resultado <b>false</b> ou <b>true</b>.


<p>
A igualdade (<code>==</code>) primeiro compara o tipo de seus operandos.
Se os tipos s&atilde;o diferentes, ent&atilde;o o resultado &eacute; <b>false</b>.
Caso contr&aacute;rio, os valores dos operandos s&atilde;o comparados.
N&uacute;meros e cadeias de caracteres s&atilde;o comparados de maneira usual.
Objetos (valores do tipo table, userdata, thread e function)
s&atilde;o comparados por <em>refer&ecirc;ncia</em>:
dois objetos s&atilde;o considerados iguais somente se eles s&atilde;o o <em>mesmo</em> objeto.
Toda vez que um novo objeto &eacute; criado
(um valor com tipo table, userdata, thread ou function)
este novo objeto &eacute; diferente de qualquer outro objeto que existia anteriormente.


<p>
&Eacute; poss&iacute;vel mudar a maneira como Lua compara os tipos table e userdata
atrav&eacute;s do uso do metam&eacute;todo "eq" (ver <a href="#2.8">&sect;2.8</a>).


<p>
As regras de convers&atilde;o em <a href="#2.2.1">&sect;2.2.1</a>
<em>n&atilde;o</em> se aplicam a compara&ccedil;&otilde;es de igualdade.
Portanto, <code>"0"==0</code> &eacute; avaliado como <b>false</b>
e <code>t[0]</code> e <code>t["0"]</code> denotam posi&ccedil;&otilde;es
diferentes em uma tabela.


<p>
O operador <code>~=</code> &eacute; exatamente a nega&ccedil;&atilde;o da igualdade (<code>==</code>).


<p>
Os operadores de ordem trabalham da seguinte forma.
Se ambos os argumentos s&atilde;o n&uacute;meros, ent&atilde;o eles s&atilde;o comparados como tais.
Caso contr&aacute;rio, se ambos os argumentos s&atilde;o cadeias de caracteres,
ent&atilde;o seus valores s&atilde;o comparados de acordo com a escolha de idioma atual.
Caso contr&aacute;rio, Lua tenta chamar o metam&eacute;todo "lt" ou o metam&eacute;todo "le"
(ver <a href="#2.8">&sect;2.8</a>).
Uma compara&ccedil;&atilde;o <code>a &gt; b</code> &eacute; traduzida para <code>b &lt; a</code>,
ao passo que <code>a &gt;= b</code> &eacute; traduzida para <code>b &lt;= a</code>.





<h3>2.5.3 - <a name="2.5.3">Operadores L&oacute;gicos</a></h3><p>
Os operadores l&oacute;gicos em Lua s&atilde;o
<b>and</b>, <b>or</b> e <b>not</b>.
Assim como as estruturas de controle (ver <a href="#2.4.4">&sect;2.4.4</a>),
todos os operadores l&oacute;gicos consideram <b>false</b> e <b>nil</b> como falso
e qualquer coisa diferente como verdadeiro.


<p>
O operador de nega&ccedil;&atilde;o <b>not</b> sempre retorna <b>false</b> ou <b>true</b>.
O operador de conjun&ccedil;&atilde;o <b>and</b> retorna seu primeiro argumento
se este valor &eacute; <b>false</b> ou <b>nil</b>;
caso contr&aacute;rio, <b>and</b> retorna seu segundo argumento.
O operador de disjun&ccedil;&atilde;o <b>or</b> retorna seu primeiro argumento
se o valor deste &eacute; diferente de <b>nil</b> e de <b>false</b>;
caso contr&aacute;rio, <b>or</b> retorna o seu segundo argumento.
Tanto <b>and</b> como <b>or</b> usam avalia&ccedil;&atilde;o de curto-circuito;
isto &eacute;,
o segundo operando &eacute; avaliado somente quando &eacute; necess&aacute;rio.
Aqui est&atilde;o alguns exemplos:

<pre>
     10 or 20            --&gt; 10
     10 or error()       --&gt; 10
     nil or "a"          --&gt; "a"
     nil and 10          --&gt; nil
     false and error()   --&gt; false
     false and nil       --&gt; false
     false or nil        --&gt; nil
     10 and 20           --&gt; 20
</pre><p>
(Neste manual,
<code>--&gt;</code> indica o resultado da express&atilde;o precedente.)





<h3>2.5.4 - <a name="2.5.4">Concatena&ccedil;&atilde;o</a></h3><p>
O operador de concatena&ccedil;&atilde;o de cadeias de caracteres em Lua &eacute;
denotado por dois pontos ('<code>..</code>').
Se ambos os operandos s&atilde;o cadeias de caracteres ou n&uacute;meros, ent&atilde;o eles s&atilde;o convertidos para
cadeias de caracteres de acordo com as regras mencionadas em <a href="#2.2.1">&sect;2.2.1</a>.
Caso contr&aacute;rio, o metam&eacute;todo "concat" &eacute; chamado (ver <a href="#2.8">&sect;2.8</a>).





<h3>2.5.5 - <a name="2.5.5">O Operador de Comprimento</a></h3>

<p>
O operador de comprimento &eacute; denotado pelo operador un&aacute;rio <code>#</code>.
O comprimento de uma cadeia de caracteres &eacute; o seu n&uacute;mero de bytes
(isto &eacute;, o significado usual de comprimento de uma cadeia quando
cada caractere ocupa um byte).


<p>
O comprimento de uma tabela <code>t</code> &eacute; definido como qualquer
&iacute;ndice inteiro <code>n</code>
tal que <code>t[n]</code> n&atilde;o &eacute; <b>nil</b> e <code>t[n+1]</code> &eacute; <b>nil</b>;
al&eacute;m disso, se <code>t[1]</code> &eacute; <b>nil</b>, <code>n</code> pode ser zero.
Para um array comum, com todos os valores diferentes de <b>nil</b> indo de 1 at&eacute; um dado <code>n</code>,
o seu comprimento &eacute; exatamente aquele <code>n</code>,
o &iacute;ndice do seu &uacute;ltimo valor.
Se o array possui "buracos"
(isto &eacute;, valores <b>nil</b> entre dois outros valores diferentes de <b>nil</b>),
ent&atilde;o <code>#t</code> pode ser qualquer um dos &iacute;ndices que
imediatamente precedem um valor <b>nil</b>
(isto &eacute;, ele pode considerar qualquer valor <b>nil</b> como o fim do
array).





<h3>2.5.6 - <a name="2.5.6">Preced&ecirc;ncia</a></h3><p>
A preced&ecirc;ncia de operadores em Lua segue a tabela abaixo,
da menor prioridade para a maior:

<pre>
     or
     and
     &lt;     &gt;     &lt;=    &gt;=    ~=    ==
     ..
     +     -
     *     /     %
     not   #     - (unary)
     ^
</pre><p>
Como &eacute; de costume,
voc&ecirc; pode usar par&ecirc;nteses para mudar as preced&ecirc;ncias de uma express&atilde;o.
Os operadores de concatena&ccedil;&atilde;o ('<code>..</code>') e de exponencia&ccedil;&atilde;o ('<code>^</code>')
s&atilde;o associativos &agrave; direita.
Todos os demais operadores bin&aacute;rios s&atilde;o associativos &agrave; esquerda.





<h3>2.5.7 - <a name="2.5.7">Construtores de Tabelas</a></h3><p>
Construtores de tabelas s&atilde;o express&otilde;es que criam tabelas.
Toda vez que um construtor &eacute; avaliado, uma nova tabela &eacute; criada.
Um construtor pode ser usado para criar uma tabelas vazia
ou para criar uma tabela e inicializar alguns dos seus campos.
A sintaxe geral de construtores &eacute;

<pre>
	construtortabela ::= `<b>{</b>&acute; [listadecampos] `<b>}</b>&acute;
	listadecampos ::= campo {separadordecampos campo} [separadordecampos]
	campo ::= `<b>[</b>&acute; exp `<b>]</b>&acute; `<b>=</b>&acute; exp | Nome `<b>=</b>&acute; exp | exp
	separadordecampos ::= `<b>,</b>&acute; | `<b>;</b>&acute;
</pre>

<p>
Cada campo da forma <code>[exp1] = exp2</code> adiciona &agrave; nova tabela uma entrada
cuja chave &eacute; <code>exp1</code> e cujo valor &eacute; <code>exp2</code>.
Um campo da forma <code>Nome = exp</code> &eacute; equivalente a
<code>["Nome"] = exp</code>.
Finalmente, campos da forma <code>exp</code> s&atilde;o equivalentes a
<code>[i] = exp</code>, onde <code>i</code> representa n&uacute;meros inteiros consecutivos,
iniciando com 1.
Campos nos outros formatos n&atilde;o afetam esta contagem.
Por exemplo,

<pre>
     a = { [f(1)] = g; "x", "y"; x = 1, f(x), [30] = 23; 45 }
</pre><p>
&eacute; equivalente a

<pre>
     do
       local t = {}
       t[f(1)] = g
       t[1] = "x"         -- primeira exp
       t[2] = "y"         -- segunda exp
       t.x = 1            -- t["x"] = 1
       t[3] = f(x)        -- terceira exp
       t[30] = 23
       t[4] = 45          -- quarta exp
       a = t
     end
</pre>

<p>
Se o &uacute;ltimo campo na lista possui a forma <code>exp</code>
e a express&atilde;o &eacute; uma chamada de fun&ccedil;&atilde;o ou uma express&atilde;o com um n&uacute;mero vari&aacute;vel de argumentos,
ent&atilde;o todos os valores retornados pela express&atilde;o entram na lista consecutivamente
(ver <a href="#2.5.8">&sect;2.5.8</a>).
Para evitar isto,
coloque par&ecirc;nteses ao redor da chamada de fun&ccedil;&atilde;o ou da express&atilde;o com
n&uacute;mero vari&aacute;vel de argumentos (ver <a href="#2.5">&sect;2.5</a>).


<p>
A lista de campos pode ter um separador a mais no fim,
como uma conveni&ecirc;ncia para c&oacute;digo gerado automaticamente.





<h3>2.5.8 - <a name="2.5.8">Chamadas de Fun&ccedil;&atilde;o</a></h3><p>
Uma chamada de fun&ccedil;&atilde;o em Lua tem a seguinte sintaxe:

<pre>
	chamadadefuncao ::= expprefixo args
</pre><p>
Em uma chamada de fun&ccedil;&atilde;o,
primeiro expprefixo e args s&atilde;o avaliados.
Se o valor de expprefixo possui tipo <em>function</em>,
ent&atilde;o esta fun&ccedil;&atilde;o &eacute; chamada
com os argumentos fornecidos.
Caso contr&aacute;rio, o metam&eacute;todo "call" de expprefixo &eacute; chamado,
tendo como primeiro par&acirc;metro o valor de expprefixo,
seguido pelos argumentos originais da chamada
(ver <a href="#2.8">&sect;2.8</a>).


<p>
A forma

<pre>
	chamadadefuncao ::= expprefixo `<b>:</b>&acute; Nome args
</pre><p>
pode ser usada para chamar "m&eacute;todos".
Uma chamada <code>v:nome(<em>args</em>)</code>
&eacute; um a&ccedil;&uacute;car sint&aacute;tico para <code>v.nome(v,<em>args</em>)</code>,
com a diferen&ccedil;a de que <code>v</code> &eacute; avaliado somente uma vez.


<p>
Argumentos possuem a seguinte sintaxe:

<pre>
	args ::= `<b>(</b>&acute; [listaexp] `<b>)</b>&acute;
	args ::= construtordetabela
	args ::= Cadeia
</pre><p>
Todas as express&otilde;es fornecidas como argumento s&atilde;o avaliadas antes da chamada.
Uma chamada da forma <code>f{<em>campos</em>}</code> &eacute;
uma a&ccedil;&uacute;car sint&aacute;tico para <code>f({<em>campos</em>})</code>;
ou seja, a lista de argumentos consiste somente em uma tabela nova.
Uma chamada da forma <code>f'<em>cadeia</em>'</code>
(ou <code>f"<em>cadeia</em>"</code> ou <code>f[[<em>cadeia</em>]]</code>)
&eacute; um a&ccedil;&uacute;car sint&aacute;tico para <code>f('<em>cadeia</em>')</code>;
ou seja, a lista de argumentos consiste somente em uma cadeia de caracteres literal.


<p>
Uma exce&ccedil;&atilde;o em rela&ccedil;&atilde;o &agrave; sintaxe de formato livre de Lua
&eacute; que n&atilde;o &eacute; poss&iacute;vel colocar uma quebra de linha antes do '<code>(</code>' em uma chamada de fun&ccedil;&atilde;o.
Esta restri&ccedil;&atilde;o evita algumas ambig&uuml;idades na linguagem.
Se voc&ecirc; escrevesse

<pre>
     a = f
     (g).x(a)
</pre><p>
Lua poderia ver isto como um comando &uacute;nico, <code>a = f(g).x(a)</code>.
Portanto, se voc&ecirc; deseja dois comandos, voc&ecirc; deve obrigatoriamente colocar um ponto-e-v&iacute;rgula entre eles.
Se voc&ecirc; realmente quer chamar <code>f</code>,
voc&ecirc; deve remover a quebra de linha antes de <code>(g)</code>.


<p>
Uma chamada da forma <code>return</code> <em>chamadadefuncao</em> &eacute; denominada
de <em>chamada final</em>.
Lua implementa <em>chamadas finais pr&oacute;prias</em>
(ou <em>recurs&otilde;es finais pr&oacute;prias</em>):
em uma chamada final,
a fun&ccedil;&atilde;o chamada reusa a entrada na pilha da fun&ccedil;&atilde;o que a chamou.
Portanto, n&atilde;o h&aacute; limite no n&uacute;mero de chamadas finais aninhadas que
um programa pode executar.
Contudo, uma chamada final apaga qualquer informa&ccedil;&atilde;o de depura&ccedil;&atilde;o sobre a
fun&ccedil;&atilde;o chamadora.
Note que uma chamada final somente acontece com uma sintaxe particular,
onde o <b>return</b> possui uma &uacute;nica chamada de fun&ccedil;&atilde;o como argumento;
esta sintaxe faz com que a chamada de fun&ccedil;&atilde;o retorne exatamente
os valores de retorno da fun&ccedil;&atilde;o chamada.
Dessa forma, nenhum dos exemplos a seguir s&atilde;o chamadas finais:

<pre>
     return (f(x))        -- o n&uacute;mero de resultados &eacute; ajustado para 1
     return 2 * f(x)
     return x, f(x)       -- resultados adicionais
     f(x); return         -- resultados descartados
     return x or f(x)     -- o n&uacute;mero de resultados &eacute; ajustado para 1
</pre>




<h3>2.5.9 - <a name="2.5.9">Defini&ccedil;&otilde;es de Fun&ccedil;&otilde;es</a></h3>

<p>
A sintaxe para a defini&ccedil;&atilde;o de uma fun&ccedil;&atilde;o &eacute;

<pre>
	funcao ::= <b>function</b> corpodafuncao
	funcao ::= `<b>(</b>&acute; [listapar] `<b>)</b>&acute; bloco <b>end</b>
</pre>

<p>
O seguinte a&ccedil;&uacute;car sint&aacute;tico simplifica defini&ccedil;&otilde;es de fun&ccedil;&otilde;es:

<pre>
	comando ::= <b>function</b> nomedafuncao corpodafuncao
	comando ::= <b>local</b> <b>function</b> Nome corpodafuncao
	nomedafuncao ::= Nome {`<b>.</b>&acute; Nome} [`<b>:</b>&acute; Nome]
</pre><p>
O comando

<pre>
     function f () <em>corpo</em> end
</pre><p>
&eacute; traduzido para

<pre>
     f = function () <em>corpo</em> end
</pre><p>
O comando

<pre>
     function t.a.b.c.f () <em>corpo</em> end
</pre><p>
&eacute; traduzido para

<pre>
     t.a.b.c.f = function () <em>corpo</em> end
</pre><p>
O comando

<pre>
     local function f () <em>corpo</em> end
</pre><p>
&eacute; traduzido para

<pre>
     local f; f = function () <em>corpo</em> end
</pre><p>
e <em>n&atilde;o</em> para

<pre>
     local f = function () <em>corpo</em> end
</pre><p>
(Isto somente faz diferen&ccedil;a quando o corpo da fun&ccedil;&atilde;o
 cont&eacute;m uma refer&ecirc;ncia para <code>f</code>.)


<p>
Uma defini&ccedil;&atilde;o de fun&ccedil;&atilde;o &eacute; uma express&atilde;o execut&aacute;vel,
cujo valor tem tipo <em>function</em>.
Quando Lua pr&eacute;-compila um trecho,
todos os corpos das fun&ccedil;&otilde;es do trecho s&atilde;o pr&eacute;-compilados tamb&eacute;m.
Ent&atilde;o, sempre que Lua executa a defini&ccedil;&atilde;o de uma fun&ccedil;&atilde;o,
a fun&ccedil;&atilde;o &eacute; <em>instanciada</em> (ou <em>fechada</em>).
Esta inst&acirc;ncia da fun&ccedil;&atilde;o (ou <em>fecho</em>)
&eacute; o valor final da express&atilde;o.
Inst&acirc;ncias diferentes da mesma fun&ccedil;&atilde;o
podem se referir a diferentes vari&aacute;veis locais externas
e podem ter diferentes tabelas de ambiente.


<p>
Par&acirc;metros comportam-se como vari&aacute;veis locais que s&atilde;o
inicializadas com os valores dos argumentos:

<pre>
	listapar ::= listadenomes [`<b>,</b>&acute; `<b>...</b>&acute;] | `<b>...</b>&acute;
</pre><p>
Quando uma fun&ccedil;&atilde;o &eacute; chamada,
a lista de argumentos &eacute; ajustada para
o comprimento da lista de par&acirc;metros,
a n&atilde;o ser que a fun&ccedil;&atilde;o seja de aridade vari&aacute;vel ou <em>vararg</em>,
o que &eacute;
indicado por tr&ecirc;s pontos ('<code>...</code>') no final da sua lista de par&acirc;metros.
Uma fun&ccedil;&atilde;o vararg n&atilde;o ajusta sua lista de argumentos;
ao inv&eacute;s disso, ela coleta todos os argumentos extras e os fornece
para a fun&ccedil;&atilde;o atrav&eacute;s de uma <em>express&atilde;o vararg</em>,
a qual tamb&eacute;m &eacute; representada como tr&ecirc;s pontos.
O valor desta express&atilde;o &eacute; uma lista de todos os argumentos extras correntes,
similar a uma fun&ccedil;&atilde;o com m&uacute;ltiplos valores de retorno.
Se uma express&atilde;o vararg &eacute; usada dentro de outra express&atilde;o
ou no meio de uma lista de express&otilde;es,
ent&atilde;o a sua lista de valores de retorno &eacute; ajustada para um elemento.
Se a express&atilde;o &eacute; usada como o &uacute;ltimo elemento de uma lista de express&otilde;es,
ent&atilde;o nenhum ajuste &eacute; feito
(a menos que a &uacute;ltima express&atilde;o seja delimitada por par&ecirc;nteses).


<p>
Como um exemplo, considere as seguintes defini&ccedil;&otilde;es:

<pre>
     function f(a, b) end
     function g(a, b, ...) end
     function r() return 1,2,3 end
</pre><p>
Neste caso, n&oacute;s temos o seguinte mapeamento de argumentos para par&acirc;metros e
para as express&otilde;es vararg:

<pre>
     CHAMADA          PAR&Acirc;METROS
     
     f(3)             a=3, b=nil
     f(3, 4)          a=3, b=4
     f(3, 4, 5)       a=3, b=4
     f(r(), 10)       a=1, b=10
     f(r())           a=1, b=2
     
     g(3)             a=3, b=nil, ... --&gt;  (nada)
     g(3, 4)          a=3, b=4,   ... --&gt;  (nada)
     g(3, 4, 5, 8)    a=3, b=4,   ... --&gt;  5  8
     g(5, r())        a=5, b=1,   ... --&gt;  2  3
</pre>

<p>
Resultados s&atilde;o retornados usando o comando <b>return</b> (ver <a href="#2.4.4">&sect;2.4.4</a>).
Se o controle alcan&ccedil;a o fim de uma fun&ccedil;&atilde;o
sem encontrar um comando <b>return</b>,
ent&atilde;o a fun&ccedil;&atilde;o retorna sem nenhum resultado.


<p>
A sintaxe de <em>dois pontos</em>
&eacute; usada para definir <em>m&eacute;todos</em>,
isto &eacute;, fun&ccedil;&otilde;es que possuem um par&acirc;metro extra impl&iacute;cito <code>self</code>.
Desta forma, o comando

<pre>
     function t.a.b.c:f (<em>params</em>) <em>corpo</em> end
</pre><p>
&eacute; uma a&ccedil;&uacute;car sint&aacute;tico para

<pre>
     t.a.b.c.f = function (self, <em>params</em>) <em>corpo</em> end
</pre>






<h2>2.6 - <a name="2.6">Regras de Visibilidade</a></h2>

<p>

Lua &eacute; uma linguagem com escopo l&eacute;xico.
O escopo das vari&aacute;veis come&ccedil;a no primeiro comando <em>depois</em>
da sua declara&ccedil;&atilde;o e vai at&eacute; o fim do bloco mais interno que
inclui a declara&ccedil;&atilde;o.
Considere o seguinte exemplo:

<pre>
     x = 10                -- vari&aacute;vel global
     do                    -- bloco novo
       local x = x         -- novo 'x', com valor 10
       print(x)            --&gt; 10
       x = x+1
       do                  -- outro bloco
         local x = x+1     -- outro 'x'
         print(x)          --&gt; 12
       end
       print(x)            --&gt; 11
     end
     print(x)              --&gt; 10  (o x global)
</pre>

<p>
Note que, em uma declara&ccedil;&atilde;o como <code>local x = x</code>,
o novo <code>x</code> sendo declarado n&atilde;o est&aacute; no escopo ainda
e portanto o segundo <code>x</code> se refere a uma vari&aacute;vel
externa.


<p>
Por causa das regras de escopo l&eacute;xico,
vari&aacute;veis locais podem ser livremente acessadas por fun&ccedil;&otilde;es
definidas dentro do seu escopo.
Uma vari&aacute;vel local usada por uma fun&ccedil;&atilde;o mais interna &eacute; chamada
de <em>upvalue</em> ou <em>vari&aacute;vel local externa</em>,
dentro da fun&ccedil;&atilde;o mais interna.


<p>
Note que cada execu&ccedil;&atilde;o de um comando <b>local</b>
define novas vari&aacute;veis locais.
Considere o exemplo a seguir:

<pre>
     a = {}
     local x = 20
     for i=1,10 do
       local y = 0
       a[i] = function () y=y+1; return x+y end
     end
</pre><p>
O la&ccedil;o cria dez fechos
(isto &eacute;, dez inst&acirc;ncias da fun&ccedil;&atilde;o an&ocirc;nima).
Cada um destes fechos usa uma vari&aacute;vel <code>y</code> diferente,
enquanto todos eles compartilham a mesma vari&aacute;vel <code>x</code>.





<h2>2.7 - <a name="2.7">Tratamento de Erros</a></h2>

<p>
Dado que Lua &eacute; uma linguagem embarcada de extens&atilde;o,
todas as a&ccedil;&otilde;es de Lua come&ccedil;am a partir de c&oacute;digo&nbsp;C no programa hospedeiro
que chama uma fun&ccedil;&atilde;o da biblioteca de Lua (ver <a href="#lua_pcall"><code>lua_pcall</code></a>).
Sempre que um erro ocorre durante a compila&ccedil;&atilde;o ou execu&ccedil;&atilde;o,
o controle retorna para C,
que pode tomar as medidas apropriadas
(tais como imprimir uma mensagem de erro).


<p>
O c&oacute;digo Lua pode explicitamente gerar um erro atrav&eacute;s de uma chamada &agrave;
fun&ccedil;&atilde;o <a href="#pdf-error"><code>error</code></a>.
Se voc&ecirc; precisa capturar erros em Lua,
voc&ecirc; pode usar a fun&ccedil;&atilde;o <a href="#pdf-pcall"><code>pcall</code></a>.





<h2>2.8 - <a name="2.8">Metatabelas</a></h2>

<p>
Todo valor em Lua pode ter uma <em>metatabela</em>.
Esta <em>metatabela</em> &eacute; uma tabela Lua comum
que define o comportamento do valor original
com rela&ccedil;&atilde;o a certas opera&ccedil;&otilde;es especiais.
&Eacute; poss&iacute;vel mudar v&aacute;rios aspectos do comportamento
de opera&ccedil;&otilde;es sobre um valor especificando campos espec&iacute;ficos na metatabela do valor.
Por exemplo, quando um valor n&atilde;o num&eacute;rico &eacute; o operando de uma adi&ccedil;&atilde;o,
Lua verifica se existe uma fun&ccedil;&atilde;o associada com o campo <code>"__add"</code> na metatabela do valor.
Se a fun&ccedil;&atilde;o existe,
Lua chama esta fun&ccedil;&atilde;o para realizar a adi&ccedil;&atilde;o.


<p>
Chamamos as chaves em uma metatabela de <em>eventos</em>
e os valores de <em>metam&eacute;todos</em>.
No exemplo anterior, o evento &eacute; <code>"add"</code>
e o metam&eacute;todo &eacute; a fun&ccedil;&atilde;o que realiza a adi&ccedil;&atilde;o.


<p>
&Eacute; poss&iacute;vel obter a metatabela de qualquer valor
usando a fun&ccedil;&atilde;o <a href="#pdf-getmetatable"><code>getmetatable</code></a>.


<p>
Voc&ecirc; pode mudar a metatabela de tabelas
atrav&eacute;s da fun&ccedil;&atilde;o <a href="#pdf-setmetatable"><code>setmetatable</code></a>.
Voc&ecirc; n&atilde;o pode mudar a metatabela de outros tipos de Lua
(a menos que voc&ecirc; use a biblioteca de depura&ccedil;&atilde;o);
voc&ecirc; deve obrigatoriamente usar a API&nbsp;C para fazer isto.


<p>
Tabelas e objetos do tipo userdata completos possuem metatabelas individuais
(embora m&uacute;ltiplas tabelas e objetos userdata possam compartilhar suas metatabelas).
Valores de todos os outros tipos compartilham um &uacute;nica metatabela por tipo;
ou seja, h&aacute; somente uma metatabela para todos os n&uacute;meros,
uma para todas as cadeias de caracteres, etc.


<p>
Uma metatabela controla como um objeto se comporta em opera&ccedil;&otilde;es aritm&eacute;ticas,
compara&ccedil;&otilde;es com rela&ccedil;&atilde;o &agrave; ordem, concatena&ccedil;&atilde;o, opera&ccedil;&atilde;o de comprimento e indexa&ccedil;&atilde;o.
Uma metatabela tamb&eacute;m pode definir uma fun&ccedil;&atilde;o a ser chamada quando um objeto userdata
&eacute; coletado pelo coletor de lixo.
Para cada uma destas opera&ccedil;&otilde;es Lua associa uma chave espec&iacute;fica
chamada um <em>evento</em>.
Quando Lua realiza uma destas opera&ccedil;&otilde;es sobre um valor,
Lua verifica se este valor possui uma metatabela com o evento correspondente.
Se este &eacute; o caso, o valor associado &agrave;quela chave (o metam&eacute;todo)
controla como Lua ir&aacute; realizar a opera&ccedil;&atilde;o.


<p>
Metatabelas controlam as opera&ccedil;&otilde;es listadas a seguir.
Cada opera&ccedil;&atilde;o &eacute; identificada por seu nome correspondente.
A chave para cada opera&ccedil;&atilde;o &eacute; uma cadeia de caracteres come&ccedil;ando com o nome
da opera&ccedil;&atilde;o sendo precedido por dois sublinhados, '<code>__</code>';
por exemplo, a chave para a opera&ccedil;&atilde;o "add" &eacute; a
cadeia <code>"__add"</code>.
A sem&acirc;ntica destas opera&ccedil;&otilde;es &eacute; melhor explicada por meio de uma fun&ccedil;&atilde;o Lua
que descreve como o interpretador executa a opera&ccedil;&atilde;o.


<p>
O c&oacute;digo mostrado aqui &eacute; meramente ilustrativo;
o comportamento real est&aacute; codificado no interpretador
e &eacute; muito mais eficiente do que esta simula&ccedil;&atilde;o.
Todas as fun&ccedil;&otilde;es usadas nestes descri&ccedil;&otilde;es
(<a href="#pdf-rawget"><code>rawget</code></a>, <a href="#pdf-tonumber"><code>tonumber</code></a>, etc.)
s&atilde;o descritas em <a href="#5.1">&sect;5.1</a>.
Em particular, para recuperar o metam&eacute;todo de um dado objeto,
usamos a express&atilde;o

<pre>
     metatable(obj)[event]
</pre><p>
Isto deve ser lido como

<pre>
     rawget(getmetatable(obj) or {}, event)
</pre><p>

Isto &eacute;, o acesso a um metam&eacute;todo n&atilde;o invoca outros metam&eacute;todos
e o acesso a objetos que n&atilde;o possuem metatabelas n&atilde;o falha
(ele simplesmente resulta em <b>nil</b>).



<ul>

<li><b>"add":</b>
a opera&ccedil;&atilde;o <code>+</code>.



<p>
A fun&ccedil;&atilde;o <code>getbinhandler</code> abaixo define como Lua escolhe um tratador
para uma opera&ccedil;&atilde;o bin&aacute;ria.
Primeiro, Lua tenta o primeiro operando.
Se o seu tipo n&atilde;o definie um tratador para a opera&ccedil;&atilde;o,
ent&atilde;o Lua tenta o segundo operando.

<pre>
     function getbinhandler (op1, op2, event)
       return metatable(op1)[event] or metatable(op2)[event]
     end
</pre><p>
Usando esta fun&ccedil;&atilde;o,
o comportamento da express&atilde;o <code>op1 + op2</code> &eacute;

<pre>
     function add_event (op1, op2)
       local o1, o2 = tonumber(op1), tonumber(op2)
       if o1 and o2 then  -- os dois operandos s&atilde;o num&eacute;ricos?
         return o1 + o2   -- '+' aqui &eacute; a 'add' primitiva
       else  -- pelo menos um dos operandos nao &eacute; num&eacute;rico
         local h = getbinhandler(op1, op2, "__add")
         if h then
           -- chama o tratador com ambos os operandos
           return (h(op1, op2))
         else  -- nenhum tratador dispon&iacute;vel: comportamento padr&atilde;o
           error(&middot;&middot;&middot;)
         end
       end
     end
</pre><p>
</li>

<li><b>"sub":</b>
a opera&ccedil;&atilde;o <code>-</code>.

Comportamento similar ao da opera&ccedil;&atilde;o "add".
</li>

<li><b>"mul":</b>
a opera&ccedil;&atilde;o <code>*</code>.

Comportamento similar ao da opera&ccedil;&atilde;o "add".
</li>

<li><b>"div":</b>
a opera&ccedil;&atilde;o <code>/</code>.

Comportamento similar ao da opera&ccedil;&atilde;o "add".
</li>

<li><b>"mod":</b>
a opera&ccedil;&atilde;o <code>%</code>.

Comportamento similar ao da opera&ccedil;&atilde;o "add",
tendo a opera&ccedil;&atilde;o
<code>o1 - floor(o1/o2)*o2</code> como opera&ccedil;&atilde;o primitiva.
</li>

<li><b>"pow":</b>
a opera&ccedil;&atilde;o <code>^</code> (exponencia&ccedil;&atilde;o).

Comportamento similar ao da opera&ccedil;&atilde;o "add",
com a fun&ccedil;&atilde;o <code>pow</code> (da biblioteca matem&aacute;tica&nbsp;de&nbsp;C)
como opera&ccedil;&atilde;o primitiva.
</li>

<li><b>"unm":</b>
a opera&ccedil;&atilde;o <code>-</code> un&aacute;ria.


<pre>
     function unm_event (op)
       local o = tonumber(op)
       if o then  -- operando &eacute; num&eacute;rico?
         return -o  -- '-' aqui &eacute; a 'unm' primitiva
       else  -- o operando n&atilde;o &eacute; num&eacute;rico.
         -- Tenta obter um tratador do operando
         local h = metatable(op).__unm
         if h then
           -- chama o tratador com o operando
           return (h(op))
         else  -- nenhum tratador dispon&iacute;vel: comportamento padr&atilde;o
           error(&middot;&middot;&middot;)
         end
       end
     end
</pre><p>
</li>

<li><b>"concat":</b>
a opera&ccedil;&atilde;o <code>..</code> (concatena&ccedil;&atilde;o).


<pre>
     function concat_event (op1, op2)
       if (type(op1) == "string" or type(op1) == "number") and
          (type(op2) == "string" or type(op2) == "number") then
         return op1 .. op2  -- concatena&ccedil;&atilde;o de cadeias primitiva
       else
         local h = getbinhandler(op1, op2, "__concat")
         if h then
           return (h(op1, op2))
         else
           error(&middot;&middot;&middot;)
         end
       end
     end
</pre><p>
</li>

<li><b>"len":</b>
a opera&ccedil;&atilde;o <code>#</code>.


<pre>
     function len_event (op)
       if type(op) == "string" then
         return strlen(op)         -- comprimento de string primitiva
       elseif type(op) == "table" then
         return #op                -- comprimento de tabela primitiva
       else
         local h = metatable(op).__len
         if h then
           -- chama o tratador com o operando
           return (h(op))
         else  -- nenhum tratador dispon&iacute;vel: comportamento padr&atilde;o
           error(&middot;&middot;&middot;)
         end
       end
     end
</pre><p>
Veja <a href="#2.5.5">&sect;2.5.5</a> para uma descri&ccedil;&atilde;o do comprimento de um tabela.
</li>

<li><b>"eq":</b>
a opera&ccedil;&atilde;o <code>==</code>.

A fun&ccedil;&atilde;o <code>getcomphandler</code> define como Lua escolhe um metam&eacute;todo
para operadores de compara&ccedil;&atilde;o.
Um metam&eacute;todo somente &eacute; selecionado quando os dois objetos
que est&atilde;o sendo comparados possuem o mesmo tipo
e o mesmo metam&eacute;todo para a opera&ccedil;&atilde;o selecionada.

<pre>
     function getcomphandler (op1, op2, event)
       if type(op1) ~= type(op2) then return nil end
       local mm1 = metatable(op1)[event]
       local mm2 = metatable(op2)[event]
       if mm1 == mm2 then return mm1 else return nil end
     end
</pre><p>
O evento "eq" &eacute; definido da seguinte forma:

<pre>
     function eq_event (op1, op2)
       if type(op1) ~= type(op2) then  -- tipos diferentes?
         return false   -- objetos diferentes
       end
       if op1 == op2 then   -- igual primitivo?
         return true   -- objetos s&atilde;o iguais
       end
       -- tenta metam&eacute;todo
       local h = getcomphandler(op1, op2, "__eq")
       if h then
         return (h(op1, op2))
       else
         return false
       end
     end
</pre><p>
<code>a ~= b</code> &eacute; equivalente a <code>not (a == b)</code>.
</li>

<li><b>"lt":</b>
a opera&ccedil;&atilde;o <code>&lt;</code>.


<pre>
     function lt_event (op1, op2)
       if type(op1) == "number" and type(op2) == "number" then
         return op1 &lt; op2   -- compara&ccedil;&atilde;o num&eacute;rica
       elseif type(op1) == "string" and type(op2) == "string" then
         return op1 &lt; op2   -- compara&ccedil;&atilde;o lexicogr&aacute;fica
       else
         local h = getcomphandler(op1, op2, "__lt")
         if h then
           return (h(op1, op2))
         else
           error(&middot;&middot;&middot;)
         end
       end
     end
</pre><p>
<code>a &gt; b</code> &eacute; equivalente a <code>b &lt; a</code>.
</li>

<li><b>"le":</b>
a opera&ccedil;&atilde;o <code>&lt;=</code>.


<pre>
     function le_event (op1, op2)
       if type(op1) == "number" and type(op2) == "number" then
         return op1 &lt;= op2   -- compara&ccedil;&atilde;o num&eacute;rica
       elseif type(op1) == "string" and type(op2) == "string" then
         return op1 &lt;= op2   -- compara&ccedil;&atilde;o lexicogr&aacute;fica
       else
         local h = getcomphandler(op1, op2, "__le")
         if h then
           return (h(op1, op2))
         else
           h = getcomphandler(op1, op2, "__lt")
           if h then
             return not h(op2, op1)
           else
             error(&middot;&middot;&middot;)
           end
         end
       end
     end
</pre><p>
<code>a &gt;= b</code> &eacute; equivalente a <code>b &lt;= a</code>.
Note que, na aus&ecirc;ncia de um metam&eacute;todo "le",
Lua tenta o "lt", assumindo que <code>a &lt;= b</code> &eacute;
equivalente a <code>not (b &lt; a)</code>.
</li>

<li><b>"index":</b>
A indexa&ccedil;&atilde;o de leitura <code>table[key]</code>.


<pre>
     function gettable_event (table, key)
       local h
       if type(table) == "table" then
         local v = rawget(table, key)
         if v ~= nil then return v end
         h = metatable(table).__index
         if h == nil then return nil end
       else
         h = metatable(table).__index
         if h == nil then
           error(&middot;&middot;&middot;)
         end
       end
       if type(h) == "function" then
         return (h(table, key))    -- chama o tratador
       else return h[key]          -- ou repete a opera&ccedil;&atilde;o sobre ele
       end
     end
</pre><p>
</li>

<li><b>"newindex":</b>
A indexa&ccedil;&atilde;o de atribui&ccedil;&atilde;o <code>table[key] = value</code>.


<pre>
     function settable_event (table, key, value)
       local h
       if type(table) == "table" then
         local v = rawget(table, key)
         if v ~= nil then rawset(table, key, value); return end
         h = metatable(table).__newindex
         if h == nil then rawset(table, key, value); return end
       else
         h = metatable(table).__newindex
         if h == nil then
           error(&middot;&middot;&middot;)
         end
       end
       if type(h) == "function" then
         h(table, key, value)       -- chama o tratador
       else h[key] = value          -- ou repete a opera&ccedil;&atilde;o sobre
       end
     end
</pre><p>
</li>

<li><b>"call":</b>
chamada quando Lua chama um valor.


<pre>
     function function_event (func, ...)
       if type(func) == "function" then
         return func(...)   -- call primitiva
       else
         local h = metatable(func).__call
         if h then
           return h(func, ...)
         else
           error(&middot;&middot;&middot;)
         end
       end
     end
</pre><p>
</li>

</ul>




<h2>2.9 - <a name="2.9">Ambientes</a></h2>

<p>
Al&eacute;m de metatabelas,
objetos do tipo thread, function e userdata
possuem outra tabela associada com eles,
chamada de seu <em>ambiente</em>.
Assim como metatabelas, ambientes s&atilde;o tabelas normais e
v&aacute;rios objetos podem compartilhar o mesmo ambiente.


<p>
Objetos do tipo thread s&atilde;o criados compartilhando o ambiente da
thread que os criou. Objetos do tipo userdata e fun&ccedil;&otilde;es&nbsp;C s&atilde;o
criados compartilhando o ambiente da fun&ccedil;&atilde;o&nbsp;C que os criou.
Fun&ccedil;&otilde;es Lua n&atilde;o aninhadas
(criadas por <a href="#pdf-loadfile"><code>loadfile</code></a>, <a href="#pdf-loadstring"><code>loadstring</code></a> ou <a href="#pdf-load"><code>load</code></a>)
s&atilde;o criadas compartilhando o ambiente da thread que as criou.
Fun&ccedil;&otilde;es Lua aninhadas s&atilde;o criadas compartilhando o ambiente da
fun&ccedil;&atilde;o Lua que as criou.


<p>
Ambientes associados com objetos do tipo userdata n&atilde;o possuem significado para Lua.
&Eacute; apenas uma conveni&ecirc;ncia para programadores associarem uma tabela a
um objeto userdata.


<p>
Ambientes associados com fluxos de execu&ccedil;&atilde;o (threads) s&atilde;o chamados de
<em>ambientes globais</em>.
Eles s&atilde;o usados como o ambiente padr&atilde;o pelos fluxos de execu&ccedil;&atilde;o e
fun&ccedil;&otilde;es n&atilde;o aninhadas criadas pelo fluxo de execu&ccedil;&atilde;o
e podem ser diretamente acessados pelo c&oacute;digo&nbsp;C (ver <a href="#3.3">&sect;3.3</a>).


<p>
O ambiente associado com uma fun&ccedil;&atilde;o&nbsp;C pode ser diretamente
acessado pelo c&oacute;digo&nbsp;C (ver <a href="#3.3">&sect;3.3</a>).
Ele &eacute; usado como o ambiente padr&atilde;o para outras fun&ccedil;&otilde;es&nbsp;C
e objetos userdata criados pela fun&ccedil;&atilde;o.


<p>
Ambientes associados com fun&ccedil;&otilde;es Lua s&atilde;o usados para resolver
todos os acessos a vari&aacute;veis globais dentro da fun&ccedil;&atilde;o (ver <a href="#2.3">&sect;2.3</a>).
Eles s&atilde;o usados como o ambiente padr&atilde;o para outras fun&ccedil;&otilde;es Lua
criadas pela fun&ccedil;&atilde;o.


<p>
&Eacute; poss&iacute;vel mudar o ambiente de uma fun&ccedil;&atilde;o Lua ou do
fluxo de execu&ccedil;&atilde;o que est&aacute; sendo executado atualmente chamando <a href="#pdf-setfenv"><code>setfenv</code></a>.
&Eacute; poss&iacute;vel obter o ambiente de uma fun&ccedil;&atilde;o Lua ou do fluxo de execu&ccedil;&atilde;o sendo
executado atualmente chamando <a href="#pdf-getfenv"><code>getfenv</code></a>.
Para tratar o ambiente de outros objetos
(userdata, fun&ccedil;&otilde;es&nbsp;C, outros fluxos de execu&ccedil;&atilde;o) voc&ecirc; deve obrigatoriamente
usar a API&nbsp;C.





<h2>2.10 - <a name="2.10">Coleta de Lixo</a></h2>

<p>
Lua realiza gerenciamento autom&aacute;tico da mem&oacute;ria.
Isto significa que
voc&ecirc; n&atilde;o precisa se preocupar com a aloca&ccedil;&atilde;o de mem&oacute;ria para novos objetos
nem com a libera&ccedil;&atilde;o de mem&oacute;ria quando os objetos n&atilde;o s&atilde;o mais necess&aacute;rios.
Lua gerencia a mem&oacute;ria automaticamente executando
um <em>coletor de lixo</em> de tempos em tempos
para coletar todos os <em>objetos mortos</em>
(ou seja, objetos que n&atilde;o s&atilde;o mais acess&iacute;veis a partir de Lua).
Toda mem&oacute;ria usada por Lua est&aacute; sujeita ao gerenciamento autom&aacute;tico de mem&oacute;ria:
tabelas, userdata, fun&ccedil;&otilde;es, fluxos de execu&ccedil;&atilde;o, cadeias de caracteres, etc.


<p>
Lua implementa um coletor de lixo marca-e-limpa (<em>mark-and-sweep</em>) incremental.
O coletor usa dois n&uacute;meros para controlar o seu ciclo de coleta de lixo:
a <em>pausa do coletor de lixo</em> e
o <em>multiplicador de passo do coletor de lixo</em>.
O valor de ambos &eacute; expresso de forma percentual
(ou seja, um valor de 100 representa um valor interno de 1).


<p>
A pausa do coletor de lixo
controla quanto tempo o coletor espera antes de iniciar um novo ciclo.
Valores maiores fazem o coletor ser menos agressivo.
Valores menores do que 100 significam que o coletor n&atilde;o ir&aacute; esperar para
iniciar um novo ciclo.
Um valor de 200 significa que o coletor ir&aacute; esperar at&eacute; que a mem&oacute;ria total em uso
dobre antes de iniciar um novo ciclo.


<p>
O multiplicador de passo
controla a velocidade relativa do coletor em rela&ccedil;&atilde;o &agrave;
aloca&ccedil;&atilde;o de mem&oacute;ria.
Valores maiores fazem o coletor ser mais agressivo mas tamb&eacute;m aumentam
o tamanho de cada passo incremental.
Valores menores do que 100 fazem com que o coletor seja muito lento e
pode ocorrer que o coletor nunca termine um ciclo.
O valor padr&atilde;o, 200, significa que o coletor &eacute; executado a uma velocidade que &eacute; "duas vezes"
a velocidade de aloca&ccedil;&atilde;o de mem&oacute;ria.


<p>
&Eacute; poss&iacute;vel mudar estes n&uacute;meros atrav&eacute;s de chamadas &agrave;s fun&ccedil;&otilde;es <a href="#lua_gc"><code>lua_gc</code></a> em C
ou <a href="#pdf-collectgarbage"><code>collectgarbage</code></a> em Lua.
Com estas fun&ccedil;&otilde;es voc&ecirc; tamb&eacute;m pode controlar
o coletor diretamente (e.g., par&aacute;-lo e reinici&aacute;-lo).



<h3>2.10.1 - <a name="2.10.1">Metam&eacute;todos de Coleta de Lixo</a></h3>

<p>
Usando a API&nbsp;C,
voc&ecirc; pode configurar os metam&eacute;todos do coletor de lixo para objetos userdata (ver <a href="#2.8">&sect;2.8</a>).
Estes metam&eacute;todos tamb&eacute;m s&atilde;o chamados de <em>finalizadores</em>.
Finalizadores permitem que voc&ecirc; coordene a coleta de lixo de Lua
com o gerenciamento de recursos externos
(tais como o fechamento de arquivos, conex&otilde;es de rede ou de bancos de dados
ou a libera&ccedil;&atilde;o de sua pr&oacute;pria mem&oacute;ria).


<p>
Objetos userdata com um campo <code>__gc</code> em suas metatabelas n&atilde;o s&atilde;o
recolhidos imediatamente pelo coletor de lixo.
Ao inv&eacute;s disso, Lua os coloca naquela lista.
Depois que a coleta &eacute; realizada,
Lua faz o equivalente da seguinte fun&ccedil;&atilde;o
para cada objeto userdata em uma lista:

<pre>
     function gc_event (userdata)
       local h = metatable(userdata).__gc
       if h then
         h(userdata)
       end
     end
</pre>

<p>
Ao final do ciclo de coleta de lixo,
os finalizadores para os objetos userdata s&atilde;o chamados na
ordem <em>reversa</em> ao de sua cria&ccedil;&atilde;o,
entre aqueles coletados naquele ciclo.
Isto &eacute;, o primeiro finalizador a ser chamado &eacute; aquele associado
com o objeto userdata que foi criado por &uacute;ltimo no programa.
O userdata s&oacute; &eacute; efetivamente liberado no pr&oacute;ximo ciclo de coleta de lixo.





<h3>2.10.2 - <a name="2.10.2">Tabelas Fracas</a></h3>

<p>
Uma <em>tabela fraca</em> &eacute; uma tabela cujos elementos s&atilde;o
<em>refer&ecirc;ncias fracas</em>.
Uma refer&ecirc;ncia fraca &eacute; ignorada pelo coletor de lixo.
Em outras palavras,
se as &uacute;nicas refer&ecirc;ncias para um objeto s&atilde;o refer&ecirc;ncias fracas,
ent&atilde;o o coletor de lixo ir&aacute; coletar este objeto.


<p>
Uma tabela fraca pode ter chaves fracas, valores fracos ou ambos.
Uma tabela com chaves fracas permite a coleta de suas chaves
mas impede a coleta de seus valores.
Uma tabela com chaves fracas e valores fracos permite a coleta
tanto das chaves como dos valores.
Em qualquer caso, se a chave &eacute; coletada ou o valor &eacute; coletado,
o par inteiro &eacute; removido da tabela.
A fragilidade de uma tabela &eacute; controlada pelo
campo <code>__mode</code> de sua metatabela.
Se o campo <code>__mode</code> &eacute; uma cadeia de caracteres contendo o caractere&nbsp;'<code>k</code>',
as chaves da tabela s&atilde;o fracas.
Se <code>__mode</code> cont&eacute;m '<code>v</code>',
os valores na tabela s&atilde;o fracos.


<p>
Depois de usar uma tabela como uma metatabela,
n&atilde;o se deve mudar o valor de seu campo <code>__mode</code>.
Caso contr&aacute;rio, o comportamento fraco das tabelas controladas por esta
metatabela &eacute; indefinido.







<h2>2.11 - <a name="2.11">Co-rotinas</a></h2>

<p>
Lua oferece suporte a co-rotinas,
tamb&eacute;m conhecidas como <em>fluxos de execu&ccedil;&atilde;o (threads) colaborativos</em>.
Uma co-rotina em Lua representa um fluxo de execu&ccedil;&atilde;o independente.
Ao contr&aacute;rio de processos leves em sistemas que d&atilde;o suporte a m&uacute;ltiplos fluxos de execu&ccedil;&atilde;o,
uma co-rotina somente suspende sua execu&ccedil;&atilde;o atrav&eacute;s de uma chamada expl&iacute;cita
a uma fun&ccedil;&atilde;o de cess&atilde;o.


<p>
&Eacute; poss&iacute;vel criar uma co-rotina com uma chamada &agrave; <a href="#pdf-coroutine.create"><code>coroutine.create</code></a>.
O seu &uacute;nico argumento &eacute; uma fun&ccedil;&atilde;o
que &eacute; a fun&ccedil;&atilde;o principal da co-rotina.
A fun&ccedil;&atilde;o <code>create</code> somente cria uma nova co-rotina e
retorna uma refer&ecirc;ncia para ela (um objeto do tipo <em>thread</em>);
ela n&atilde;o inicia a execu&ccedil;&atilde;o da co-rotina.


<p>
Quando a fun&ccedil;&atilde;o <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a> &eacute; chamada pela primeira vez,
recebendo como seu primeiro argumento
um objeto do tipo thread retornado por <a href="#pdf-coroutine.create"><code>coroutine.create</code></a>,
a co-rotina inicia a sua execu&ccedil;&atilde;o,
na primeira linha de sua fun&ccedil;&atilde;o principal.
Depois que a co-rotina come&ccedil;a a ser executada,
ela continua executando at&eacute; terminar ou <em>ceder</em>.


<p>
Uma fun&ccedil;&atilde;o pode terminar sua execu&ccedil;&atilde;o de duas maneiras:
normalmente, quando sua fun&ccedil;&atilde;o principal retorna
(explicitamente ou implicitamente, depois da &uacute;ltima instru&ccedil;&atilde;o);
e de maneira anormal, se ocorre um erro n&atilde;o protegido.
No primeiro caso, <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a> retorna <b>true</b>
mais quaisquer valores retornados pela fun&ccedil;&atilde;o principal da co-rotina.
No caso de acontecerem erros, <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a> retorna <b>false</b>
mais uma mensagem de erro.


<p>
Uma co-rotina cede a execu&ccedil;&atilde;o atrav&eacute;s de uma chamada &agrave; fun&ccedil;&atilde;o <a href="#pdf-coroutine.yield"><code>coroutine.yield</code></a>.
Quando uma co-rotina cede,
a <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a> correspondente retorna imediatamente,
mesmo se a cess&atilde;o aconteceu dentro de uma chamada de fun&ccedil;&atilde;o aninhada
(isto &eacute;, n&atilde;o ocorreu dentro da fun&ccedil;&atilde;o principal,
mas em uma fun&ccedil;&atilde;o chamada direta ou indiretamente pela fun&ccedil;&atilde;o principal).
No caso de uma cess&atilde;o, <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a> tamb&eacute;m retorna <b>true</b>,
mais quaisquer valores passados para <a href="#pdf-coroutine.yield"><code>coroutine.yield</code></a>.
Na pr&oacute;xima vez que voc&ecirc; recome&ccedil;a a execu&ccedil;&atilde;o da mesma co-rotina,
ela continua sua execu&ccedil;&atilde;o do ponto onde ela cedeu,
com a chamada para <a href="#pdf-coroutine.yield"><code>coroutine.yield</code></a> retornando quaisquer
argumentos extras passados para <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>.


<p>
Como <a href="#pdf-coroutine.create"><code>coroutine.create</code></a>,
a fun&ccedil;&atilde;o <a href="#pdf-coroutine.wrap"><code>coroutine.wrap</code></a> tamb&eacute;m cria uma co-rotina,
mas ao inv&eacute;s de retornar a pr&oacute;pria co-rotina,
ela retorna uma fun&ccedil;&atilde;o que, quando chamada, retoma a execu&ccedil;&atilde;o da co-rotina.
Quaisquer argumentos passados para esta fun&ccedil;&atilde;o
v&atilde;o como argumentos extras para <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>.
<a href="#pdf-coroutine.wrap"><code>coroutine.wrap</code></a> retorna todos os valores retornados por <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>,
exceto o primeiro (o c&oacute;digo booleano de erro).
Diferentemente de <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>,
<a href="#pdf-coroutine.wrap"><code>coroutine.wrap</code></a> n&atilde;o captura erros;
qualquer erro &eacute; propagado para o chamador.


<p>
Como um exemplo,
considere o seguinde c&oacute;digo:

<pre>
     function foo (a)
       print("foo", a)
       return coroutine.yield(2*a)
     end
     
     co = coroutine.create(function (a,b)
           print("co-body", a, b)
           local r = foo(a+1)
           print("co-body", r)
           local r, s = coroutine.yield(a+b, a-b)
           print("co-body", r, s)
           return b, "end"
     end)
            
     print("main", coroutine.resume(co, 1, 10))
     print("main", coroutine.resume(co, "r"))
     print("main", coroutine.resume(co, "x", "y"))
     print("main", coroutine.resume(co, "x", "y"))
</pre><p>
Quando voc&ecirc; execut&aacute;-lo, ele produzir&aacute; a seguinte sa&iacute;da:

<pre>
     co-body 1       10
     foo     2
     
     main    true    4
     co-body r
     main    true    11      -9
     co-body x       y
     main    true    10      end
     main    false   cannot resume dead coroutine
</pre>
<p>



<h1>3 - <a name="3">A Interface de Programa&ccedil;&atilde;o da Aplica&ccedil;&atilde;o (API)</a></h1>

<p>

Esta se&ccedil;&atilde;o descreve a API&nbsp;C para Lua, ou seja,
o conjunto de fun&ccedil;&otilde;es&nbsp;C dispon&iacute;veis para o programa hospedeiro se comunicar
com Lua.
Todas as fun&ccedil;&otilde;es da API, bem como os tipos e constantes relacionados,
est&atilde;o declarados no arquivo de cabe&ccedil;alho <a name="pdf-lua.h"><code>lua.h</code></a>.


<p>
Mesmo quando usamos o termo "fun&ccedil;&atilde;o",
qualquer opera&ccedil;&atilde;o na API pode, de forma alternativa, ser provida como uma macro.
Tais macros usam cada um dos seus argumentos exatamente uma vez
(com exce&ccedil;&atilde;o do primeiro argumento, que &eacute; sempre um estado Lua)
e portanto n&atilde;o geram qualquer efeito colateral oculto.


<p>
Como na maioria das bibliotecas&nbsp;C,
as fun&ccedil;&otilde;es da API Lua n&atilde;o verificam a validade ou a consist&ecirc;ncia dos seus argumentos.
Contudo, &eacute; poss&iacute;vel mudar este comportamento compilando Lua
com uma defini&ccedil;&atilde;o apropriada para a macro <a name="pdf-luai_apicheck"><code>luai_apicheck</code></a>,
no arquivo <code>luaconf.h</code>.



<h2>3.1 - <a name="3.1">A Pilha</a></h2>

<p>
Lua usa uma <em>pilha virtual</em> para passar e receber valores de C.
Cada elemento nesta pilha representa um valor Lua
(<b>nil</b>, um n&uacute;mero, uma cadeia de caracteres, etc.).


<p>
Sempre que Lua chama C, a fun&ccedil;&atilde;o chamada recebe uma nova pilha,
que &eacute; independente de pilhas anteriores e de pilhas de
fun&ccedil;&otilde;es&nbsp;C que ainda estejam ativas.
Esta pilha cont&eacute;m inicialmente quaisquer argumentos para a fun&ccedil;&atilde;o&nbsp;C
e &eacute; onde a fun&ccedil;&atilde;o&nbsp;C empilha os seus resultados
para serem retornados ao chamador (ver <a href="#lua_CFunction"><code>lua_CFunction</code></a>).


<p>
Por conveni&ecirc;ncia,
a maioria das opera&ccedil;&otilde;es de consulta na API n&atilde;o segue uma disciplina estrita de pilha.
Ao inv&eacute;s disso, elas podem se referir a qualquer elemento na pilha
usando um <em>&iacute;ndice</em>:
Um &iacute;ndice positivo representa uma posi&ccedil;&atilde;o <em>absoluta</em> na pilha
(come&ccedil;ando em&nbsp;1);
um &iacute;ndice negativo representa uma posi&ccedil;&atilde;o <em>relativa</em> ao topo da pilha.
De maneira mais espec&iacute;fica, se a pilha possui <em>n</em> elementos,
ent&atilde;o o &iacute;ndice&nbsp;1 representa o primeiro elemento
(isto &eacute;, o elemento que foi empilhado na pilha primeiro)
e o
&iacute;ndice&nbsp;<em>n</em> representa o &uacute;ltimo elemento;
o &iacute;ndice&nbsp;-1 tamb&eacute;m representa o &uacute;ltimo elemento
(isto &eacute;, o elemento no&nbsp;topo)
e o &iacute;ndice <em>-n</em> representa o primeiro elemento.
Dizemos que um &iacute;ndice &eacute; <em>v&aacute;lido</em>
se ele est&aacute; entre&nbsp;1 e o topo da pilha
(isto &eacute;, se <code>1 &le; abs(&iacute;ndice) &le; topo</code>).
 





<h2>3.2 - <a name="3.2">Tamanho da Pilha</a></h2>

<p>
Quando voc&ecirc; interage com a API de Lua,
voc&ecirc; &eacute; respons&aacute;vel por assegurar consist&ecirc;ncia.
Em particular,
<em>voc&ecirc; &eacute; respons&aacute;vel por controlar estouro da pilha</em>.
Voc&ecirc; pode usar a fun&ccedil;&atilde;o <a href="#lua_checkstack"><code>lua_checkstack</code></a>
para aumentar o tamanho da pilha.


<p>
Sempre que Lua chama C,
ela assegura que pelo menos <a name="pdf-LUA_MINSTACK"><code>LUA_MINSTACK</code></a> posi&ccedil;&otilde;es na pilha est&atilde;o dispon&iacute;veis.
<code>LUA_MINSTACK</code> &eacute; definida como 20,
ent&atilde;o geralmente voc&ecirc; n&atilde;o precisa se preocupar com o espa&ccedil;o da pilha
a menos que o seu c&oacute;digo possua la&ccedil;os empilhando elementos na pilha.


<p>
A maioria das fun&ccedil;&otilde;es de consulta aceita como &iacute;ndices qualquer valor dentro do
espa&ccedil;o da pilha dispon&iacute;vel, isto &eacute;, &iacute;ndices at&eacute; o tamanho m&aacute;ximo da pilha
que voc&ecirc; configurou atrav&eacute;s da fun&ccedil;&atilde;o <a href="#lua_checkstack"><code>lua_checkstack</code></a>.
Tais &iacute;ndices s&atilde;o chamados <em>&iacute;ndices aceit&aacute;veis</em>.
Mais formalmente, definimos um <em>&iacute;ndice aceit&aacute;vel</em>
como a seguir:

<pre>
     (&iacute;ndice &lt; 0 &amp;&amp; abs(&iacute;ndice) &lt;= topo) ||
     (&iacute;ndice &gt; 0 &amp;&amp; &iacute;ndice &lt;= espa&ccedil;odapilha)
</pre><p>
Note que 0 nunca &eacute; um &iacute;ndice aceit&aacute;vel.





<h2>3.3 - <a name="3.3">Pseudo-&Iacute;ndices</a></h2>

<p>
A menos que seja dito o contr&aacute;rio,
qualquer fun&ccedil;&atilde;o que aceita &iacute;ndices v&aacute;lidos pode tamb&eacute;m ser chamada com
<em>pseudo-&iacute;ndices</em>,
que representam alguns valores Lua que s&atilde;o acess&iacute;veis para o c&oacute;digo&nbsp;C
mas que n&atilde;o est&atilde;o na pilha.
Pseudo-&iacute;ndices s&atilde;o usados para acessar o ambiente do fluxo de execu&ccedil;&atilde;o,
o ambiente da fun&ccedil;&atilde;o,
o registro
e os upvalues da fun&ccedil;&atilde;o&nbsp;C (ver <a href="#3.4">&sect;3.4</a>).


<p>
O ambiente do fluxo de execu&ccedil;&atilde;o (onde as vari&aacute;veis globais existem) est&aacute;
sempre no pseudo-&iacute;ndice <a name="pdf-LUA_GLOBALSINDEX"><code>LUA_GLOBALSINDEX</code></a>.
O ambiente da fun&ccedil;&atilde;o&nbsp;C rodando est&aacute; sempre
no pseudo-&iacute;ndice <a name="pdf-LUA_ENVIRONINDEX"><code>LUA_ENVIRONINDEX</code></a>.


<p>
Para acessar e mudar o valor de vari&aacute;veis globais,
voc&ecirc; pode usar opera&ccedil;&otilde;es de tabelas usuais sobre uma tabela de ambiente.
Por exemplo, para acessar o valor de uma vari&aacute;vel global, fa&ccedil;a

<pre>
     lua_getfield(L, LUA_GLOBALSINDEX, varname);
</pre>




<h2>3.4 - <a name="3.4">Fechos C</a></h2>

<p>
Quando uma fun&ccedil;&atilde;o&nbsp;C &eacute; criada,
&eacute; poss&iacute;vel associar alguns valores a ela,
criando ent&atilde;o um <em>fecho&nbsp;C</em>;
estes valores s&atilde;o chamados de <em>upvalues</em> e s&atilde;o
acess&iacute;veis para a fun&ccedil;&atilde;o sempre que ela &eacute; chamada
(ver <a href="#lua_pushcclosure"><code>lua_pushcclosure</code></a>).


<p>
Sempre que uma fun&ccedil;&atilde;o&nbsp;C &eacute; chamada,
seus upvalues s&atilde;o posicionados em pseudo-&iacute;ndices espec&iacute;ficos.
Estes pseudo-&iacute;ndices s&atilde;o gerados pela macro
<a name="lua_upvalueindex"><code>lua_upvalueindex</code></a>.
O primeiro valor associado com uma fun&ccedil;&atilde;o est&aacute; na posi&ccedil;&atilde;o
<code>lua_upvalueindex(1)</code>, e assim por diante.
Qualquer acesso a <code>lua_upvalueindex(<em>n</em>)</code>,
onde <em>n</em> &eacute; maior do que o n&uacute;mero de upvalues da
fun&ccedil;&atilde;o atual (mas n&atilde;o &eacute; maior do que 256),
produz um &iacute;ndice aceit&aacute;vel (embora inv&aacute;lido).





<h2>3.5 - <a name="3.5">Registro</a></h2>

<p>
Lua prov&ecirc; um <em>registro</em>,
uma tabela pr&eacute;-definida que pode ser usada por qualquer c&oacute;digo&nbsp;C para
armazenar qualquer valor Lua que o c&oacute;digo C precise armazenar.
Esta tabela est&aacute; sempre localizada no pseudo-&iacute;ndice
<a name="pdf-LUA_REGISTRYINDEX"><code>LUA_REGISTRYINDEX</code></a>.
Qualquer biblioteca&nbsp;de&nbsp;C pode armazenar dados nesta tabela,
mas ela deve tomar cuidado para escolher chaves diferentes daquelas usadas
por outras bibliotecas, para evitar colis&otilde;es.
Tipicamente, voc&ecirc; deve usar como chave uma cadeia de caracteres contendo o nome da sua biblioteca
ou um objeto do tipo userdata leve com o endere&ccedil;o de um objeto&nbsp;C em seu c&oacute;digo.


<p>
As chaves inteiras no registro s&atilde;o usadas pelo mecanismo de refer&ecirc;ncia,
implementado pela biblioteca auxiliar,
e portanto n&atilde;o devem ser usadas para outros prop&oacute;sitos.





<h2>3.6 - <a name="3.6">Tratamento de Erros em C</a></h2>

<p>
Internamente, Lua usa o mecanismo de <code>longjmp</code> de C para tratar erros.
(Voc&ecirc; pode tamb&eacute;m utilizar exce&ccedil;&otilde;es se voc&ecirc; usar C++;
veja o arquivo <code>luaconf.h</code>.)
Quando Lua se depara com qualquer erro
(tais como erros de aloca&ccedil;&atilde;o de mem&oacute;ria, erros de tipo, erros de sintaxe
e erros de tempo de execu&ccedil;&atilde;o)
ela <em>dispara</em> um erro;
isto &eacute;, ela faz um desvio longo.
Um <em>ambiente protegido</em> usa <code>setjmp</code>
para estabelecer um ponto de recupera&ccedil;&atilde;o;
qualquer erro desvia o fluxo de execu&ccedil;&atilde;o para o ponto de recupera&ccedil;&atilde;o ativado mais recentemente.


<p>
A maioria das fun&ccedil;&otilde;es na API pode disparar um erro,
por exemplo devido a um erro de aloca&ccedil;&atilde;o de mem&oacute;ria.
A documenta&ccedil;&atilde;o para cada fun&ccedil;&atilde;o indica se
ela pode disparar erros.


<p>
Dentro de uma fun&ccedil;&atilde;o&nbsp;C voc&ecirc; pode disparar um erro chamando <a href="#lua_error"><code>lua_error</code></a>.





<h2>3.7 - <a name="3.7">Fun&ccedil;&otilde;es e Tipos</a></h2>

<p>
Listamos aqui todas as fun&ccedil;&otilde;es e tipos da API&nbsp;C em
ordem alfab&eacute;tica.
Cada fun&ccedil;&atilde;o tem um indicador como este:
<span class="apii">[-o, +p, <em>x</em>]</span>


<p>
O primeiro campo, <code>o</code>,
representa quantos elementos a fun&ccedil;&atilde;o desempilha da pilha.
O segundo campo, <code>p</code>,
indica quantos elementos a fun&ccedil;&atilde;o empilha na pilha.
(Qualquer fun&ccedil;&atilde;o sempre empilha seus resultados depois de desempilhar seus argumentos.)
Um campo na forma <code>x|y</code> significa que a fun&ccedil;&atilde;o pode empilhar (ou desempilhar)
<code>x</code> ou <code>y</code> elementos,
dependendo da situa&ccedil;&atilde;o;
uma marca de interroga&ccedil;&atilde;o '<code>?</code>' significa
que n&atilde;o podemos saber quantos elementos a fun&ccedil;&atilde;o desempilha/empilha
olhando somente os seus argumentos
(e.g., o n&uacute;mero de elementos pode depender do que est&aacute; na pilha).
O terceiro campo, <code>x</code>,
diz se a fun&ccedil;ao pode disparar erros:
'<code>-</code>' significa que a fun&ccedil;&atilde;o nunca dispara qualquer erro;
'<code>m</code>' significa que a fun&ccedil;&atilde;o pode disparar um erro
somente devido &agrave; falta de mem&oacute;ria;
'<code>e</code>' significa que a fun&ccedil;&atilde;o pode disparar outros tipos de erro;
'<code>v</code>' significa que a fun&ccedil;&atilde;o pode disparar um erro de maneira proposital.



<hr><h3><a name="lua_Alloc"><code>lua_Alloc</code></a></h3>
<pre>typedef void * (*lua_Alloc) (void *ud,
                             void *ptr,
                             size_t osize,
                             size_t nsize);</pre>

<p>
O tipo da fun&ccedil;&atilde;o de aloca&ccedil;&atilde;o de mem&oacute;ria usada pelos estados Lua.
A fun&ccedil;&atilde;o de aloca&ccedil;&atilde;o deve prover uma
funcionalidade similar &agrave; de <code>realloc</code>,
mas n&atilde;o exatamente a mesma.
Seus argumentos s&atilde;o
<code>ud</code>, um ponteiro opaco passado para <a href="#lua_newstate"><code>lua_newstate</code></a>;
<code>ptr</code>, um ponteiro para o bloco sendo alocado/realocado/liberado;
<code>osize</code>, o tamanho original do bloco;
e <code>nsize</code>, o novo tamanho do bloco.
<code>ptr</code> &eacute; <code>NULL</code> se e somente se <code>osize</code> &eacute; zero.
Quando <code>nsize</code> &eacute; zero, a fun&ccedil;&atilde;o de aloca&ccedil;&atilde;o deve retornar <code>NULL</code>;
se <code>osize</code> &eacute; diferente de zero,
o bloco de mem&oacute;ria apontado por <code>ptr</code> deve ser liberado.
Quando <code>nsize</code> n&atilde;o &eacute; zero, a fun&ccedil;&atilde;o de aloca&ccedil;&atilde;o retorna <code>NULL</code>
se e somente se ela n&atilde;o pode alocar o tamanho do bloco requisitado.
Quando <code>nsize</code> n&atilde;o &eacute; zero e <code>osize</code> &eacute; zero,
a fun&ccedil;&atilde;o de aloca&ccedil;&atilde;o deve comportar-se como <code>malloc</code>.
Quando <code>nsize</code> e <code>osize</code> n&atilde;o s&atilde;o zero,
a fun&ccedil;&atilde;o de aloca&ccedil;&atilde;o comporta-se como <code>realloc</code>.
Lua assume que a fun&ccedil;&atilde;o de aloca&ccedil;&atilde;o nunca falha quando
<code>osize &gt;= nsize</code>.


<p>
Temos a seguir uma implementa&ccedil;&atilde;o simples para a fun&ccedil;&atilde;o de aloca&ccedil;&atilde;o.
Ela &eacute; usada na biblioteca auxiliar por <a href="#luaL_newstate"><code>luaL_newstate</code></a>.

<pre>
     static void *l_alloc (void *ud, void *ptr, size_t osize,
                                                size_t nsize) {
       (void)ud;  (void)osize;  /* n&atilde;o utilizados */
       if (nsize == 0) {
         free(ptr);
         return NULL;
       }
       else
         return realloc(ptr, nsize);
     }
</pre><p>
Este c&oacute;digo assume
que <code>free(NULL)</code> n&atilde;o possui nenhum efeito e que
<code>realloc(NULL, size)</code> &eacute; equivalente a <code>malloc(size)</code>.
ANSI&nbsp;C garante esses dois comportamentos.





<hr><h3><a name="lua_atpanic"><code>lua_atpanic</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>lua_CFunction lua_atpanic (lua_State *L, lua_CFunction panicf);</pre>

<p>
Estabelece uma nova fun&ccedil;&atilde;o de p&acirc;nico e retorna a fun&ccedil;&atilde;o de p&acirc;nico antiga.


<p>
Se um erro ocorre fora de qualquer ambiente protegido,
Lua chama uma <em>fun&ccedil;&atilde;o de p&acirc;nico</em>
e ent&atilde;o chama <code>exit(EXIT_FAILURE)</code>,
terminando ent&atilde;o a aplica&ccedil;&atilde;o hospedeira.
A sua fun&ccedil;&atilde;o de p&acirc;nico pode evitar esta sa&iacute;da caso
ela nunca retorne (e.g., fazendo uma desvio longo).


<p>
A fun&ccedil;&atilde;o de p&acirc;nico pode acessar a mensagem de erro no topo da pilha.





<hr><h3><a name="lua_call"><code>lua_call</code></a></h3><p>
<span class="apii">[-(nargs + 1), +nresults, <em>e</em>]</span>
<pre>void lua_call (lua_State *L, int nargs, int nresults);</pre>

<p>
Chama uma fun&ccedil;&atilde;o.


<p>
Para chamar uma fun&ccedil;&atilde;o voc&ecirc; deve usar o seguinte protocolo:
primeiro, a fun&ccedil;&atilde;o a ser chamada &eacute; empilhada na pilha;
em seguida, os argumentos da fun&ccedil;&atilde;o s&atilde;o empilhados
em ordem direta;
isto &eacute;, o primeiro argumento &eacute; empilhado primeiro.
Por &uacute;ltimo voc&ecirc; chama <a href="#lua_call"><code>lua_call</code></a>;
<code>nargs</code> &eacute; o n&uacute;mero de argumentos que voc&ecirc; empilhou na pilha.
Todos os argumentos e o valor da fun&ccedil;&atilde;o s&atilde;o desempilhados da pilha
quando a fun&ccedil;&atilde;o &eacute; chamada.
Os resultados da fun&ccedil;&atilde;o s&atilde;o empilhados na pilha quando a fun&ccedil;&atilde;o retorna.
O n&uacute;mero de resultados &eacute; ajustado para <code>nresults</code>,
a menos que <code>nresults</code> seja <a name="pdf-LUA_MULTRET"><code>LUA_MULTRET</code></a>.
Neste caso, <em>todos</em> os resultados da fun&ccedil;&atilde;o s&atilde;o empilhados.
Lua cuida para que os valores retornados caibam dentro do espa&ccedil;o da pilha.
Os resultados da fun&ccedil;&atilde;o s&atilde;o empilhados na pilha em ordem direta
(o primeiro resultado &eacute; empilhado primeiro),
de modo que depois da chamada o &uacute;ltimo resultado est&aacute; no topo da pilha.


<p>
Qualquer erro dentro da fun&ccedil;&atilde;o chamada &eacute; propagado para cima
(com um <code>longjmp</code>).


<p>
O seguinte exemplo mostra como o programa hospedeiro pode fazer o
equivalente a este c&oacute;digo Lua:

<pre>
     a = f("how", t.x, 14)
</pre><p>
Aqui est&aacute; o mesmo c&oacute;digo em&nbsp;C:

<pre>
     lua_getfield(L, LUA_GLOBALSINDEX, "f");  /* fun&ccedil;&atilde;o a ser chamada */
     lua_pushstring(L, "how");                  /* primeiro argumento */
     lua_getfield(L, LUA_GLOBALSINDEX, "t"); /* tabela a ser indexada */
     lua_getfield(L, -1, "x"); /* empilha o resultado de t.x (2&ordm; arg) */
     lua_remove(L, -2);                        /* remove 't' da pilha */
     lua_pushinteger(L, 14);                          /* 3&ordm; argumento */
     lua_call(L, 3, 1);   /* chama 'f' com 3 argumentos e 1 resultado */
     lua_setfield(L, LUA_GLOBALSINDEX, "a"); /* estabelece 'a' global */
</pre><p>
Note que o c&oacute;digo acima &eacute; "balanceado":
ao seu final, a pilha est&aacute; de volta &agrave; sua configura&ccedil;&atilde;o original.
Isto &eacute; considerado uma boa pr&aacute;tica de programa&ccedil;&atilde;o.





<hr><h3><a name="lua_CFunction"><code>lua_CFunction</code></a></h3>
<pre>typedef int (*lua_CFunction) (lua_State *L);</pre>

<p>
O tipo para fun&ccedil;&otilde;es&nbsp;C.


<p>
A fim de se comunicar apropriadamente com Lua,
uma fun&ccedil;&atilde;o&nbsp;C deve usar o seguinte protocolo,
o qual define o modo como par&acirc;metros e resultados s&atilde;o passados:
uma fun&ccedil;&atilde;o&nbsp;C recebe seus argumentos de Lua na sua pilha
em ordem direta (o primeiro argumento &eacute; empilhado primeiro).
Portanto, quando a fun&ccedil;&atilde;o inicia,
<code>lua_gettop(L)</code> retorna o n&uacute;mero de argumentos recebidos pela fun&ccedil;&atilde;o.
O primeiro argumento (se houver) est&aacute; no &iacute;ndice 1
e seu &uacute;ltimo argumento est&aacute; no &iacute;ndice <code>lua_gettop(L)</code>.
Para retornar valores para Lua, uma fun&ccedil;&atilde;o&nbsp;C apenas os empilha na pilha,
em ordem direta (o primeiro resultado &eacute; empilhado primeiro)
e retorna o n&uacute;mero de resultados.
Qualquer outro valor na pilha abaixo dos resultados ser&aacute; devidamente
descartado por Lua.
Como uma fun&ccedil;&atilde;o Lua, uma fun&ccedil;&atilde;o&nbsp;C chamada por Lua tamb&eacute;m pode retornar
muitos resultados.


<p>
Como um exemplo, a seguinte fun&ccedil;&atilde;o recebe um n&uacute;mero vari&aacute;vel
de argumentos num&eacute;ricos e retorna a m&eacute;dia e a soma deles:

<pre>
     static int foo (lua_State *L) {
       int n = lua_gettop(L);   /* n&uacute;mero de argumentos */
       lua_Number sum = 0;
       int i;
       for (i = 1; i &lt;= n; i++) {
         if (!lua_isnumber(L, i)) {
           lua_pushstring(L, "incorrect argument");
           lua_error(L);
         }
         sum += lua_tonumber(L, i);
       }
       lua_pushnumber(L, sum/n);  /* primeiro resultado */
       lua_pushnumber(L, sum);     /* segundo resultado */
       return 2;                /* n&uacute;mero de resultados */
     }
</pre>




<hr><h3><a name="lua_checkstack"><code>lua_checkstack</code></a></h3><p>
<span class="apii">[-0, +0, <em>m</em>]</span>
<pre>int lua_checkstack (lua_State *L, int extra);</pre>

<p>
Garante que existem pelo menos <code>extra</code> posi&ccedil;&otilde;es dispon&iacute;veis na pilha.
A fun&ccedil;&atilde;o retorna falso se ela n&atilde;o puder aumentar o tamanho da pilha para o tamanho desejado.
Esta fun&ccedil;&atilde;o nunca comprime a pilha;
se a pilha j&aacute; &eacute; maior do que o novo tamanho,
ela n&atilde;o ter&aacute; o seu tamanho modificado.





<hr><h3><a name="lua_close"><code>lua_close</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>void lua_close (lua_State *L);</pre>

<p>
Destr&oacute;i todos os objetos no estado Lua fornecido
(chamando os metam&eacute;todos de coleta de lixo correspondentes, se houver)
e libera toda a mem&oacute;ria din&acirc;mica usada por aquele estado.
Em v&aacute;rias plataformas, pode n&atilde;o ser necess&aacute;rio chamar esta fun&ccedil;&atilde;o,
porque todos os recursos s&atilde;o naturalmente liberados quando o programa hospedeiro morre.
Por outro lado, programas que ficam rodando por muito tempo,
como um <em>daemon</em> ou um servidor web,
podem precisar liberar estados t&atilde;o logo eles n&atilde;o sejam mais necess&aacute;rios,
para evitar um crescimento demasiado do uso da mem&oacute;ria.





<hr><h3><a name="lua_concat"><code>lua_concat</code></a></h3><p>
<span class="apii">[-n, +1, <em>e</em>]</span>
<pre>void lua_concat (lua_State *L, int n);</pre>

<p>
Concatena os <code>n</code> valores no topo da pilha,
desempilha-os e deixa o resultado no topo da pilha.
Se <code>n</code>&nbsp;&eacute;&nbsp;1, o resultado &eacute; o &uacute;nico valor na pilha
(isto &eacute;, a fun&ccedil;&atilde;o n&atilde;o faz nada);
se <code>n</code> &eacute; 0, o resultado &eacute; a cadeia de caracteres vazia.
A concatena&ccedil;&atilde;o &eacute; realizada de acordo com a sem&acirc;ntica usual de Lua
(ver <a href="#2.5.4">&sect;2.5.4</a>).





<hr><h3><a name="lua_cpcall"><code>lua_cpcall</code></a></h3><p>
<span class="apii">[-0, +(0|1), <em>-</em>]</span>
<pre>int lua_cpcall (lua_State *L, lua_CFunction func, void *ud);</pre>

<p>
Chama a fun&ccedil;&atilde;o&nbsp;C <code>func</code> em modo protegido.
<code>func</code> inicia somente com um &uacute;nico elemento na sua pilha,
o objeto userdata leve contendo <code>ud</code>.
Em caso de erros,
<a href="#lua_cpcall"><code>lua_cpcall</code></a> retorna o mesmo c&oacute;digo de erro de <a href="#lua_pcall"><code>lua_pcall</code></a>,
mais o objeto de erro no topo da pilha;
caso contr&aacute;rio, ela retorna zero e n&atilde;o muda a pilha.
Todos os valores retornados por <code>func</code> s&atilde;o descartados.





<hr><h3><a name="lua_createtable"><code>lua_createtable</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>void lua_createtable (lua_State *L, int narr, int nrec);</pre>

<p>
Cria uma nova tabela vazia e a empilha no topo da pilha.
A nova tabela possui espa&ccedil;o pr&eacute;-alocado
para <code>narr</code> elementos array e <code>nrec</code> elementos n&atilde;o-array.
Esta pr&eacute;-aloca&ccedil;&atilde;o &eacute; &uacute;til quando voc&ecirc; sabe exatamente quantos elementos
a tabela ir&aacute; ter.
Caso contr&aacute;rio voc&ecirc; pode usar a fun&ccedil;&atilde;o <a href="#lua_newtable"><code>lua_newtable</code></a>.





<hr><h3><a name="lua_dump"><code>lua_dump</code></a></h3><p>
<span class="apii">[-0, +0, <em>m</em>]</span>
<pre>int lua_dump (lua_State *L, lua_Writer writer, void *data);</pre>

<p>
Descarrega uma fun&ccedil;&atilde;o como um trecho de c&oacute;digo bin&aacute;rio.
Recebe um fun&ccedil;&atilde;o Lua no topo da pilha
e produz um trecho de c&oacute;digo bin&aacute;rio que,
se carregado novamente,
resulta em uma fun&ccedil;&atilde;o equivalente &agrave;quela que foi descarregada.
Para produzir partes do trecho de c&oacute;digo,
<a href="#lua_dump"><code>lua_dump</code></a> chama a fun&ccedil;&atilde;o <code>writer</code> (ver <a href="#lua_Writer"><code>lua_Writer</code></a>)
com o argumento <code>data</code> fornecido
para escrev&ecirc;-los.


<p>
O valor retornado &eacute; o c&oacute;digo de erro retornado pela &uacute;ltima
chamada &agrave; fun&ccedil;&atilde;o <code>writer</code>;
0&nbsp;significa que n&atilde;o ocorreram erros.


<p>
Esta fun&ccedil;&atilde;o n&atilde;o desempilha a fun&ccedil;&atilde;o Lua da pilha.





<hr><h3><a name="lua_equal"><code>lua_equal</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
<pre>int lua_equal (lua_State *L, int index1, int index2);</pre>

<p>
Retorna 1 se os dois valores nos &iacute;ndices aceit&aacute;veis <code>index1</code> e
<code>index2</code> s&atilde;o iguais,
seguindo a sem&acirc;ntica do operador <code>==</code> de Lua
(ou seja, pode chamar metam&eacute;todos).
Caso contr&aacute;rio retorna&nbsp;0.
Tamb&eacute;m retorna&nbsp;0 se qualquer um dos &iacute;ndices n&atilde;o &eacute; v&aacute;lido.





<hr><h3><a name="lua_error"><code>lua_error</code></a></h3><p>
<span class="apii">[-1, +0, <em>v</em>]</span>
<pre>int lua_error (lua_State *L);</pre>

<p>
Gera um erro Lua.
A mensagem de erro (que pode ser de fato um valor Lua de qualquer tipo)
deve estar no topo da pilha.
Esta fun&ccedil;&atilde;o faz um desvio longo
e portanto nunca retorna.
(ver <a href="#luaL_error"><code>luaL_error</code></a>).





<hr><h3><a name="lua_gc"><code>lua_gc</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
<pre>int lua_gc (lua_State *L, int what, int data);</pre>

<p>
Controla o coletor de lixo.


<p>
Esta fun&ccedil;&atilde;o realiza v&aacute;rias tarefas,
de acordo com o valor do par&acirc;metro <code>what</code>:

<ul>

<li><b><code>LUA_GCSTOP</code>:</b>
p&aacute;ra o coletor de lixo.
</li>

<li><b><code>LUA_GCRESTART</code>:</b>
reinicia o coletor de lixo.
</li>

<li><b><code>LUA_GCCOLLECT</code>:</b>
realiza um ciclo completo de coleta de lixo.
</li>

<li><b><code>LUA_GCCOUNT</code>:</b>
retorna a quantidade de mem&oacute;ria (em Kbytes) que est&aacute; sendo usada correntemente por Lua.
</li>

<li><b><code>LUA_GCCOUNTB</code>:</b>
retorna o resto da divis&atilde;o da quantidade de bytes de mem&oacute;ria usada correntemente
por Lua por 1024.
</li>

<li><b><code>LUA_GCSTEP</code>:</b>
realiza um passo incremental de coleta de lixo.
O "tamanho" do passo &eacute; controlado por <code>data</code>
(valores maiores significam mais passos) de maneira n&atilde;o especificada.
Se voc&ecirc; quer controlar o tamanho do passo
voc&ecirc; deve ajustar de maneira experimental o valor de <code>data</code>.
A fun&ccedil;&atilde;o retorna 1 se o passo finalizou um
ciclo de coleta de lixo
</li>

<li><b><code>LUA_GCSETPAUSE</code>:</b>
estabelece <code>data</code> como o novo valor
para a <em>pausa</em> do coletor (ver <a href="#2.10">&sect;2.10</a>).
A fun&ccedil;&atilde;o retorna o valor anterior da pausa.	
</li>

<li><b><code>LUA_GCSETSTEPMUL</code>:</b>
estabelece <code>data</code> como o novo valor para o <em>multiplicador de passo</em>
do coletor (ver <a href="#2.10">&sect;2.10</a>).
A fun&ccedil;&atilde;o retorna o valor anterior do multiplicador de passo.
</li>

</ul>




<hr><h3><a name="lua_getallocf"><code>lua_getallocf</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>lua_Alloc lua_getallocf (lua_State *L, void **ud);</pre>

<p>
Retorna a fun&ccedil;&atilde;o de aloca&ccedil;&atilde;o de mem&oacute;ria de um dado estado.
Se <code>ud</code> n&atilde;o &eacute; <code>NULL</code>, Lua armazena em <code>*ud</code> o
ponteiro opaco passado para <a href="#lua_newstate"><code>lua_newstate</code></a>.





<hr><h3><a name="lua_getfenv"><code>lua_getfenv</code></a></h3><p>
<span class="apii">[-0, +1, <em>-</em>]</span>
<pre>void lua_getfenv (lua_State *L, int index);</pre>

<p>
Coloca na pilha a tabela de ambiente do
valor no &iacute;ndice fornecido.





<hr><h3><a name="lua_getfield"><code>lua_getfield</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>void lua_getfield (lua_State *L, int index, const char *k);</pre>

<p>
Coloca na pilha o valor <code>t[k]</code>,
onde <code>t</code> &eacute; o valor no &iacute;ndice v&aacute;lido fornecido.
Como em Lua, esta fun&ccedil;&atilde;o pode disparar um metam&eacute;todo
para o evento "index" (ver <a href="#2.8">&sect;2.8</a>).





<hr><h3><a name="lua_getglobal"><code>lua_getglobal</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>void lua_getglobal (lua_State *L, const char *name);</pre>

<p>
Coloca na pilha o valor da global <code>name</code>.
Esta fun&ccedil;&atilde;o &eacute; definida como uma macro:

<pre>
     #define lua_getglobal(L,s)  lua_getfield(L, LUA_GLOBALSINDEX, s)
</pre>




<hr><h3><a name="lua_getmetatable"><code>lua_getmetatable</code></a></h3><p>
<span class="apii">[-0, +(0|1), <em>-</em>]</span>
<pre>int lua_getmetatable (lua_State *L, int index);</pre>

<p>
Coloca na pilha a metatabela do valor no &iacute;ndice
aceit&aacute;vel fornecido.
Se o &iacute;ndice n&atilde;o &eacute; v&aacute;lido
ou se o valor n&atilde;o possui uma metatabela,
a fun&ccedil;&atilde;o retorna&nbsp;0 e n&atilde;o coloca nada na pilha.





<hr><h3><a name="lua_gettable"><code>lua_gettable</code></a></h3><p>
<span class="apii">[-1, +1, <em>e</em>]</span>
<pre>void lua_gettable (lua_State *L, int index);</pre>

<p>
Coloca na pilha o valor <code>t[k]</code>,
onde <code>t</code> &eacute; o valor no &iacute;ndice v&aacute;lido fornecido
e <code>k</code> &eacute; o valor no topo da pilha.


<p>
Esta fun&ccedil;&atilde;o desempilha a chave '<code>k</code>'
(colocando o resultado no seu lugar).
Como em Lua, esta fun&ccedil;&atilde;o pode disparar um metam&eacute;todo
para o evento "index" (ver <a href="#2.8">&sect;2.8</a>).





<hr><h3><a name="lua_gettop"><code>lua_gettop</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>int lua_gettop (lua_State *L);</pre>

<p>
Retorna o &iacute;ndice do elemento no topo da pilha.
Visto que os &iacute;ndices come&ccedil;am em&nbsp;1,
este resultado &eacute; igual ao n&uacute;mero de elementos na pilha
(e portanto 0&nbsp;significa uma pilha vazia).





<hr><h3><a name="lua_insert"><code>lua_insert</code></a></h3><p>
<span class="apii">[-1, +1, <em>-</em>]</span>
<pre>void lua_insert (lua_State *L, int index);</pre>

<p>
Move o elemento no topo para o &iacute;ndice v&aacute;lido fornecido,
deslocando os elementos acima deste &iacute;ndice para abrir espa&ccedil;o.
Esta fun&ccedil;&atilde;o n&atilde;o pode ser chamada com um pseudo-&iacute;ndice,
porque um pseudo-&iacute;ndice n&atilde;o &eacute; uma posi&ccedil;&atilde;o real da pilha.





<hr><h3><a name="lua_Integer"><code>lua_Integer</code></a></h3>
<pre>typedef ptrdiff_t lua_Integer;</pre>

<p>
O tipo usado pela API Lua para representar valores inteiros.


<p>
O tipo padr&atilde;o &eacute; um <code>ptrdiff_t</code>,
que &eacute; usualmente o maior tipo inteiro com sinal que a m&aacute;quina manipula
"confortavelmente".





<hr><h3><a name="lua_isboolean"><code>lua_isboolean</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>int lua_isboolean (lua_State *L, int index);</pre>

<p>
Retorna 1 se o valor no &iacute;ndice aceit&aacute;vel fornecido possui tipo booleano
e 0&nbsp;caso contr&aacute;rio.





<hr><h3><a name="lua_iscfunction"><code>lua_iscfunction</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>int lua_iscfunction (lua_State *L, int index);</pre>

<p>
Retorna 1 se o valor no &iacute;ndice aceit&aacute;vel fornecido &eacute; uma fun&ccedil;&atilde;o&nbsp;C
e 0&nbsp;caso contr&aacute;rio.





<hr><h3><a name="lua_isfunction"><code>lua_isfunction</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>int lua_isfunction (lua_State *L, int index);</pre>

<p>
Retorna 1 se o valor no &iacute;ndice aceit&aacute;vel fornecido &eacute; uma fun&ccedil;&atilde;o
(C ou Lua) e 0&nbsp;caso contr&aacute;rio.





<hr><h3><a name="lua_islightuserdata"><code>lua_islightuserdata</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>int lua_islightuserdata (lua_State *L, int index);</pre>

<p>
Retorna 1 se o valor no &iacute;ndice aceit&aacute;vel fornecido &eacute; um objeto userdata leve
e 0&nbsp;caso contr&aacute;rio.





<hr><h3><a name="lua_isnil"><code>lua_isnil</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>int lua_isnil (lua_State *L, int index);</pre>

<p>
Retorna 1 se o valor no &iacute;ndice aceit&aacute;vel fornecido &eacute; <b>nil</b>
e 0&nbsp;caso contr&aacute;rio.





<hr><h3><a name="lua_isnone"><code>lua_isnone</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>int lua_isnone (lua_State *L, int index);</pre>

<p>
Retorna 1 se o &iacute;ndice aceit&aacute;vel fornecido n&atilde;o &eacute; v&aacute;lido
(isto &eacute;, se ele se refere a um elemento fora do espa&ccedil;o da pilha corrente)
e 0&nbsp;caso contr&aacute;rio.





<hr><h3><a name="lua_isnoneornil"><code>lua_isnoneornil</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>int lua_isnoneornil (lua_State *L, int index);</pre>

<p>
Retorna 1 se o &iacute;ndice aceit&aacute;vel fornecido n&atilde;o &eacute; v&aacute;lido
(isto &eacute;, se ele se refere a um elemento fora do espa&ccedil;o da pilha corrente)
ou se o valor neste &iacute;ndice &eacute; <b>nil</b>
e 0&nbsp;caso contr&aacute;rio.





<hr><h3><a name="lua_isnumber"><code>lua_isnumber</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>int lua_isnumber (lua_State *L, int index);</pre>

<p>
Retorna 1 se o valor no &iacute;ndice aceit&aacute;vel fornecido &eacute; um n&uacute;mero
ou uma cadeia de caracteres que pode ser convertida para um n&uacute;mero
e 0&nbsp;caso contr&aacute;rio.





<hr><h3><a name="lua_isstring"><code>lua_isstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>int lua_isstring (lua_State *L, int index);</pre>

<p>
Retorna 1 se o valor no &iacute;ndice aceit&aacute;vel fornecido &eacute; uma cadeia de caracteres
ou um n&uacute;mero (o qual sempre pode ser convertido para uma cadeia)
e 0&nbsp;caso contr&aacute;rio.





<hr><h3><a name="lua_istable"><code>lua_istable</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>int lua_istable (lua_State *L, int index);</pre>

<p>
Retorna 1 se o valor no &iacute;ndice aceit&aacute;vel fornecido &eacute; uma tabela
e 0&nbsp;caso contr&aacute;rio.





<hr><h3><a name="lua_isthread"><code>lua_isthread</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>int lua_isthread (lua_State *L, int index);</pre>

<p>
Retorna 1 se o valor no &iacute;ndice aceit&aacute;vel fornecido &eacute; do tipo thread
e 0&nbsp;caso contr&aacute;rio.





<hr><h3><a name="lua_isuserdata"><code>lua_isuserdata</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>int lua_isuserdata (lua_State *L, int index);</pre>

<p>
Retorna 1 se o valor no &iacute;ndice aceit&aacute;vel fornecido &eacute; um objeto userdata
(completo ou leve) e 0&nbsp;caso contr&aacute;rio.





<hr><h3><a name="lua_lessthan"><code>lua_lessthan</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
<pre>int lua_lessthan (lua_State *L, int index1, int index2);</pre>

<p>
Retorna 1 se o valor no &iacute;ndice aceit&aacute;vel <code>index1</code> &eacute; menor
do que o valor no &iacute;ndice aceit&aacute;vel <code>index2</code>,
seguindo a sem&acirc;ntica do operador <code>&lt;</code> de Lua
(ou seja, pode chamar metam&eacute;todos).
Caso contr&aacute;rio retorna&nbsp;0.
Tamb&eacute;m retorna&nbsp;0 se qualquer um dos &iacute;ndices n&atilde;o for v&aacute;lido.





<hr><h3><a name="lua_load"><code>lua_load</code></a></h3><p>
<span class="apii">[-0, +1, <em>-</em>]</span>
<pre>int lua_load (lua_State *L,
              lua_Reader reader,
              void *data,
              const char *chunkname);</pre>

<p>
Carrega um trecho de c&oacute;digo Lua.
Se n&atilde;o ocorrer nenhum erro,
<a href="#lua_load"><code>lua_load</code></a> empilha o trecho compilado como uma
fun&ccedil;&atilde;o Lua no topo da pilha.
Caso contr&aacute;rio, empilha uma mensagem de erro.
Os valores de retorno de <a href="#lua_load"><code>lua_load</code></a> s&atilde;o:

<ul>

<li><b>0:</b> sem erros;</li>

<li><b><a name="pdf-LUA_ERRSYNTAX"><code>LUA_ERRSYNTAX</code></a>:</b>
erro de sintaxe durante a pr&eacute;-compila&ccedil;&atilde;o;</li>

<li><b><a href="#pdf-LUA_ERRMEM"><code>LUA_ERRMEM</code></a>:</b>
erro de aloca&ccedil;&atilde;o de mem&oacute;ria.</li>

</ul>

<p>
Esta fun&ccedil;&atilde;o somente carrega um trecho;
ela n&atilde;o o executa.


<p>
<a href="#lua_load"><code>lua_load</code></a> automaticamente detecta se o trecho est&aacute; na forma de texto ou na forma bin&aacute;ria
e o carrega de maneira correta (veja o programa <code>luac</code>).


<p>
A fun&ccedil;&atilde;o <a href="#lua_load"><code>lua_load</code></a> usa uma fun&ccedil;&atilde;o <code>reader</code> fornecida pelo usu&aacute;rio
para ler o trecho de c&oacute;digo (ver <a href="#lua_Reader"><code>lua_Reader</code></a>).
O argumento <code>data</code> &eacute; um valor opaco passado para a fun&ccedil;&atilde;o de leitura.


<p>
O argumento <code>chunkname</code> d&aacute; um nome ao trecho,
o qual &eacute; usado para mensagens de erro e em informa&ccedil;&otilde;es de depura&ccedil;&atilde;o (ver <a href="#3.8">&sect;3.8</a>).





<hr><h3><a name="lua_newstate"><code>lua_newstate</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>lua_State *lua_newstate (lua_Alloc f, void *ud);</pre>

<p>
Cria um estado novo independente.
Retorna <code>NULL</code> se n&atilde;o puder criar o estado
(devido &agrave; falta de mem&oacute;ria).
O argumento <code>f</code> &eacute; a fun&ccedil;&atilde;o de aloca&ccedil;&atilde;o;
Lua faz toda a aloca&ccedil;&atilde;o de mem&oacute;ria para este estado atrav&eacute;s desta fun&ccedil;&atilde;o.
O segundo argumento, <code>ud</code>, &eacute; um ponteiro opaco que Lua
simplesmente passa para a fun&ccedil;&atilde;o de aloca&ccedil;&atilde;o a cada chamada.





<hr><h3><a name="lua_newtable"><code>lua_newtable</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>void lua_newtable (lua_State *L);</pre>

<p>
Cria uma nova tabela vazia e a coloca na pilha.
&Eacute; equivalente a <code>lua_createtable(L, 0, 0)</code>.





<hr><h3><a name="lua_newthread"><code>lua_newthread</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>lua_State *lua_newthread (lua_State *L);</pre>

<p>
Cria um novo objeto do tipo thread, coloca-o na pilha
e retorna um ponteiro para um <a href="#lua_State"><code>lua_State</code></a> que representa este novo fluxo de execu&ccedil;&atilde;o.
O novo fluxo de execu&ccedil;&atilde;o retornado por esta fun&ccedil;&atilde;o compartilha todos os objetos globais
(tais como tabelas) com o estado original,
mas possui uma pilha de execu&ccedil;&atilde;o independente.


<p>
N&atilde;o h&aacute; uma fun&ccedil;&atilde;o expl&iacute;cita para terminar ou destruir um fluxo de execu&ccedil;&atilde;o.
Objetos do tipo thread est&atilde;o sujeitos &agrave; coleta de lixo,
assim como qualquer outro objeto de Lua.





<hr><h3><a name="lua_newuserdata"><code>lua_newuserdata</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>void *lua_newuserdata (lua_State *L, size_t size);</pre>

<p>
Esta fun&ccedil;&atilde;o aloca um novo bloco de mem&oacute;ria com o tamanho fornecido,
coloca na pilha um novo objeto userdata completo com o endere&ccedil;o do bloco
e retorna este endere&ccedil;o.


<p>
Objetos userdata representam valores&nbsp;C em Lua.
Um <em>userdata completo</em> representa um bloco de mem&oacute;ria.
Ele &eacute; um objeto (assim como uma tabela):
voc&ecirc; deve cri&aacute;-lo, ele pode ter sua pr&oacute;pria metatabela
e voc&ecirc; pode detectar quando ele est&aacute; sendo coletado.
Um objeto userdata completo somente &eacute; igual a ele mesmo (usando a igualdade primitiva, sem o uso de metam&eacute;todos).


<p>
Quando Lua coleta um userdata completo com um metam&eacute;todo <code>gc</code>,
Lua chama o metam&eacute;todo e marca o userdata como finalizado.
Quando este userdata &eacute; coletado novamente ent&atilde;o
Lua libera sua mem&oacute;ria correspondente.





<hr><h3><a name="lua_next"><code>lua_next</code></a></h3><p>
<span class="apii">[-1, +(2|0), <em>e</em>]</span>
<pre>int lua_next (lua_State *L, int index);</pre>

<p>
Desempilha uma chave da pilha
e empilha um par chave-valor da tabela no &iacute;ndice fornecido
(o "pr&oacute;ximo" par depois da chave fornecida).
Se n&atilde;o h&aacute; mais elementos na tabela,
ent&atilde;o <a href="#lua_next"><code>lua_next</code></a> retorna 0 (e n&atilde;o empilha nada).


<p>
Um percorrimento t&iacute;pico parece com este:

<pre>
     /* tabela est&aacute; na pilha no &iacute;ndice 't'' */
     lua_pushnil(L);  /* primeira chave */
     while (lua_next(L, t) != 0) {
       /* usa 'key' (no &iacute;ndice -2) e 'value' (no &iacute;ndice -1) */
       printf("%s - %s\n",
              lua_typename(L, lua_type(L, -2)),
              lua_typename(L, lua_type(L, -1)));
       /* remove 'value'; guarda 'key'  para a pr&oacute;xima itera&ccedil;&atilde;o */
       lua_pop(L, 1);
     }
</pre>

<p>
Durante o percorrimento de uma tabela,
n&atilde;o chame <a href="#lua_tolstring"><code>lua_tolstring</code></a> diretamente sobre uma chave,
a menos que voc&ecirc; saiba que a chave &eacute; realmente uma cadeia de carecteres.
Lembre-se que <a href="#lua_tolstring"><code>lua_tolstring</code></a> <em>altera</em>
o valor no &iacute;ndice fornecido;
isto confunde a pr&oacute;xima chamada para <a href="#lua_next"><code>lua_next</code></a>.





<hr><h3><a name="lua_Number"><code>lua_Number</code></a></h3>
<pre>typedef double lua_Number;</pre>

<p>
O tipo de n&uacute;meros em Lua.
Por padr&atilde;o, ele &eacute; double, mas pode ser mudado em <code>luaconf.h</code>.


<p>
Atrav&eacute;s do arquivo de configura&ccedil;&atilde;o &eacute; poss&iacute;vel mudar
Lua para operar com outro tipo para n&uacute;meros (e.g., float ou long).





<hr><h3><a name="lua_objlen"><code>lua_objlen</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>size_t lua_objlen (lua_State *L, int index);</pre>

<p>
Retorna o "comprimento" do valor no &iacute;ndice aceit&aacute;vel fornecido:
para cadeias de caracteres, isto &eacute; o comprimento da cadeia;	
para tabelas, isto &eacute; o resultado do operador de comprimento ('<code>#</code>');
para objetos do tipo userdata, isto &eacute; o tamanho do bloco de mem&oacute;ria alocado
para o userdata;
para outros valores, o tamanho &eacute;&nbsp;0.





<hr><h3><a name="lua_pcall"><code>lua_pcall</code></a></h3><p>
<span class="apii">[-(nargs + 1), +(nresults|1), <em>-</em>]</span>
<pre>int lua_pcall (lua_State *L, int nargs, int nresults, int errfunc);</pre>

<p>
Chama uma fun&ccedil;&atilde;o em modo protegido.


<p>
Tanto <code>nargs</code> quanto <code>nresults</code> possuem o mesmo significado
que possu&iacute;am em <a href="#lua_call"><code>lua_call</code></a>.
Se n&atilde;o h&aacute; erros durante a chamada,
<a href="#lua_pcall"><code>lua_pcall</code></a> comporta-se exatamente como <a href="#lua_call"><code>lua_call</code></a>.
Contudo, se h&aacute; qualquer erro,
<a href="#lua_pcall"><code>lua_pcall</code></a> o captura,
coloca um &uacute;nico valor na pilha (a mensagem de erro)
e retorna um c&oacute;digo de erro.
Como <a href="#lua_call"><code>lua_call</code></a>,
<a href="#lua_pcall"><code>lua_pcall</code></a> sempre remove a fun&ccedil;&atilde;o
e seus argumentos da pilha.


<p>
Se <code>errfunc</code> &eacute; 0,
ent&atilde;o a mensagem de erro retornada na pilha
&eacute; exatamente a mensagem de erro original.
Caso contr&aacute;rio, <code>errfunc</code> &eacute; o &iacute;ndice na pilha de um
<em>fun&ccedil;&atilde;o de tratamento de erros</em>.
(Na implementa&ccedil;&atilde;o atual, este &iacute;ndice n&atilde;o pode ser um pseudo-&iacute;ndice.)
No caso de erros de tempo de execu&ccedil;&atilde;o,
esta fun&ccedil;&atilde;o ser&aacute; chamada com a mensagem de erro
e seu valor de retorno ser&aacute; a mensagem retornada na pilha por <a href="#lua_pcall"><code>lua_pcall</code></a>.


<p>
Tipicamente, a fun&ccedil;&atilde;o de tratamento de erros &eacute; usada para adicionar mais informa&ccedil;&atilde;o
de depura&ccedil;&atilde;o &agrave; mensagem de erro, como um tra&ccedil;o da pilha.
Tal informa&ccedil;&atilde;o n&atilde;o pode ser obtida ap&oacute;s o retorno de <a href="#lua_pcall"><code>lua_pcall</code></a>,
pois neste ponto a pilha j&aacute; foi desfeita.


<p>
A fun&ccedil;&atilde;o <a href="#lua_pcall"><code>lua_pcall</code></a> retorna 0 em caso de sucesso
ou um dos seguintes c&oacute;digos de erro
(definidos em <code>lua.h</code>):

<ul>

<li><b><a name="pdf-LUA_ERRRUN"><code>LUA_ERRRUN</code></a>:</b>
um erro de tempo de execu&ccedil;&atilde;o.
</li>

<li><b><a name="pdf-LUA_ERRMEM"><code>LUA_ERRMEM</code></a>:</b>
erro de aloca&ccedil;&atilde;o de mem&oacute;ria.
Para tais erros, Lua n&atilde;o chama a fun&ccedil;&atilde;o de tratamento de erros.
</li>

<li><b><a name="pdf-LUA_ERRERR"><code>LUA_ERRERR</code></a>:</b>
erro quando estava executando a fun&ccedil;&atilde;o de tratamento de erros.
</li>

</ul>




<hr><h3><a name="lua_pop"><code>lua_pop</code></a></h3><p>
<span class="apii">[-n, +0, <em>-</em>]</span>
<pre>void lua_pop (lua_State *L, int n);</pre>

<p>
Desempilha <code>n</code> elementos da pilha.





<hr><h3><a name="lua_pushboolean"><code>lua_pushboolean</code></a></h3><p>
<span class="apii">[-0, +1, <em>-</em>]</span>
<pre>void lua_pushboolean (lua_State *L, int b);</pre>

<p>
Empilha um valor booleano com valor <code>b</code> na pilha.





<hr><h3><a name="lua_pushcclosure"><code>lua_pushcclosure</code></a></h3><p>
<span class="apii">[-n, +1, <em>m</em>]</span>
<pre>void lua_pushcclosure (lua_State *L, lua_CFunction fn, int n);</pre>

<p>
Empilha um novo fecho&nbsp;C na pilha.


<p>
Quando uma fun&ccedil;&atilde;o&nbsp;C &eacute; criada,
&eacute; poss&iacute;vel associar alguns valores a ela,
criando ent&atilde;o um fecho&nbsp;C (ver <a href="#3.4">&sect;3.4</a>);
estes valores s&atilde;o ent&atilde;o acess&iacute;veis para a fun&ccedil;&atilde;o sempre que ela &eacute; chamada.
Para associar valores com uma fun&ccedil;&atilde;o&nbsp;C,
primeiro estes valores devem ser colocados na pilha
(quando h&aacute; m&uacute;ltiplos valores, o primeiro valor &eacute; empilhado primeiro).
Ent&atilde;o <a href="#lua_pushcclosure"><code>lua_pushcclosure</code></a>
&eacute; chamada para criar e colocar a fun&ccedil;&atilde;o&nbsp;C na pilha,
com o argumento <code>n</code> informando quantos valores devem ser
associados com a fun&ccedil;&atilde;o.
<a href="#lua_pushcclosure"><code>lua_pushcclosure</code></a> tamb&eacute;m desempilha estes valores da pilha.


<p>
O valor m&aacute;ximo para <code>n</code> &eacute; 255.





<hr><h3><a name="lua_pushcfunction"><code>lua_pushcfunction</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>void lua_pushcfunction (lua_State *L, lua_CFunction f);</pre>

<p>
Empilha uma fun&ccedil;&atilde;o&nbsp;C na pilha.
Esta fun&ccedil;&atilde;o recebe um ponteiro para uma fun&ccedil;&atilde;o C
e coloca na pilha um valor Lua do tipo <code>function</code> que,
quando chamado, invoca a fun&ccedil;&atilde;o&nbsp;C correspondente.


<p>
Qualquer fun&ccedil;&atilde;o para ser registrada em Lua deve
seguir o protocolo correto para receber seus par&acirc;metros
e retornar seus resultados (ver <a href="#lua_CFunction"><code>lua_CFunction</code></a>).


<p>
<code>lua_pushcfunction</code> &eacute; definida como uma macro:

<pre>
     #define lua_pushcfunction(L,f)  lua_pushcclosure(L,f,0)
</pre>




<hr><h3><a name="lua_pushfstring"><code>lua_pushfstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>const char *lua_pushfstring (lua_State *L, const char *fmt, ...);</pre>

<p>
Coloca na pilha uma cadeia de caracteres formatada
e retorna um ponteiro para esta cadeia.
Ela &eacute; similar &agrave; fun&ccedil;&atilde;o&nbsp;C <code>sprintf</code>,
mas possui algumas diferen&ccedil;as importantes:



<ul>

<li>
Voc&ecirc; n&atilde;o precisa alocar espa&ccedil;o para o resultado:
o resultado &eacute; uma cadeia de caracteres e Lua cuida da aloca&ccedil;&atilde;o de mem&oacute;ria
(e da desaloca&ccedil;&atilde;o, atrav&eacute;s da coleta de lixo).
</li>

<li>
Os especificadores de convers&atilde;o s&atilde;o bastante restritos.
N&atilde;o h&aacute; <em>flags</em>, tamanhos ou precis&otilde;es.
Os especificadores de convers&atilde;o podem ser somente
'<code>%%</code>' (insere um '<code>%</code>' na cadeia),
'<code>%s</code>' (insere uma cadeia terminada por zero, sem restri&ccedil;&otilde;es de tamanho),
'<code>%f</code>' (insere um <a href="#lua_Number"><code>lua_Number</code></a>),
'<code>%p</code>' (insere um ponteiro como um n&uacute;mero hexadecimal),
'<code>%d</code>' (insere um <code>int</code>) e
'<code>%c</code>' (insere um <code>int</code> como um caractere).
</li>

</ul>




<hr><h3><a name="lua_pushinteger"><code>lua_pushinteger</code></a></h3><p>
<span class="apii">[-0, +1, <em>-</em>]</span>
<pre>void lua_pushinteger (lua_State *L, lua_Integer n);</pre>

<p>
Coloca um n&uacute;mero com valor <code>n</code> na pilha.





<hr><h3><a name="lua_pushliteral"><code>lua_pushliteral</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>void lua_pushliteral (lua_State *L, const char *s);</pre>

<p>
Esta macro &eacute; equivalente a <a href="#lua_pushlstring"><code>lua_pushlstring</code></a>,
mas somente pode ser usada quando <code>s</code> &eacute; uma cadeia
literal. Nestes casos, a macro automaticamente prov&ecirc;
o comprimento da cadeia.





<hr><h3><a name="lua_pushlightuserdata"><code>lua_pushlightuserdata</code></a></h3><p>
<span class="apii">[-0, +1, <em>-</em>]</span>
<pre>void lua_pushlightuserdata (lua_State *L, void *p);</pre>

<p>
Coloca um objeto do tipo userdata leve na pilha.


<p>
Um userdata representa valores&nbsp;de&nbsp;C em Lua.
Um <em>userdata leve</em> representa um ponteiro.
Ele &eacute; um valor (como um n&uacute;mero):
voc&ecirc; n&atilde;o pode cri&aacute;-lo, ele n&atilde;o possui uma metatabela individual
e ele n&atilde;o &eacute; coletado (uma vez que ele nunca foi criado).
Um userdata leve &eacute; igual a "qualquer"
userdata leve com o mesmo endere&ccedil;o&nbsp;C.





<hr><h3><a name="lua_pushlstring"><code>lua_pushlstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>void lua_pushlstring (lua_State *L, const char *s, size_t len);</pre>

<p>
Empilha a cadeia de caracteres apontada por <code>s</code> com tamanho <code>len</code>
na pilha.
Lua cria (ou reusa) uma c&oacute;pia interna da cadeia fornecida,
de forma que a mem&oacute;ria apontada por <code>s</code> pode ser liberada ou reutilizada imediatamente ap&oacute;s
o retorno da fun&ccedil;&atilde;o.
A cadeia pode conter zeros dentro dela.





<hr><h3><a name="lua_pushnil"><code>lua_pushnil</code></a></h3><p>
<span class="apii">[-0, +1, <em>-</em>]</span>
<pre>void lua_pushnil (lua_State *L);</pre>

<p>
Coloca um valor nil na pilha.





<hr><h3><a name="lua_pushnumber"><code>lua_pushnumber</code></a></h3><p>
<span class="apii">[-0, +1, <em>-</em>]</span>
<pre>void lua_pushnumber (lua_State *L, lua_Number n);</pre>

<p>
Coloca um n&uacute;mero com valor <code>n</code> na pilha.





<hr><h3><a name="lua_pushstring"><code>lua_pushstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>void lua_pushstring (lua_State *L, const char *s);</pre>

<p>
Empilha a cadeia terminada por zero apontada por <code>s</code>
na pilha.
Lua cria (ou reusa) uma c&oacute;pia interna da cadeia fornecida,
de forma que a mem&oacute;ria apontada por <code>s</code> pode ser liberada ou reutilizada imediatamente ap&oacute;s
o retorno da fun&ccedil;&atilde;o.
A cadeia n&atilde;o pode conter zeros dentro dela;
assume-se que a cadeia termina no primeiro zero.





<hr><h3><a name="lua_pushthread"><code>lua_pushthread</code></a></h3><p>
<span class="apii">[-0, +1, <em>-</em>]</span>
<pre>int lua_pushthread (lua_State *L);</pre>

<p>
Empilha o fluxo de execu&ccedil;&atilde;o representado por <code>L</code> na pilha.
Retorna 1 se este fluxo de execu&ccedil;&atilde;o &eacute; o fluxo de execu&ccedil;&atilde;o principal do seu estado.





<hr><h3><a name="lua_pushvalue"><code>lua_pushvalue</code></a></h3><p>
<span class="apii">[-0, +1, <em>-</em>]</span>
<pre>void lua_pushvalue (lua_State *L, int index);</pre>

<p>
Empilha uma c&oacute;pia do elemento no &iacute;ndice v&aacute;lido fornecido
na pilha.





<hr><h3><a name="lua_pushvfstring"><code>lua_pushvfstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>const char *lua_pushvfstring (lua_State *L,
                              const char *fmt,
                              va_list argp);</pre>

<p>
Equivalente a <a href="#lua_pushfstring"><code>lua_pushfstring</code></a>, exceto que esta fun&ccedil;&atilde;o recebe uma <code>va_list</code>
ao inv&eacute;s de um n&uacute;mero vari&aacute;vel de argumentos.





<hr><h3><a name="lua_rawequal"><code>lua_rawequal</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>int lua_rawequal (lua_State *L, int index1, int index2);</pre>

<p>
Retorna 1 se os dois valores nos &iacute;ndices aceit&aacute;veis <code>index1</code> e
<code>index2</code> s&atilde;o iguais primitivamente
(isto &eacute;, sem fazer chamadas a metam&eacute;todos).
Caso contr&aacute;rio retorna&nbsp;0.
Tamb&eacute;m retorna&nbsp;0 se qualquer um dos &iacute;ndices n&atilde;o for v&aacute;lido.





<hr><h3><a name="lua_rawget"><code>lua_rawget</code></a></h3><p>
<span class="apii">[-1, +1, <em>-</em>]</span>
<pre>void lua_rawget (lua_State *L, int index);</pre>

<p>
Similar a <a href="#lua_gettable"><code>lua_gettable</code></a>, mas faz um acesso primitivo
(i.e., sem usar metam&eacute;todos).





<hr><h3><a name="lua_rawgeti"><code>lua_rawgeti</code></a></h3><p>
<span class="apii">[-0, +1, <em>-</em>]</span>
<pre>void lua_rawgeti (lua_State *L, int index, int n);</pre>

<p>
Coloca na pilha o valor <code>t[n]</code>,
onde <code>t</code> &eacute; o valor no &iacute;ndice v&aacute;lido fornecido.
O acesso &eacute; primitivo;
isto &eacute;, ele n&atilde;o invoca metam&eacute;todos.





<hr><h3><a name="lua_rawset"><code>lua_rawset</code></a></h3><p>
<span class="apii">[-2, +0, <em>m</em>]</span>
<pre>void lua_rawset (lua_State *L, int index);</pre>

<p>
Similar a <a href="#lua_settable"><code>lua_settable</code></a>, mas faz uma atribui&ccedil;&atilde;o primitiva
(i.e., sem usar metam&eacute;todos).





<hr><h3><a name="lua_rawseti"><code>lua_rawseti</code></a></h3><p>
<span class="apii">[-1, +0, <em>m</em>]</span>
<pre>void lua_rawseti (lua_State *L, int index, int n);</pre>

<p>
Faz o equivalente a <code>t[n] = v</code>,
onde <code>t</code> &eacute; o valor no &iacute;ndice v&aacute;lido fornecido
e <code>v</code> &eacute; o valor no topo da pilha.


<p>
Esta fun&ccedil;&atilde;o desempilha o valor da pilha.
A atribui&ccedil;&atilde;o &eacute; primitiva;
isto &eacute;, ela n&atilde;o invoca metam&eacute;todos.





<hr><h3><a name="lua_Reader"><code>lua_Reader</code></a></h3>
<pre>typedef const char * (*lua_Reader) (lua_State *L,
                                    void *data,
                                    size_t *size);</pre>

<p>
A fun&ccedil;&atilde;o de leitura usada por <a href="#lua_load"><code>lua_load</code></a>.
Toda vez que ela precisa de outro peda&ccedil;o do trecho,
<a href="#lua_load"><code>lua_load</code></a> chama a fun&ccedil;&atilde;o de leitura,
passando junto o seu par&acirc;metro <code>data</code>.
A fun&ccedil;&atilde;o de leitura deve retornar um ponteiro para um bloco de mem&oacute;ria
com um novo peda&ccedil;o do trecho
e atribuir a <code>*size</code> o tamanho do bloco.
O bloco deve existir at&eacute; que a fun&ccedil;&atilde;o de leitura seja chamada novamente.
Para sinalizar o fim do trecho,
a fun&ccedil;&atilde;o de leitura deve retornar <code>NULL</code> ou atribuir zero a <code>size</code>.
A fun&ccedil;&atilde;o de leitura pode retornar peda&ccedil;os de qualquer tamanho maior do que zero.





<hr><h3><a name="lua_register"><code>lua_register</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
<pre>void lua_register (lua_State *L,
                   const char *name,
                   lua_CFunction f);</pre>

<p>
Estabelece a fun&ccedil;&atilde;o C <code>f</code> como o novo valor da global <code>name</code>.
Esta fun&ccedil;&atilde;o &eacute; definida como uma macro:

<pre>
     #define lua_register(L,n,f) \
            (lua_pushcfunction(L, f), lua_setglobal(L, n))
</pre>




<hr><h3><a name="lua_remove"><code>lua_remove</code></a></h3><p>
<span class="apii">[-1, +0, <em>-</em>]</span>
<pre>void lua_remove (lua_State *L, int index);</pre>

<p>
Remove o elemento no &iacute;ndice v&aacute;lido fornecido,
deslocando para baixo os elementos acima deste &iacute;ndice para preencher o buraco.
Esta fun&ccedil;&atilde;o n&atilde;o pode ser chamada com um pseudo-&iacute;ndice,
visto que o pseudo-&iacute;ndice n&atilde;o &eacute; uma posi&ccedil;&atilde;o real da pilha.





<hr><h3><a name="lua_replace"><code>lua_replace</code></a></h3><p>
<span class="apii">[-1, +0, <em>-</em>]</span>
<pre>void lua_replace (lua_State *L, int index);</pre>

<p>
Move o elemento do topo para a posi&ccedil;&atilde;o fornecida (e desempilha-o),
sem deslocar qualquer elemento
(substituindo portanto o valor na posi&ccedil;&atilde;o fornecida).





<hr><h3><a name="lua_resume"><code>lua_resume</code></a></h3><p>
<span class="apii">[-?, +?, <em>-</em>]</span>
<pre>int lua_resume (lua_State *L, int narg);</pre>

<p>
Inicia e recome&ccedil;a uma co-rotina em um fluxo de execu&ccedil;&atilde;o.


<p>
Para iniciar uma co-rotina, voc&ecirc; deve primeiro criar um novo fluxo de execu&ccedil;&atilde;o
(ver <a href="#lua_newthread"><code>lua_newthread</code></a>);
em seguida voc&ecirc; deve colocar na sua pilha a fun&ccedil;&atilde;o principal mais quaisquer argumentos;
por &uacute;ltimo voc&ecirc; chama <a href="#lua_resume"><code>lua_resume</code></a>,
com <code>narg</code> sendo o n&uacute;mero de argumentos.
Esta chamada retorna quando a co-rotina suspende ou finaliza sua execu&ccedil;&atilde;o.
Quando ela retorna, a pilha cont&eacute;m todos os valores passados para <a href="#lua_yield"><code>lua_yield</code></a>
ou todos os valores retornados pelo corpo da fun&ccedil;&atilde;o.
<a href="#lua_resume"><code>lua_resume</code></a> retorna
<a href="#pdf-LUA_YIELD"><code>LUA_YIELD</code></a> se a co-rotina cede,
0 se a co-rotina termina sua execu&ccedil;&atilde;o
sem erros
ou um c&oacute;digo de erro no caso de acontecerem erros (ver <a href="#lua_pcall"><code>lua_pcall</code></a>).
No caso de erros,
a pilha n&atilde;o &eacute; desfeita,
de forma que voc&ecirc; pode usar a API de depura&ccedil;&atilde;o sobre ela.
A mensagem de erro est&aacute; no topo da pilha.
Para reiniciar uma co-rotina, voc&ecirc; deve colocar na pilha dela somente os valores
a serem passados como resultados de <code>yield</code>
e ent&atilde;o chamar <a href="#lua_resume"><code>lua_resume</code></a>.





<hr><h3><a name="lua_setallocf"><code>lua_setallocf</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>void lua_setallocf (lua_State *L, lua_Alloc f, void *ud);</pre>

<p>
Muda a fun&ccedil;&atilde;o de aloca&ccedil;&atilde;o de um dado estado para <code>f</code>
com objeto userdata <code>ud</code>.





<hr><h3><a name="lua_setfenv"><code>lua_setfenv</code></a></h3><p>
<span class="apii">[-1, +0, <em>-</em>]</span>
<pre>int lua_setfenv (lua_State *L, int index);</pre>

<p>
Desempilha uma tabela da pilha e estabelece esta tabela como
sendo o novo ambiente para o valor no &iacute;ndice fornecido.
Se o valor no &iacute;ndice fornecido n&atilde;o &eacute;
nem uma fun&ccedil;&atilde;o, nem um fluxo de execu&ccedil;&atilde;o e nem um objeto userdata,
<a href="#lua_setfenv"><code>lua_setfenv</code></a> retorna 0.
Caso contr&aacute;rio a fun&ccedil;&atilde;o retorna 1.





<hr><h3><a name="lua_setfield"><code>lua_setfield</code></a></h3><p>
<span class="apii">[-1, +0, <em>e</em>]</span>
<pre>void lua_setfield (lua_State *L, int index, const char *k);</pre>

<p>
Faz o equivalente a <code>t[k] = v</code>,
onde <code>t</code> &eacute; o valor no &iacute;ndice v&aacute;lido fornecido
e <code>v</code> &eacute; o valor no topo da pilha.


<p>
Esta fun&ccedil;&atilde;o desempilha o valor da pilha.
Como em Lua, esta fun&ccedil;&atilde;o pode disparar um metam&eacute;todo
para o evento "newindex" (ver <a href="#2.8">&sect;2.8</a>).





<hr><h3><a name="lua_setglobal"><code>lua_setglobal</code></a></h3><p>
<span class="apii">[-1, +0, <em>e</em>]</span>
<pre>void lua_setglobal (lua_State *L, const char *name);</pre>

<p>
Desempilha um valor da pilha e
o estabelece como o novo valor da global <code>name</code>.
Esta fun&ccedil;&atilde;o &eacute; definida como uma macro:

<pre>
     #define lua_setglobal(L,s)   lua_setfield(L, LUA_GLOBALSINDEX, s)
</pre>




<hr><h3><a name="lua_setmetatable"><code>lua_setmetatable</code></a></h3><p>
<span class="apii">[-1, +0, <em>-</em>]</span>
<pre>int lua_setmetatable (lua_State *L, int index);</pre>

<p>
Desempilha uma tabela da pilha e
estabelece esta tabela como a nova metatabela para o valor no &iacute;ndice
aceit&aacute;vel fornecido.





<hr><h3><a name="lua_settable"><code>lua_settable</code></a></h3><p>
<span class="apii">[-2, +0, <em>e</em>]</span>
<pre>void lua_settable (lua_State *L, int index);</pre>

<p>
Faz o equivalente a <code>t[k] = v</code>,
onde <code>t</code> &eacute; o valor no &iacute;ndice v&aacute;lido fornecido,
<code>v</code> &eacute; o valor no topo da pilha
e <code>k</code> &eacute; o valor logo abaixo do topo.


<p>
Esta fun&ccedil;&atilde;o desempilha tanto a chave como o valor da pilha.
Da mesma forma que em Lua, esta fun&ccedil;&atilde;o pode disparar um metam&eacute;todo
para o evento "newindex" (ver <a href="#2.8">&sect;2.8</a>).





<hr><h3><a name="lua_settop"><code>lua_settop</code></a></h3><p>
<span class="apii">[-?, +?, <em>-</em>]</span>
<pre>void lua_settop (lua_State *L, int index);</pre>

<p>
Aceita qualquer &iacute;ndice aceit&aacute;vel, ou&nbsp;0,
e estabelece este &iacute;ndice como o topo da pilha.
Se o novo topo &eacute; maior do que o antigo,
ent&atilde;o os novos elementos s&atilde;o preenchidos com <b>nil</b>.
Se <code>index</code> &eacute;&nbsp;0, ent&atilde;o todos os elementos da pilha s&atilde;o removidos.





<hr><h3><a name="lua_State"><code>lua_State</code></a></h3>
<pre>typedef struct lua_State lua_State;</pre>

<p>
Estrutura opaca que guarda o estado completo de um interpretador Lua.
A biblioteca de Lua &eacute; totalmente reentrante:
n&atilde;o existem vari&aacute;veis globais.
Toda a informa&ccedil;&atilde;o sobre um estado &eacute; mantida nesta estrutura.


<p>
Um ponteiro para este estado deve ser passado como o primeiro argumento para
toda fun&ccedil;&atilde;o na biblioteca, exceto para <a href="#lua_newstate"><code>lua_newstate</code></a>,
que cria um novo estado Lua a partir do zero.





<hr><h3><a name="lua_status"><code>lua_status</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>int lua_status (lua_State *L);</pre>

<p>
Retorna o status do fluxo de execu&ccedil;&atilde;o <code>L</code>.


<p>
O status pode ser 0 para um fluxo de execu&ccedil;&atilde;o normal,
um c&oacute;digo de erro se o fluxo de execu&ccedil;&atilde;o terminou sua execu&ccedil;&atilde;o com um erro
ou <a name="pdf-LUA_YIELD"><code>LUA_YIELD</code></a> se o fluxo de execu&ccedil;&atilde;o est&aacute; suspenso.





<hr><h3><a name="lua_toboolean"><code>lua_toboolean</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>int lua_toboolean (lua_State *L, int index);</pre>

<p>
Converte um valor Lua no &iacute;ndice aceit&aacute;vel fornecido para um valor
booleano&nbsp;C (0&nbsp;ou&nbsp;1).
Como todos os testes em Lua,
<a href="#lua_toboolean"><code>lua_toboolean</code></a> retorna 1 para qualquer valor Lua
diferente de <b>false</b> e de <b>nil</b>;
caso contr&aacute;rio a fun&ccedil;&atilde;o retorna 0.
A fun&ccedil;&atilde;o tamb&eacute;m retorna 0 quando chamada com um &iacute;ndice n&atilde;o v&aacute;lido.
(Se voc&ecirc; quiser aceitar somente valores booleanos de fato,
use <a href="#lua_isboolean"><code>lua_isboolean</code></a> para testar o tipo do valor.)





<hr><h3><a name="lua_tocfunction"><code>lua_tocfunction</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>lua_CFunction lua_tocfunction (lua_State *L, int index);</pre>

<p>
Converte um valor no &iacute;ndice aceit&aacute;vel fornecido para uma fun&ccedil;&atilde;o&nbsp;C.
Tal valor deve ser uma fun&ccedil;&atilde;o&nbsp;C;
caso contr&aacute;rio, retorna <code>NULL</code>.





<hr><h3><a name="lua_tointeger"><code>lua_tointeger</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>lua_Integer lua_tointeger (lua_State *L, int index);</pre>

<p>
Converte o valor Lua no &iacute;ndice aceit&aacute;vel fornecido
para o tipo inteiro com sinal <a href="#lua_Integer"><code>lua_Integer</code></a>.
O valor Lua deve ser um n&uacute;mero ou uma cadeia que pode ser convertida para um n&uacute;mero
(ver <a href="#2.2.1">&sect;2.2.1</a>);
caso contr&aacute;rio, <a href="#lua_tointeger"><code>lua_tointeger</code></a> retorna&nbsp;0.


<p>
Se o n&uacute;mero n&atilde;o &eacute; um inteiro,
ele &eacute; truncado de alguma maneira n&atilde;o especificada.





<hr><h3><a name="lua_tolstring"><code>lua_tolstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>m</em>]</span>
<pre>const char *lua_tolstring (lua_State *L, int index, size_t *len);</pre>

<p>
Converte o valor Lua no &iacute;ndice aceit&aacute;vel fornecido para uma cadeia&nbsp;C.
Se <code>len</code> n&atilde;o &eacute; <code>NULL</code>,
a fun&ccedil;&atilde;o tamb&eacute;m estabelece <code>*len</code> como o comprimento da cadeia.
O valor Lua deve ser uma cadeia de caracteres ou um n&uacute;mero;
caso contr&aacute;rio, a fun&ccedil;&atilde;o retorna <code>NULL</code>.
Se o valor &eacute; um n&uacute;mero,
ent&atilde;o <a href="#lua_tolstring"><code>lua_tolstring</code></a> tamb&eacute;m
<em>muda o valor real na pilha para uma cadeia</em>.
(Esta mudan&ccedil;a confunde <a href="#lua_next"><code>lua_next</code></a>
quando <a href="#lua_tolstring"><code>lua_tolstring</code></a> &eacute; aplicada a chaves durante um percorrimento de tabela.)


<p>
<a href="#lua_tolstring"><code>lua_tolstring</code></a> retorna um ponteiro totalmente alinhado
para uma cadeia de caracteres dentro do estado Lua.
Esta cadeia sempre tem um zero ('<code>\0</code>')
ap&oacute;s o seu &uacute;ltimo caractere (como em&nbsp;C),
mas pode conter outros zeros no seu corpo.
Visto que Lua possui coleta de lixo,
n&atilde;o h&aacute; garantia de que o ponteiro retornado por <a href="#lua_tolstring"><code>lua_tolstring</code></a>
ser&aacute; v&aacute;lido ap&oacute;s o valor correspondente ser removido da pilha.





<hr><h3><a name="lua_tonumber"><code>lua_tonumber</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>lua_Number lua_tonumber (lua_State *L, int index);</pre>

<p>
Converte o valor Lua no &iacute;ndice aceit&aacute;vel fornecido
para o tipo&nbsp;C <a href="#lua_Number"><code>lua_Number</code></a> (ver <a href="#lua_Number"><code>lua_Number</code></a>).
O valor Lua deve ser um n&uacute;mero ou uma cadeia que pode ser convertida para um n&uacute;mero
(ver <a href="#2.2.1">&sect;2.2.1</a>);
caso contr&aacute;rio, <a href="#lua_tonumber"><code>lua_tonumber</code></a> retorna&nbsp;0.





<hr><h3><a name="lua_topointer"><code>lua_topointer</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>const void *lua_topointer (lua_State *L, int index);</pre>

<p>
Converte o valor no &iacute;ndice aceit&aacute;vel fornecido para um
ponteiro&nbsp;C gen&eacute;rico (<code>void*</code>).
O valor pode ser um objeto userdata, uma tabela, um fluxo de execu&ccedil;&atilde;o ou uma fun&ccedil;&atilde;o;
objetos diferentes ir&atilde;o fornecer ponteiros diferentes.
N&atilde;o h&aacute; maneira de converter o ponteiro de volta ao seu valor original.


<p>
Tipicamente esta fun&ccedil;&atilde;o &eacute; usada somente para informa&ccedil;&otilde;es de depura&ccedil;&atilde;o.





<hr><h3><a name="lua_tostring"><code>lua_tostring</code></a></h3><p>
<span class="apii">[-0, +0, <em>m</em>]</span>
<pre>const char *lua_tostring (lua_State *L, int index);</pre>

<p>
Equivalente a <a href="#lua_tolstring"><code>lua_tolstring</code></a> com <code>len</code> sendo igual a <code>NULL</code>.





<hr><h3><a name="lua_tothread"><code>lua_tothread</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>lua_State *lua_tothread (lua_State *L, int index);</pre>

<p>
Converte o valor no &iacute;ndice aceit&aacute;vel fornecido para um fluxo de execu&ccedil;&atilde;o
(representado como <code>lua_State*</code>).
Este valor deve ser um fluxo de execu&ccedil;&atilde;o;
caso contr&aacute;rio, a fun&ccedil;&atilde;o retorna <code>NULL</code>.





<hr><h3><a name="lua_touserdata"><code>lua_touserdata</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>void *lua_touserdata (lua_State *L, int index);</pre>

<p>
Se o valor no &iacute;ndice aceit&aacute;vel fornecido &eacute; um objeto userdata completo,
a fun&ccedil;&atilde;o retorna o endere&ccedil;o do seu bloco.
Se o valor &eacute; um userdata leve,
a fun&ccedil;&atilde;o retorna seu ponteiro.
Caso contr&aacute;rio, retorna <code>NULL</code>.





<hr><h3><a name="lua_type"><code>lua_type</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>int lua_type (lua_State *L, int index);</pre>

<p>
Retorna o tipo do valor no &iacute;ndice aceit&aacute;vel fornecido
ou <code>LUA_TNONE</code> para um &iacute;ndice n&atilde;o v&aacute;lido
(isto &eacute;, um &iacute;ndice para uma posi&ccedil;&atilde;o da pilha "vazia").
Os tipos retornados por <a href="#lua_type"><code>lua_type</code></a> s&atilde;o codificados pelas seguintes constantes
definidas em <code>lua.h</code>:
<code>LUA_TNIL</code>,
<code>LUA_TNUMBER</code>,
<code>LUA_TBOOLEAN</code>,
<code>LUA_TSTRING</code>,
<code>LUA_TTABLE</code>,
<code>LUA_TFUNCTION</code>,
<code>LUA_TUSERDATA</code>,
<code>LUA_TTHREAD</code>
e
<code>LUA_TLIGHTUSERDATA</code>.





<hr><h3><a name="lua_typename"><code>lua_typename</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>const char *lua_typename  (lua_State *L, int tp);</pre>

<p>
Retorna o nome do tipo codificado pelo valor <code>tp</code>,
que deve ser um dos valores retornados por <a href="#lua_type"><code>lua_type</code></a>.





<hr><h3><a name="lua_Writer"><code>lua_Writer</code></a></h3>
<pre>typedef int (*lua_Writer) (lua_State *L,
                           const void* p,
                           size_t sz,
                           void* ud);</pre>

<p>
O tipo da fun&ccedil;&atilde;o de escrita usada por <a href="#lua_dump"><code>lua_dump</code></a>.
Toda vez que ela produz outro peda&ccedil;o de trecho,
<a href="#lua_dump"><code>lua_dump</code></a> chama a fun&ccedil;&atilde;o de escrita,
passando junto o buffer a ser escrito (<code>p</code>),
seu tamanho (<code>sz</code>)
e o par&acirc;metro <code>data</code> fornecido para <a href="#lua_dump"><code>lua_dump</code></a>.


<p>
A fun&ccedil;&atilde;o de escrita retorna um c&oacute;digo de erro:
0&nbsp;significa nenhum erro;
qualquer outro valor significa um erro e faz <a href="#lua_dump"><code>lua_dump</code></a> parar de
chamar a fun&ccedil;&atilde;o de escrita.





<hr><h3><a name="lua_xmove"><code>lua_xmove</code></a></h3><p>
<span class="apii">[-?, +?, <em>-</em>]</span>
<pre>void lua_xmove (lua_State *from, lua_State *to, int n);</pre>

<p>
Troca valores entre diferentes fluxos de execu&ccedil;&atilde;o do <em>mesmo</em> estado global.


<p>
Esta fun&ccedil;&atilde;o desempilha <code>n</code> valores da pilha <code>from</code>
e os empilha na pilha <code>to</code>.





<hr><h3><a name="lua_yield"><code>lua_yield</code></a></h3><p>
<span class="apii">[-?, +?, <em>-</em>]</span>
<pre>int lua_yield  (lua_State *L, int nresults);</pre>

<p>
Cede uma co-rotina.


<p>
Esta fun&ccedil;&atilde;o somente deve ser chamada como a
express&atilde;o de retorno de uma fun&ccedil;&atilde;o&nbsp;C, como a seguir:

<pre>
     return lua_yield (L, nresults);
</pre><p>
Quando uma fun&ccedil;&atilde;o&nbsp;C chama <a href="#lua_yield"><code>lua_yield</code></a> desta maneira,
a co-rotina sendo executada suspende a sua execu&ccedil;&atilde;o
e a chamada a <a href="#lua_resume"><code>lua_resume</code></a> que iniciou esta co-rotina retorna.
O par&acirc;metro <code>results</code> &eacute; o n&uacute;mero de valores da pilha
que s&atilde;o passados como resultados para <a href="#lua_resume"><code>lua_resume</code></a>.







<h2>3.8 - <a name="3.8">A Interface de Depura&ccedil;&atilde;o</a></h2>

<p>
Lua n&atilde;o possui mecanismos de depura&ccedil;&atilde;o pr&eacute;-definidos.
Ao inv&eacute;s disto, ela oferece uma interface especial
por meio de fun&ccedil;&otilde;es e <em>ganchos</em>.
Esta interface permite a constru&ccedil;&atilde;o de diferentes
tipos de depuradores, medidores e outras ferramentas
que necessitam de "informa&ccedil;&atilde;o interna" do interpretador.



<hr><h3><a name="lua_Debug"><code>lua_Debug</code></a></h3>
<pre>typedef struct lua_Debug {
  int event;
  const char *name;           /* (n) */
  const char *namewhat;       /* (n) */
  const char *what;           /* (S) */
  const char *source;         /* (S) */
  int currentline;            /* (l) */
  int nups;                   /* (u) n&uacute;mero de upvalues */
  int linedefined;            /* (S) */
  int lastlinedefined;        /* (S) */
  char short_src[LUA_IDSIZE]; /* (S) */
  /* parte privada */
  <em>outros campos</em>
} lua_Debug;</pre>

<p>
Uma estrutura usada para guardar diferentes peda&ccedil;os de
informa&ccedil;&atilde;o sobre uma fun&ccedil;&atilde;o ativa.
<a href="#lua_getstack"><code>lua_getstack</code></a> preenche somente a parte privada
desta estrutura, para uso posterior.
Para preencher os outros campos de <a href="#lua_Debug"><code>lua_Debug</code></a> com informa&ccedil;&atilde;o &uacute;til,
chame <a href="#lua_getinfo"><code>lua_getinfo</code></a>.


<p>
Os campos de <a href="#lua_Debug"><code>lua_Debug</code></a> possuem o seguinte significado:

<ul>

<li><b><code>source</code>:</b>
Se a fun&ccedil;&atilde;o foi definida em uma cadeia de caracters,
ent&atilde;o <code>source</code> &eacute; essa cadeia.
Se a fun&ccedil;&atilde;o foi definida em um arquivo,
ent&atilde;o <code>source</code> inicia com um '<code>@</code>' seguido pelo nome do arquivo.
</li>
	

<li><b><code>short_src</code>:</b>
uma vers&atilde;o "adequada" para impress&atilde;o de <code>source</code>, para ser usada em mensagens de erro.
</li>

<li><b><code>linedefined</code>:</b>
o n&uacute;mero da linha onde a defini&ccedil;&atilde;o da fun&ccedil;&atilde;o come&ccedil;a.
</li>

<li><b><code>lastlinedefined</code>:</b>
o n&uacute;mero da linha onde a defini&ccedil;&atilde;o da fun&ccedil;&atilde;o termina.
</li>

<li><b><code>what</code>:</b>
a cadeia <code>"Lua"</code> se a fun&ccedil;&atilde;o &eacute; uma fun&ccedil;&atilde;o Lua,
<code>"C"</code> se ela &eacute; uma fun&ccedil;&atilde;o&nbsp;C,
<code>"main"</code> se ela &eacute; a parte principal de um trecho
e <code>"tail"</code> se ela foi uma fun&ccedil;&atilde;o que fez uma recurs&atilde;o final.
No &uacute;ltimo caso,
Lua n&atilde;o possui nenhuma outra informa&ccedil;&atilde;o sobre a fun&ccedil;&atilde;o.
</li>

<li><b><code>currentline</code>:</b>
a linha corrente onde a fun&ccedil;&atilde;o fornecida est&aacute; executando.
Quando nenhuma informa&ccedil;&atilde;o sobre a linha est&aacute; dispon&iacute;vel,
atribui-se -1 a <code>currentline</code>.
</li>

<li><b><code>name</code>:</b>
um nome razo&aacute;vel para a fun&ccedil;&atilde;o fornecida.
Dado que fun&ccedil;&otilde;es em Lua s&atilde;o valores de primeira classe,
elas n&atilde;o possuem um nome fixo:
algumas fun&ccedil;&otilde;es podem ser o valor de m&uacute;ltiplas vari&aacute;veis globais,
enquanto outras podem estar armazenadas somente em um campo de uma tabela.
A fun&ccedil;&atilde;o <code>lua_getinfo</code> verifica como a fun&ccedil;&atilde;o foi
chamada para encontrar um nome adequado.
Se n&atilde;o &eacute; poss&iacute;vel encontrar um nome,
ent&atilde;o atribui-se <code>NULL</code> a <code>name</code>.
</li>

<li><b><code>namewhat</code>:</b>
explica o campo <code>name</code>.
O valor de <code>namewhat</code> pode ser
<code>"global"</code>, <code>"local"</code>, <code>"method"</code>,
<code>"field"</code>, <code>"upvalue"</code> ou <code>""</code> (a cadeia vazia),
de acordo com como a fun&ccedil;&atilde;o foi chamada.
(Lua usa a cadeia vazia quando nenhuma outra op&ccedil;&atilde;o parece se aplicar.)
</li>

<li><b><code>nups</code>:</b>
o n&uacute;mero de upvalues da fun&ccedil;&atilde;o.
</li>

</ul>




<hr><h3><a name="lua_gethook"><code>lua_gethook</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>lua_Hook lua_gethook (lua_State *L);</pre>

<p>
Retorna a fun&ccedil;&atilde;o de gancho atual.





<hr><h3><a name="lua_gethookcount"><code>lua_gethookcount</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>int lua_gethookcount (lua_State *L);</pre>

<p>
Retorna a contagem de gancho atual.





<hr><h3><a name="lua_gethookmask"><code>lua_gethookmask</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>int lua_gethookmask (lua_State *L);</pre>

<p>
Retorna a m&aacute;scara de gancho atual.





<hr><h3><a name="lua_getinfo"><code>lua_getinfo</code></a></h3><p>
<span class="apii">[-(0|1), +(0|1|2), <em>m</em>]</span>
<pre>int lua_getinfo (lua_State *L, const char *what, lua_Debug *ar);</pre>

<p>
Retorna informa&ccedil;&atilde;o sobre uma fun&ccedil;&atilde;o espec&iacute;fica ou uma invoca&ccedil;&atilde;o de fun&ccedil;&atilde;o espec&iacute;fica.


<p>
Para obter informa&ccedil;&atilde;o sobre uma invoca&ccedil;&atilde;o de fun&ccedil;&atilde;o,
o par&acirc;metro <code>ar</code> deve ser um registro de ativa&ccedil;&atilde;o v&aacute;lido que foi
preenchido por uma chamada anterior a <a href="#lua_getstack"><code>lua_getstack</code></a> ou
foi fornecido como argumento para um gancho (ver <a href="#lua_Hook"><code>lua_Hook</code></a>).


<p>
Para obter informa&ccedil;&atilde;o sobre uma fun&ccedil;&atilde;o voc&ecirc; deve coloc&aacute;-la na pilha
e iniciar a cadeia <code>what</code> com o caractere '<code>&gt;</code>'.
(Neste caso,
<code>lua_getinfo</code> desempilha a fun&ccedil;&atilde;o no topo da pilha.)
Por exemplo, para saber em qual linha uma fun&ccedil;&atilde;o <code>f</code> foi definida,
voc&ecirc; pode escrever o seguinte c&oacute;digo:

<pre>
     lua_Debug ar;
     lua_getfield(L, LUA_GLOBALSINDEX, "f");  /* obt&eacute;m a global 'f' */
     lua_getinfo(L, "&gt;S", &amp;ar);
     printf("%d\n", ar.linedefined);
</pre>

<p>
Cada caractere na cadeia <code>what</code>
seleciona alguns campos da estrutura <code>ar</code> para serem preenchidos ou
um valor a ser empilhado na pilha:

<ul>

<li><b>'<code>n</code>':</b> preenche os campos <code>name</code> e <code>namewhat</code>;
</li>

<li><b>'<code>S</code>':</b>
preenche os campos <code>source</code>, <code>short_src</code>,
<code>linedefined</code>, <code>lastlinedefined</code> e <code>what</code>;
</li>

<li><b>'<code>l</code>':</b> preenche o campo <code>currentline</code>;
</li>

<li><b>'<code>u</code>':</b> preenche o campo <code>nups</code>;
</li>

<li><b>'<code>f</code>':</b>
coloca na pilha a fun&ccedil;&atilde;o que est&aacute;
executando no n&iacute;vel fornecido;
</li>

<li><b>'<code>L</code>':</b>
coloca na pilha uma tabela cujos &iacute;ndices s&atilde;o o
n&uacute;mero das linhas que s&atilde;o v&aacute;lidas na fun&ccedil;&atilde;o.
(Uma <em>linha v&aacute;lida</em> &eacute; uma linha com algum c&oacute;digo associado,
isto &eacute;, uma linha onde voc&ecirc; pode colocar um ponto de parada.
Linhas n&atilde;o v&aacute;lidas incluem linhas vazias e coment&aacute;rios.)
</li>

</ul>

<p>
Esta fun&ccedil;&atilde;o retorna 0 em caso de erro
(por exemplo, no caso de uma op&ccedil;&atilde;o inv&aacute;lida em <code>what</code>).





<hr><h3><a name="lua_getlocal"><code>lua_getlocal</code></a></h3><p>
<span class="apii">[-0, +(0|1), <em>-</em>]</span>
<pre>const char *lua_getlocal (lua_State *L, lua_Debug *ar, int n);</pre>

<p>
Obt&eacute;m informa&ccedil;&atilde;o sobre uma vari&aacute;vel local de um registro de ativa&ccedil;&atilde;o fornecido.
O par&acirc;metro <code>ar</code> deve ser um registro de ativa&ccedil;&atilde;o v&aacute;lido que foi
preenchido por uma chamada anterior a <a href="#lua_getstack"><code>lua_getstack</code></a> ou
foi fornecido como um argumento para um gancho (ver <a href="#lua_Hook"><code>lua_Hook</code></a>).
O &iacute;ndice <code>n</code> seleciona qual vari&aacute;vel local inspecionar
(1 &eacute; o primeiro par&acirc;metro ou vari&aacute;vel local ativa e assim por diante,
at&eacute; a &uacute;ltima vari&aacute;vel local ativa).
<a href="#lua_getlocal"><code>lua_getlocal</code></a> coloca o valor da vari&aacute;vel na pilha
e retorna o nome dela.


<p>
Nomes de vari&aacute;veis come&ccedil;ando com '<code>(</code>' (abre par&ecirc;nteses)
representam vari&aacute;veis internas
(vari&aacute;veis de controle de la&ccedil;os, tempor&aacute;rios e fun&ccedil;&otilde;es&nbsp;C locais.).


<p>
Retorna <code>NULL</code> (e n&atilde;o empilha nada)
quando o &iacute;ndice &eacute; maior do que
o n&uacute;mero de vari&aacute;veis locais ativas.





<hr><h3><a name="lua_getstack"><code>lua_getstack</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>int lua_getstack (lua_State *L, int level, lua_Debug *ar);</pre>

<p>
Obt&eacute;m informa&ccedil;&atilde;o sobre a pilha de tempo de execu&ccedil;&atilde;o do interpretador.


<p>
Esta fun&ccedil;&atilde;o preenche partes de uma estrutura <a href="#lua_Debug"><code>lua_Debug</code></a> com
uma identifica&ccedil;&atilde;o do <em>registro de ativa&ccedil;&atilde;o</em>
da fun&ccedil;&atilde;o executando em um dado n&iacute;vel.
O&nbsp;n&iacute;vel&nbsp;0 &eacute; a fun&ccedil;&atilde;o executando atualmente,
ao passo que o n&iacute;vel <em>n+1</em> &eacute; a fun&ccedil;&atilde;o que chamou o n&iacute;vel <em>n</em>.
Quando n&atilde;o h&aacute; erros, <a href="#lua_getstack"><code>lua_getstack</code></a> retorna 1;
quando chamada com um n&iacute;vel maior do que a profundidade da pilha,
a fun&ccedil;&atilde;o retorna 0.





<hr><h3><a name="lua_getupvalue"><code>lua_getupvalue</code></a></h3><p>
<span class="apii">[-0, +(0|1), <em>-</em>]</span>
<pre>const char *lua_getupvalue (lua_State *L, int funcindex, int n);</pre>

<p>
Obt&eacute;m informa&ccedil;&atilde;o sobre um upvalue de um fecho.
(Para fun&ccedil;&otilde;es Lua,
upvalues s&atilde;o vari&aacute;veis locais externas que a fun&ccedil;&atilde;o usa
e que s&atilde;o conceitualmente inclu&iacute;das no fecho dela.)
<a href="#lua_getupvalue"><code>lua_getupvalue</code></a> obt&eacute;m o &iacute;ndice <code>n</code> de um upvalue,
coloca o valor do upvalue na pilha
e retorna o nome dele.
<code>funcindex</code> aponta para o fecho na pilha.
(Upvalues n&atilde;o possuem uma ordem espec&iacute;fica,
uma vez que eles s&atilde;o ativos ao longo de toda a fun&ccedil;&atilde;o.
Ent&atilde;o, eles s&atilde;o numerados em uma ordem arbitr&aacute;ria.)


<p>
Retorna <code>NULL</code> (e n&atilde;o empilha nada)
quando o &iacute;ndice &eacute; maior do que o n&uacute;mero de upvalues.
Para fun&ccedil;&otilde;es&nbsp;C, esta fun&ccedil;&atilde;o usa a cadeia vazia <code>""</code>
como um nome para todos os upvalues.





<hr><h3><a name="lua_Hook"><code>lua_Hook</code></a></h3>
<pre>typedef void (*lua_Hook) (lua_State *L, lua_Debug *ar);</pre>

<p>
O tipo para fun&ccedil;&otilde;es de gancho de depura&ccedil;&atilde;o.


<p>
Sempre que um gancho &eacute; chamado, atribui-se ao campo <code>event</code> de seu argumento <code>ar</code>
o evento espec&iacute;fico que disparou o gancho.
Lua identifica estes eventos com a seguintes constantes:
<a name="pdf-LUA_HOOKCALL"><code>LUA_HOOKCALL</code></a>, <a name="pdf-LUA_HOOKRET"><code>LUA_HOOKRET</code></a>,
<a name="pdf-LUA_HOOKTAILRET"><code>LUA_HOOKTAILRET</code></a>, <a name="pdf-LUA_HOOKLINE"><code>LUA_HOOKLINE</code></a>
e <a name="pdf-LUA_HOOKCOUNT"><code>LUA_HOOKCOUNT</code></a>.
Al&eacute;m disso, para eventos de linha, o campo <code>currentline</code> tamb&eacute;m &eacute; atribu&iacute;do.
Para obter o valor de qualquer campo em <code>ar</code>,
o gancho deve chamar <a href="#lua_getinfo"><code>lua_getinfo</code></a>.
Para eventos de retorno, <code>event</code> pode ser <code>LUA_HOOKRET</code>,
o valor normal, ou <code>LUA_HOOKTAILRET</code>.
No &uacute;ltimo caso, Lua est&aacute; simulando um retorno de
uma fun&ccedil;&atilde;o que fez uma recurs&atilde;o final;
neste caso, &eacute; in&uacute;til chamar <a href="#lua_getinfo"><code>lua_getinfo</code></a>.


<p>
Enquanto Lua est&aacute; executando um gancho, ela desabilita outras chamadas a ganchos.
Portanto, se um gancho chama Lua de volta para executar uma fun&ccedil;&atilde;o ou um trecho,
esta execu&ccedil;&atilde;o ocorre sem quaisquer chamadas a ganchos.





<hr><h3><a name="lua_sethook"><code>lua_sethook</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>int lua_sethook (lua_State *L, lua_Hook f, int mask, int count);</pre>

<p>
Estabelece a fun&ccedil;&atilde;o de gancho de depura&ccedil;&atilde;o.


<p>
O argumento <code>f</code> &eacute; uma fun&ccedil;&atilde;o de gancho.
<code>mask</code> especifica sobre quais eventos o gancho ser&aacute; chamado:
ele &eacute; formado por uma conjun&ccedil;&atilde;o bit-a-bit das constantes
<a name="pdf-LUA_MASKCALL"><code>LUA_MASKCALL</code></a>,
<a name="pdf-LUA_MASKRET"><code>LUA_MASKRET</code></a>,
<a name="pdf-LUA_MASKLINE"><code>LUA_MASKLINE</code></a>
e <a name="pdf-LUA_MASKCOUNT"><code>LUA_MASKCOUNT</code></a>.
O argumento <code>count</code> somente possui significado quando a m&aacute;scara
inclui <code>LUA_MASKCOUNT</code>.
Para cada evento, o gancho &eacute; chamado como explicado abaixo:

<ul>

<li><b>O gancho de chamada (CALL):</b> &eacute; chamado quando o interpretador chama uma fun&ccedil;&atilde;o.
O gancho &eacute; chamado logo ap&oacute;s Lua entrar na nova fun&ccedil;&atilde;o,
antes da fun&ccedil;&atilde;o receber seus argumentos.
</li>

<li><b>O gancho de retorno (RET):</b> &eacute; chamado quando o interpretador retorna de uma fun&ccedil;&atilde;o.
O gancho &eacute; chamado logo ap&oacute;s Lua sair da fun&ccedil;&atilde;o.
Voc&ecirc; n&atilde;o tem acesso aos valores a serem retornados pela fun&ccedil;&atilde;o.
</li>

<li><b>O gancho de linha (LINE):</b> &eacute; chamado quando o interpretador est&aacute; para
iniciar a execu&ccedil;&atilde;o de uma nova linha de c&oacute;digo
ou quando ele volta atr&aacute;s no c&oacute;digo (mesmo que para a mesma linha).
(Este evento somente acontece quando Lua est&aacute; executando uma fun&ccedil;&atilde;o Lua.)
</li>

<li><b>O gancho de contagem (COUNT):</b> &eacute; chamado ap&oacute;s o interpretador executar cada uma das
instru&ccedil;&otilde;es <code>count</code>.
(Este evento somente ocorre quando Lua est&aacute; executando uma fun&ccedil;&atilde;o Lua.)
</li>

</ul>

<p>
Um gancho &eacute; desabilitado atribuindo-se zero a <code>mask</code>.





<hr><h3><a name="lua_setlocal"><code>lua_setlocal</code></a></h3><p>
<span class="apii">[-(0|1), +0, <em>-</em>]</span>
<pre>const char *lua_setlocal (lua_State *L, lua_Debug *ar, int n);</pre>

<p>
Estabelece o valor de uma vari&aacute;vel local de um registro de ativa&ccedil;&atilde;o fornecido.
Os par&acirc;metros <code>ar</code> e <code>n</code> s&atilde;o como em <a href="#lua_getlocal"><code>lua_getlocal</code></a>
(ver <a href="#lua_getlocal"><code>lua_getlocal</code></a>).
<a href="#lua_setlocal"><code>lua_setlocal</code></a> atribui o valor no topo da pilha
&agrave; vari&aacute;vel e retorna o nome dela.
A fun&ccedil;&atilde;o tamb&eacute;m desempilha o valor da pilha.


<p>
Retorna <code>NULL</code> (e n&atilde;o desempilha nada)
quando o &iacute;ndice &eacute; maior do que
o n&uacute;mero de vari&aacute;veis locais ativas.





<hr><h3><a name="lua_setupvalue"><code>lua_setupvalue</code></a></h3><p>
<span class="apii">[-(0|1), +0, <em>-</em>]</span>
<pre>const char *lua_setupvalue (lua_State *L, int funcindex, int n);</pre>

<p>
Estabelece o valor de um upvalue de um fecho.
A fun&ccedil;&atilde;o atribui o valor no topo da pilha
ao upvalue e retorna o nome dele.
Ela tamb&eacute;m desempilha o valor da pilha.
Os par&acirc;metros <code>funcindex</code> e <code>n</code> s&atilde;o como na fun&ccedil;&atilde;o <a href="#lua_getupvalue"><code>lua_getupvalue</code></a>
(ver <a href="#lua_getupvalue"><code>lua_getupvalue</code></a>).


<p>
Retorna <code>NULL</code> (e n&atilde;o desempilha nada)
quando o &iacute;ndice &eacute; maior do que o n&uacute;mero de upvalues.







<h1>4 - <a name="4">A Biblioteca Auxiliar</a></h1>

<p>

A <em>biblioteca auxiliar</em> fornece v&aacute;rias fun&ccedil;&otilde;es convenientes
para a interface de C com Lua.
Enquanto a API b&aacute;sica fornece as fun&ccedil;&otilde;es primitivas para todas as
intera&ccedil;&otilde;es entre C e Lua,
a biblioteca auxiliar fornece fun&ccedil;&otilde;es de mais alto n&iacute;vel para algumas
tarefas comuns.


<p>
Todas as fun&ccedil;&otilde;es da biblioteca auxiliar
s&atilde;o definidas no arquivo de cabe&ccedil;alho <code>lauxlib.h</code> e
possuem um prefixo <code>luaL_</code>.


<p>
Todas as fun&ccedil;&otilde;es na biblioteca auxiliar s&atilde;o constru&iacute;das
sobre a API b&aacute;sica
e portanto elas n&atilde;o oferecem nada que n&atilde;o possa ser feito com a API b&aacute;sica.


<p>
V&aacute;rias fun&ccedil;&otilde;es na biblioteca auxiliar s&atilde;o usadas para
verificar argumentos de fun&ccedil;&otilde;es&nbsp;C.
O nome delas sempre &eacute; <code>luaL_check*</code> ou <code>luaL_opt*</code>.
Todas essas fun&ccedil;&otilde;es disparam um erro se a verifica&ccedil;&atilde;o n&atilde;o &eacute; satisfeita.
Visto que a mensagem de erro &eacute; formatada para argumentos
(e.g., "<code>bad argument #1</code>"),
voc&ecirc; n&atilde;o deve usar estas fun&ccedil;&otilde;es para outros valores da pilha.



<h2>4.1 - <a name="4.1">Fun&ccedil;&otilde;es e Tipos</a></h2>

<p>
Listamos aqui todas as fun&ccedil;&otilde;es e tipos da biblioteca auxiliar
em ordem alfab&eacute;tica.



<hr><h3><a name="luaL_addchar"><code>luaL_addchar</code></a></h3><p>
<span class="apii">[-0, +0, <em>m</em>]</span>
<pre>void luaL_addchar (luaL_Buffer *B, char c);</pre>

<p>
Adiciona o caractere <code>c</code> ao buffer <code>B</code>
(ver <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>).





<hr><h3><a name="luaL_addlstring"><code>luaL_addlstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>m</em>]</span>
<pre>void luaL_addlstring (luaL_Buffer *B, const char *s, size_t l);</pre>

<p>
Adiciona a cadeia de caracteres apontada por <code>s</code> com comprimento <code>l</code> ao
buffer <code>B</code>
(ver <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>).
A cadeia pode conter zeros dentro dela.





<hr><h3><a name="luaL_addsize"><code>luaL_addsize</code></a></h3><p>
<span class="apii">[-0, +0, <em>m</em>]</span>
<pre>void luaL_addsize (luaL_Buffer *B, size_t n);</pre>

<p>
Adiciona ao buffer <code>B</code> (ver <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>)
uma cadeia de comprimento <code>n</code> copiada anteriormente para
a &aacute;rea de buffer (ver <a href="#luaL_prepbuffer"><code>luaL_prepbuffer</code></a>).





<hr><h3><a name="luaL_addstring"><code>luaL_addstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>m</em>]</span>
<pre>void luaL_addstring (luaL_Buffer *B, const char *s);</pre>

<p>
Adiciona a cadeia terminada por 0 apontada por <code>s</code>
ao buffer <code>B</code>
(ver <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>).
A cadeia n&atilde;o pode conter zeros dentro dela.





<hr><h3><a name="luaL_addvalue"><code>luaL_addvalue</code></a></h3><p>
<span class="apii">[-1, +0, <em>m</em>]</span>
<pre>void luaL_addvalue (luaL_Buffer *B);</pre>

<p>
Adiciona o valor no topo da pilha
ao buffer <code>B</code>
(ver <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>).
Desempilha o valor.


<p>
Esta &eacute; a &uacute;nica fun&ccedil;&atilde;o sobre buffers de cadeias que pode (e deve)
ser chamada com um elemento extra na pilha,
que &eacute; o valor a ser adicionado ao buffer.





<hr><h3><a name="luaL_argcheck"><code>luaL_argcheck</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>void luaL_argcheck (lua_State *L,
                    int cond,
                    int narg,
                    const char *extramsg);</pre>

<p>
Verifica se <code>cond</code> &eacute; verdadeira.
Se n&atilde;o, dispara um erro com a seguinte mensagem,
onde <code>func</code> &eacute; recuperada a partir da pilha de chamada:

<pre>
     bad argument #&lt;narg&gt; to &lt;func&gt; (&lt;extramsg&gt;)
</pre>




<hr><h3><a name="luaL_argerror"><code>luaL_argerror</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>int luaL_argerror (lua_State *L, int narg, const char *extramsg);</pre>

<p>
Dispara um erro com a seguinte mensagem,
onde <code>func</code> &eacute; recuperada a partir da pilha de chamada:

<pre>
     bad argument #&lt;narg&gt; to &lt;func&gt; (&lt;extramsg&gt;)
</pre>

<p>
Esta fun&ccedil;&atilde;o nunca retorna,
mas &eacute; idiom&aacute;tico us&aacute;-la em fun&ccedil;&otilde;es&nbsp;C
como <code>return luaL_argerror(<em>args</em>)</code>.





<hr><h3><a name="luaL_Buffer"><code>luaL_Buffer</code></a></h3>
<pre>typedef struct luaL_Buffer luaL_Buffer;</pre>

<p>
O tipo para um <em>buffer de cadeia de caracteres</em>.


<p>
Um buffer de cadeia permite c&oacute;digo&nbsp;C construir cadeias Lua pouco a pouco.
O seu padr&atilde;o de uso &eacute; como a seguir:

<ul>

<li>Primeiro voc&ecirc; declara uma vari&aacute;vel <code>b</code> do tipo <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>.</li>

<li>Em seguida voc&ecirc; a inicializa com uma chamada <code>luaL_buffinit(L, &amp;b)</code>.</li>

<li>
Depois voc&ecirc; adiciona peda&ccedil;os da cadeia ao buffer chamando qualquer uma
das fun&ccedil;&otilde;es <code>luaL_add*</code>.
</li>

<li>
Voc&ecirc; termina fazendo uma chamada <code>luaL_pushresult(&amp;b)</code>.
Esta chamada deixa a cadeia final no topo da pilha.
</li>

</ul>

<p>
Durante essa opera&ccedil;&atilde;o normal,
um buffer de cadeia usa um n&uacute;mero vari&aacute;vel de posi&ccedil;&otilde;es da pilha.
Ent&atilde;o, quando voc&ecirc; est&aacute; usando um buffer, voc&ecirc; n&atilde;o deve assumir que sabe onde
o topo da pilha est&aacute;.
Voc&ecirc; pode usar a pilha entre chamadas sucessivas &agrave;s opera&ccedil;&otilde;es de buffer
desde que este uso seja balanceado;
isto &eacute;,
quando voc&ecirc; chama uma opera&ccedil;&atilde;o de buffer,
a pilha est&aacute; no mesmo n&iacute;vel
em que ela estava imediatamente ap&oacute;s a opera&ccedil;&atilde;o de buffer anterior.
(A &uacute;nica exce&ccedil;&atilde;o a esta regra &eacute; <a href="#luaL_addvalue"><code>luaL_addvalue</code></a>.)
Ap&oacute;s chamar <a href="#luaL_pushresult"><code>luaL_pushresult</code></a> a pilha est&aacute; de volta ao seu
n&iacute;vel quando o buffer foi inicializado,
mais a cadeia final no seu topo.





<hr><h3><a name="luaL_buffinit"><code>luaL_buffinit</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
<pre>void luaL_buffinit (lua_State *L, luaL_Buffer *B);</pre>

<p>
Inicializa um buffer <code>B</code>.
Esta fun&ccedil;&atilde;o n&atilde;o aloca qualquer espa&ccedil;o;
o buffer deve ser declarado como uma vari&aacute;vel
(ver <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>).





<hr><h3><a name="luaL_callmeta"><code>luaL_callmeta</code></a></h3><p>
<span class="apii">[-0, +(0|1), <em>e</em>]</span>
<pre>int luaL_callmeta (lua_State *L, int obj, const char *e);</pre>

<p>
Chama um metam&eacute;todo.


<p>
Se o objeto no &iacute;ndice <code>obj</code> possui uma metatabela e esta
metatabela possui um campo <code>e</code>,
esta fun&ccedil;&atilde;o chama esse campo e passa o objeto como seu &uacute;nico argumento.
Neste caso esta fun&ccedil;&atilde;o retorna 1 e coloca na pilha
o valor retornado pela chamada.
Se n&atilde;o h&aacute; metatabela ou metam&eacute;todo,
esta fun&ccedil;&atilde;o retorna 0 (sem empilhar qualquer valor na pilha).





<hr><h3><a name="luaL_checkany"><code>luaL_checkany</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>void luaL_checkany (lua_State *L, int narg);</pre>

<p>
Verifica se a fun&ccedil;&atilde;o tem um argumento
de qualquer tipo (incluindo <b>nil</b>) na posi&ccedil;&atilde;o <code>narg</code>.





<hr><h3><a name="luaL_checkint"><code>luaL_checkint</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>int luaL_checkint (lua_State *L, int narg);</pre>

<p>
Verifica se o argumento <code>narg</code> da fun&ccedil;&atilde;o &eacute; um n&uacute;mero
e retorna este n&uacute;mero convertido para um <code>int</code>.





<hr><h3><a name="luaL_checkinteger"><code>luaL_checkinteger</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>lua_Integer luaL_checkinteger (lua_State *L, int narg);</pre>

<p>
Verifica se o argumento <code>narg</code> da fun&ccedil;&atilde;o &eacute; um n&uacute;mero
e retorna este n&uacute;mero convertido para um <a href="#lua_Integer"><code>lua_Integer</code></a>.





<hr><h3><a name="luaL_checklong"><code>luaL_checklong</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>long luaL_checklong (lua_State *L, int narg);</pre>

<p>
Verifica se o argumento <code>narg</code> da fun&ccedil;&atilde;o &eacute; um n&uacute;mero
e retorna este n&uacute;mero convertido para um <code>long</code>.





<hr><h3><a name="luaL_checklstring"><code>luaL_checklstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>const char *luaL_checklstring (lua_State *L, int narg, size_t *l);</pre>

<p>
Verifica se o argumento <code>narg</code> da fun&ccedil;&atilde;o &eacute; uma cadeia
e retorna esta cadeia;
se <code>l</code> n&atilde;o &eacute; <code>NULL</code> preenche <code>*l</code>
com o comprimento da cadeia.


<p>
Esta fun&ccedil;&atilde;o usa <a href="#lua_tolstring"><code>lua_tolstring</code></a> para obter seu resultado,
de modo que todas as convers&otilde;es e advert&ecirc;ncias relacionadas
a <a href="#lua_tolstring"><code>lua_tolstring</code></a> se aplicam aqui tamb&eacute;m.




<hr><h3><a name="luaL_checknumber"><code>luaL_checknumber</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>lua_Number luaL_checknumber (lua_State *L, int narg);</pre>

<p>
Verifica se o argumento <code>narg</code> da fun&ccedil;&atilde;o &eacute; um n&uacute;mero
e retorna este n&uacute;mero.





<hr><h3><a name="luaL_checkoption"><code>luaL_checkoption</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>int luaL_checkoption (lua_State *L,
                      int narg,
                      const char *def,
                      const char *const lst[]);</pre>

<p>
Verifica se o argumento <code>narg</code> da fun&ccedil;&atilde;o &eacute; uma cadeia e
procura por esta cadeia no array <code>lst</code>
(o qual deve ser terminado por NULL).
Retorna o &iacute;ndice no array onde a cadeia foi encontrada.
Dispara um erro se o argumento n&atilde;o &eacute; uma cadeia ou
se a cadeia n&atilde;o p&ocirc;de ser encontrada.


<p>
Se <code>def</code> n&atilde;o &eacute; <code>NULL</code>,
a fun&ccedil;&atilde;o usa <code>def</code> como um valor padr&atilde;o quando
n&atilde;o h&aacute; argumento <code>narg</code> ou se este argumento &eacute; <b>nil</b>.


<p>
Esta &eacute; uma fun&ccedil;&atilde;o &uacute;til para mapear cadeias para enumera&ccedil;&otilde;es&nbsp;de&nbsp;C.
(A conven&ccedil;&atilde;o usual em bibliotecas Lua &eacute;
usar cadeias ao inv&eacute;s de n&uacute;meros para selecionar op&ccedil;&otilde;es.)





<hr><h3><a name="luaL_checkstack"><code>luaL_checkstack</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>void luaL_checkstack (lua_State *L, int sz, const char *msg);</pre>

<p>
Aumenta o tamanho da pilha para <code>top + sz</code> elementos,
disparando um erro se a pilha n&atilde;o pode ser aumentada para aquele tamanho.
<code>msg</code> &eacute; um texto adicional a ser colocado na mensagem de erro.





<hr><h3><a name="luaL_checkstring"><code>luaL_checkstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>const char *luaL_checkstring (lua_State *L, int narg);</pre>

<p>
Verifica se o argumento <code>narg</code> da fun&ccedil;&atilde;o &eacute; uma cadeia
e retorna esta cadeia.


<p>
Esta fun&ccedil;&atilde;o usa <a href="#lua_tolstring"><code>lua_tolstring</code></a> para obter seu resultado,
de modo que todas as convers&otilde;es e advert&ecirc;ncias relacionadas
a <a href="#lua_tolstring"><code>lua_tolstring</code></a> se aplicam aqui tamb&eacute;m.




<hr><h3><a name="luaL_checktype"><code>luaL_checktype</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>void luaL_checktype (lua_State *L, int narg, int t);</pre>

<p>
Verifica se o argumento <code>narg</code> da fun&ccedil;&atilde;o tem tipo <code>t</code>.
Veja <a href="#lua_type"><code>lua_type</code></a> para a codifica&ccedil;&atilde;o de tipos para <code>t</code>.





<hr><h3><a name="luaL_checkudata"><code>luaL_checkudata</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>void *luaL_checkudata (lua_State *L, int narg, const char *tname);</pre>

<p>
Verifica se o argumento <code>narg</code> da fun&ccedil;&atilde;o &eacute; um objeto userdata
do tipo <code>tname</code> (ver <a href="#luaL_newmetatable"><code>luaL_newmetatable</code></a>).





<hr><h3><a name="luaL_dofile"><code>luaL_dofile</code></a></h3><p>
<span class="apii">[-0, +?, <em>m</em>]</span>
<pre>int luaL_dofile (lua_State *L, const char *filename);</pre>

<p>
Carrega e executa o arquivo fornecido.
&Eacute; definida como a seguinte macro:

<pre>
     (luaL_loadfile(L, filename) || lua_pcall(L, 0, LUA_MULTRET, 0))
</pre><p>
A fun&ccedil;&atilde;o retorna 0 se n&atilde;o h&aacute; erros
ou 1 em caso de erros.





<hr><h3><a name="luaL_dostring"><code>luaL_dostring</code></a></h3><p>
<span class="apii">[-0, +?, <em>m</em>]</span>
<pre>int luaL_dostring (lua_State *L, const char *str);</pre>

<p>
Carrega e executa a cadeia fornecida.
&Eacute; definida como a seguinte macro:

<pre>
     (luaL_loadstring(L, str) || lua_pcall(L, 0, LUA_MULTRET, 0))
</pre><p>
A fun&ccedil;&atilde;o retorna 0 se n&atilde;o h&aacute; erros
ou 1 em caso de erros.





<hr><h3><a name="luaL_error"><code>luaL_error</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>int luaL_error (lua_State *L, const char *fmt, ...);</pre>

<p>
Dispara um erro.
O formato da mensagem de erro &eacute; dado por <code>fmt</code>
mais quaisquer argumentos extras,
seguindo as mesmas regras de <a href="#lua_pushfstring"><code>lua_pushfstring</code></a>.
Tamb&eacute;m adiciona no in&iacute;cio da mensagem o nome do arquivo
e o n&uacute;mero da linha onde o erro ocorreu,
caso esta informa&ccedil;&atilde;o esteja dispon&iacute;vel.


<p>
Esta fun&ccedil;&atilde;o nunca retorna,
mas &eacute; idiom&aacute;tico us&aacute;-la em fun&ccedil;&otilde;es&nbsp;C
como <code>return luaL_error(<em>args</em>)</code>.





<hr><h3><a name="luaL_getmetafield"><code>luaL_getmetafield</code></a></h3><p>
<span class="apii">[-0, +(0|1), <em>m</em>]</span>
<pre>int luaL_getmetafield (lua_State *L, int obj, const char *e);</pre>

<p>
Coloca na pilha o campo <code>e</code> da metatabela
do objeto no &iacute;ndice <code>obj</code>.
Se o objeto n&atilde;o possui uma metatabela
ou se a metatabela n&atilde;o possui este campo,
retorna 0 e n&atilde;o empilha nada.





<hr><h3><a name="luaL_getmetatable"><code>luaL_getmetatable</code></a></h3><p>
<span class="apii">[-0, +1, <em>-</em>]</span>
<pre>void luaL_getmetatable (lua_State *L, const char *tname);</pre>

<p>
Coloca na pilha a metatabela associada com o nome <code>tname</code>
no registro (ver <a href="#luaL_newmetatable"><code>luaL_newmetatable</code></a>).





<hr><h3><a name="luaL_gsub"><code>luaL_gsub</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>const char *luaL_gsub (lua_State *L,
                       const char *s,
                       const char *p,
                       const char *r);</pre>

<p>
Cria uma c&oacute;pia da cadeia <code>s</code> substituindo
qualquer ocorr&ecirc;ncia da cadeia <code>p</code>
pela cadeia <code>r</code>.
Coloca a cadeia resultante na pilha e a retorna.





<hr><h3><a name="luaL_loadbuffer"><code>luaL_loadbuffer</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>int luaL_loadbuffer (lua_State *L,
                     const char *buff,
                     size_t sz,
                     const char *name);</pre>

<p>
Carrega um buffer como um trecho de c&oacute;digo Lua.
Esta fun&ccedil;&atilde;o usa <a href="#lua_load"><code>lua_load</code></a> para carregar o trecho no
buffer apontado por <code>buff</code> com tamanho <code>sz</code>.


<p>
Esta fun&ccedil;&atilde;o retorna os mesmos resultados de <a href="#lua_load"><code>lua_load</code></a>.
<code>name</code> &eacute; o nome do trecho,
usado para informa&ccedil;&otilde;es de depura&ccedil;&atilde;o e mensagens de erro.





<hr><h3><a name="luaL_loadfile"><code>luaL_loadfile</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>int luaL_loadfile (lua_State *L, const char *filename);</pre>

<p>
Carrega um arquivo como um trecho de c&oacute;digo Lua.
Esta fun&ccedil;&atilde;o usa <a href="#lua_load"><code>lua_load</code></a> para carregar o trecho no arquivo
chamado <code>filename</code>.
Se <code>filename</code> &eacute; <code>NULL</code>,
ent&atilde;o ela carrega a partir da entrada padr&atilde;o.
A primeira linha no arquivo &eacute; ignorada se ela come&ccedil;a com <code>#</code>.


<p>
Esta fun&ccedil;&atilde;o retorna os mesmos resultados de <a href="#lua_load"><code>lua_load</code></a>,
mas ela possui um c&oacute;digo de erro extra <a name="pdf-LUA_ERRFILE"><code>LUA_ERRFILE</code></a>
se ela n&atilde;o pode abrir/ler o arquivo.


<p>
Da mesma forma que <a href="#lua_load"><code>lua_load</code></a>, esta fun&ccedil;&atilde;o somente carrega o trecho;
ela n&atilde;o o executa.





<hr><h3><a name="luaL_loadstring"><code>luaL_loadstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>int luaL_loadstring (lua_State *L, const char *s);</pre>

<p>
Carrega uma cadeia como um trecho de c&oacute;digo Lua.
Esta fun&ccedil;&atilde;o usa <a href="#lua_load"><code>lua_load</code></a> para carregar o trecho na
cadeia (terminada por zero) <code>s</code>.


<p>
Esta fun&ccedil;&atilde;o retorna os mesmos resultados de <a href="#lua_load"><code>lua_load</code></a>.


<p>
Assim como <a href="#lua_load"><code>lua_load</code></a>, esta fun&ccedil;&atilde;o somente carrega o trecho;
ela n&atilde;o o executa.





<hr><h3><a name="luaL_newmetatable"><code>luaL_newmetatable</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>int luaL_newmetatable (lua_State *L, const char *tname);</pre>

<p>
Se o registro j&aacute; possui a chave <code>tname</code>,
retorna 0.
Caso contr&aacute;rio,
cria uma nova tabela para ser usada como uma metatabela para o objeto userdata,
adiciona esta tabela ao registro com chave <code>tname</code>
e retorna 1.


<p>
Em ambos os casos coloca na pilha o valor final associado
com <code>tname</code> no registro.





<hr><h3><a name="luaL_newstate"><code>luaL_newstate</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>lua_State *luaL_newstate (void);</pre>

<p>
Cria um novo estado Lua.
Chama <a href="#lua_newstate"><code>lua_newstate</code></a> com uma
fun&ccedil;&atilde;o de aloca&ccedil;&atilde;o baseada na fun&ccedil;&atilde;o padr&atilde;o&nbsp;de&nbsp;C <code>realloc</code>
e ent&atilde;o estabelece uma fun&ccedil;&atilde;o de p&acirc;nico (ver <a href="#lua_atpanic"><code>lua_atpanic</code></a>) que imprime
uma mensagem de erro para a sa&iacute;da de erro padr&atilde;o em caso de erros
fatais.


<p>
Retorna o novo estado
ou <code>NULL</code> se ocorreu um erro de aloca&ccedil;&atilde;o de mem&oacute;ria.





<hr><h3><a name="luaL_openlibs"><code>luaL_openlibs</code></a></h3><p>
<span class="apii">[-0, +0, <em>m</em>]</span>
<pre>void luaL_openlibs (lua_State *L);</pre>

<p>
Abre todas as bibliotecas padr&otilde;es no estado fornecido.





<hr><h3><a name="luaL_optint"><code>luaL_optint</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>int luaL_optint (lua_State *L, int narg, int d);</pre>

<p>
Se o argumento <code>narg</code> da fun&ccedil;&atilde;o &eacute; um n&uacute;mero,
retorna este n&uacute;mero convertido para um <code>int</code>.
Se este argumento est&aacute; ausente ou se ele &eacute; <b>nil</b>,
retorna <code>d</code>.
Caso contr&aacute;rio, dispara um erro.





<hr><h3><a name="luaL_optinteger"><code>luaL_optinteger</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>lua_Integer luaL_optinteger (lua_State *L,
                             int narg,
                             lua_Integer d);</pre>

<p>
Se o argumento <code>narg</code> da fun&ccedil;&atilde;o &eacute; um n&uacute;mero,
retorna este n&uacute;mero convertido para um <a href="#lua_Integer"><code>lua_Integer</code></a>.
Se este argumento est&aacute; ausente ou se ele &eacute; <b>nil</b>,
retorna <code>d</code>.
Caso contr&aacute;rio, dispara um erro.





<hr><h3><a name="luaL_optlong"><code>luaL_optlong</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>long luaL_optlong (lua_State *L, int narg, long d);</pre>

<p>
Se o argumento <code>narg</code> da fun&ccedil;&atilde;o &eacute; um n&uacute;mero,
retorna este n&uacute;mero convertido para um <code>long</code>.
Se este argumento est&aacute; ausente ou se ele &eacute; <b>nil</b>,
retorna <code>d</code>.
Caso contr&aacute;rio, dispara um erro.





<hr><h3><a name="luaL_optlstring"><code>luaL_optlstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>const char *luaL_optlstring (lua_State *L,
                             int narg,
                             const char *d,
                             size_t *l);</pre>

<p>
Se o argumento <code>narg</code> da fun&ccedil;&atilde;o &eacute; uma cadeia,
retorna esta cadeia.
Se este argumento est&aacute; ausente ou se ele <b>nil</b>,
retorna <code>d</code>.
Caso contr&aacute;rio, dispara um erro.


<p>
Se <code>l</code> n&atilde;o &eacute; <code>NULL</code>,
preenche a posi&ccedil;&atilde;o <code>*l</code> com o comprimento do resultado.





<hr><h3><a name="luaL_optnumber"><code>luaL_optnumber</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>lua_Number luaL_optnumber (lua_State *L, int narg, lua_Number d);</pre>

<p>
Se o argumento <code>narg</code> da fun&ccedil;&atilde;o &eacute; um n&uacute;mero,
retorna este n&uacute;mero.
Se este argumento est&aacute; ausente ou se ele &eacute; <b>nil</b>,
retorna <code>d</code>.
Caso contr&aacute;rio, dispara um erro.





<hr><h3><a name="luaL_optstring"><code>luaL_optstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>const char *luaL_optstring (lua_State *L,
                            int narg,
                            const char *d);</pre>

<p>
Se o argumento <code>narg</code> da fun&ccedil;&atilde;o &eacute; uma cadeia,
retorna esta cadeia.
Se este argumento est&aacute; ausente ou se ele &eacute; <b>nil</b>,
retorna <code>d</code>.
Caso contr&aacute;rio, dispara um erro.





<hr><h3><a name="luaL_prepbuffer"><code>luaL_prepbuffer</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>char *luaL_prepbuffer (luaL_Buffer *B);</pre>

<p>
Retorna um endere&ccedil;o para um espa&ccedil;o de tamanho <a name="pdf-LUAL_BUFFERSIZE"><code>LUAL_BUFFERSIZE</code></a>
onde voc&ecirc; pode copiar uma cadeia para ser adicionada ao buffer <code>B</code>
(ver <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>).
Ap&oacute;s copiar a cadeia para este espa&ccedil;o voc&ecirc; deve chamar
<a href="#luaL_addsize"><code>luaL_addsize</code></a> com o tamanho da cadeia para adicion&aacute;-la realmente
ao buffer.





<hr><h3><a name="luaL_pushresult"><code>luaL_pushresult</code></a></h3><p>
<span class="apii">[-?, +1, <em>m</em>]</span>
<pre>void luaL_pushresult (luaL_Buffer *B);</pre>

<p>
Finaliza o uso do buffer <code>B</code> deixando a cadeia final no
topo da pilha.





<hr><h3><a name="luaL_ref"><code>luaL_ref</code></a></h3><p>
<span class="apii">[-1, +0, <em>m</em>]</span>
<pre>int luaL_ref (lua_State *L, int t);</pre>

<p>
Cria e retorna uma <em>refer&ecirc;ncia</em>,
na tabela no &iacute;ndice <code>t</code>,
para o objeto no topo da pilha (e desempilha o objeto).


<p>
Uma refer&ecirc;ncia &eacute; uma chave inteira &uacute;nica.
Desde que voc&ecirc; n&atilde;o adicione manualmente chaves inteiras na tabela <code>t</code>,
<a href="#luaL_ref"><code>luaL_ref</code></a> garante a unicidade da chave que ela retorna.
Voc&ecirc; pode recuperar um objeto referenciado pelo refer&ecirc;ncia <code>r</code>
chamando <code>lua_rawgeti(L, t, r)</code>.
A fun&ccedil;&atilde;o <a href="#luaL_unref"><code>luaL_unref</code></a> libera uma refer&ecirc;ncia e o objeto associado a ela.


<p>
Se o objeto no topo da pilha &eacute; <b>nil</b>,
<a href="#luaL_ref"><code>luaL_ref</code></a> retorna a constante <a name="pdf-LUA_REFNIL"><code>LUA_REFNIL</code></a>.
A constante <a name="pdf-LUA_NOREF"><code>LUA_NOREF</code></a> &eacute; garantidamente diferente
de qualquer refer&ecirc;ncia retornada por <a href="#luaL_ref"><code>luaL_ref</code></a>.





<hr><h3><a name="luaL_Reg"><code>luaL_Reg</code></a></h3>
<pre>typedef struct luaL_Reg {
  const char *name;
  lua_CFunction func;
} luaL_Reg;</pre>

<p>
O tipo para arrays de fun&ccedil;&otilde;es a serem registrados por
<a href="#luaL_register"><code>luaL_register</code></a>.
<code>name</code> &eacute; o nome da fun&ccedil;&atilde;o e <code>func</code> &eacute; um ponteiro para
a fun&ccedil;&atilde;o.
Qualquer array de <a href="#luaL_Reg"><code>luaL_Reg</code></a> deve terminar com uma entrada sentinela
na qual tanto <code>name</code> como <code>func</code> s&atilde;o <code>NULL</code>.





<hr><h3><a name="luaL_register"><code>luaL_register</code></a></h3><p>
<span class="apii">[-(0|1), +1, <em>m</em>]</span>
<pre>void luaL_register (lua_State *L,
                    const char *libname,
                    const luaL_Reg *l);</pre>

<p>
Abre uma biblioteca.


<p>
Quando chamada com <code>libname</code> igual a <code>NULL</code>,
simplesmente registra todas as fun&ccedil;&otilde;es na lista <code>l</code>
(ver <a href="#luaL_Reg"><code>luaL_Reg</code></a>) na tabela no topo da pilha.


<p>
Quando chamada com um valor de <code>libname</code> diferente de <code>NULL</code>,
<code>luaL_register</code> cria uma nova tabela <code>t</code>,
estabelece ela como o valor da vari&aacute;vel global <code>libname</code>,
estabelece ela como o valor de <code>package.loaded[libname]</code>
e registra nela todas as fun&ccedil;&otilde;es na lista <code>l</code>.
Se existe uma tabela em <code>package.loaded[libname]</code> ou
na vari&aacute;vel <code>libname</code>,
a fun&ccedil;&atilde;o reusa esta tabela ao inv&eacute;s de criar uma nova.


<p>
Em qualquer caso a fun&ccedil;&atilde;o deixa a tabela
no topo da pilha.





<hr><h3><a name="luaL_typename"><code>luaL_typename</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>const char *luaL_typename (lua_State *L, int index);</pre>

<p>
Retorna o nome do tipo do valor no &iacute;ndice fornecido.





<hr><h3><a name="luaL_typerror"><code>luaL_typerror</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>int luaL_typerror (lua_State *L, int narg, const char *tname);</pre>

<p>
Gera um erro com uma mensagem como a seguinte:

<pre>
     <em>location</em>: bad argument <em>narg</em> to '<em>func</em>' (<em>tname</em> expected, got <em>rt</em>)
</pre><p>
onde <code><em>location</em></code> &eacute; produzida por <a href="#luaL_where"><code>luaL_where</code></a>,
<code><em>func</em></code> &eacute; o nome da fun&ccedil;&atilde;o corrente
e <code><em>rt</em></code> &eacute; o nome do tipo do argumento.





<hr><h3><a name="luaL_unref"><code>luaL_unref</code></a></h3><p>
<span class="apii">[-0, +0, <em>-</em>]</span>
<pre>void luaL_unref (lua_State *L, int t, int ref);</pre>

<p>
Libera a refer&ecirc;ncia <code>ref</code> da tabela no &iacute;ndice <code>t</code>
(ver <a href="#luaL_ref"><code>luaL_ref</code></a>).
A entrada &eacute; removida da tabela,
de modo que o objeto referenciado pode ser coletado.
A refer&ecirc;ncia <code>ref</code> tamb&eacute;m &eacute; liberada para ser usada novamente.


<p>
Se <code>ref</code> &eacute; <a href="#pdf-LUA_NOREF"><code>LUA_NOREF</code></a> ou <a href="#pdf-LUA_REFNIL"><code>LUA_REFNIL</code></a>,
<a href="#luaL_unref"><code>luaL_unref</code></a> n&atilde;o faz nada.





<hr><h3><a name="luaL_where"><code>luaL_where</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>void luaL_where (lua_State *L, int lvl);</pre>

<p>
Coloca na pilha uma cadeia identificando a posi&ccedil;&atilde;o atual
do controle no n&iacute;vel <code>lvl</code> na pilha de chamada.
Tipicamente esta cadeia possui o seguinte formato:

<pre>
     <em>chunkname</em>:<em>currentline</em>:
</pre><p>
N&iacute;vel&nbsp;0 &eacute; a fun&ccedil;&atilde;o executando correntemente,
n&iacute;vel&nbsp;1 &eacute; a fun&ccedil;&atilde;o que chamou a fun&ccedil;&atilde;o que est&aacute; executando atualmente,
etc.


<p>
Esta fun&ccedil;&atilde;o &eacute; usada para construir um prefixo para mensagens de erro.







<h1>5 - <a name="5">Bibliotecas Padr&atilde;o</a></h1>

<p>
As bibliotecas padr&atilde;o de Lua oferecem fun&ccedil;&otilde;es &uacute;teis
que s&atilde;o implementadas diretamente atrav&eacute;s da API&nbsp;C.
Algumas dessas fun&ccedil;&otilde;es oferecem servi&ccedil;os essenciais para a linguagem
(e.g., <a href="#pdf-type"><code>type</code></a> e <a href="#pdf-getmetatable"><code>getmetatable</code></a>);
outras oferecem acesso a servi&ccedil;os "externos" (e.g., E/S);
e outras poderiam ser implementadas em Lua mesmo,
mas s&atilde;o bastante &uacute;teis ou possuem requisitos de desemepenho cr&iacute;ticos que
merecem uma implementa&ccedil;&atilde;o em C (e.g., <a href="#pdf-table.sort"><code>table.sort</code></a>).


<p>
Todas as bibliotecas s&atilde;o implementadas atr&aacute;ves da API&nbsp;C oficial
e s&atilde;o fornecidas como m&oacute;dulos&nbsp;C separados.
Correntemente, Lua possui as seguintes bibliotecas padr&atilde;o:

<ul>

<li>biblioteca b&aacute;sica, que inclui a sub-biblioteca de co-rotinas;</li>

<li>biblioteca de pacotes;</li>

<li>manipula&ccedil;&atilde;o de cadeias de caracteres;</li>

<li>manipula&ccedil;&atilde;o de tabelas;</li>

<li>fun&ccedil;&otilde;es matem&aacute;ticas (sen, log, etc.);</li>

<li>entrada e sa&iacute;da;</li>

<li>facilidades do sistema operacional;</li>

<li>facilidades de depura&ccedil;&atilde;o.</li>

</ul><p>
Excetuando-se a biblioteca b&aacute;sica e a biblioteca de pacotes,
cada biblioteca prov&ecirc; todas as suas fun&ccedil;&otilde;es como campos de uma tabela global
ou como m&eacute;todos de seus objetos.


<p>
Para ter acesso a essas bibliotecas,
o programa hospedeiro&nbsp;C deve chamar a fun&ccedil;&atilde;o <a href="#luaL_openlibs"><code>luaL_openlibs</code></a>,
que abre todas as bibliotecas padr&atilde;o.
De modo alternativo,
&eacute; poss&iacute;vel abri-las individualmente chamando
<a name="pdf-luaopen_base"><code>luaopen_base</code></a> (para a biblioteca b&aacute;sica),
<a name="pdf-luaopen_package"><code>luaopen_package</code></a> (para a biblioteca de pacotes),
<a name="pdf-luaopen_string"><code>luaopen_string</code></a> (para a biblioteca de cadeias de caracteres),
<a name="pdf-luaopen_table"><code>luaopen_table</code></a> (para a biblioteca de tabelas),
<a name="pdf-luaopen_math"><code>luaopen_math</code></a> (para a biblioteca matem&aacute;tica),
<a name="pdf-luaopen_io"><code>luaopen_io</code></a> (para a biblioteca de E/S),
<a name="pdf-luaopen_os"><code>luaopen_os</code></a> (para a biblioteca do Sistema Operacional),
e <a name="pdf-luaopen_debug"><code>luaopen_debug</code></a> (para a biblioteca de depura&ccedil;&atilde;o).
Essas fun&ccedil;&otilde;es est&atilde;o declaradas em <a name="pdf-lualib.h"><code>lualib.h</code></a>
e n&atilde;o devem ser chamadas diretamente:
voc&ecirc; deve cham&aacute;-las como qualquer outra fun&ccedil;&atilde;o&nbsp;C de Lua,
e.g., usando <a href="#lua_call"><code>lua_call</code></a>.



<h2>5.1 - <a name="5.1">Fun&ccedil;&otilde;es B&aacute;sicas</a></h2>

<p>
A biblioteca de fun&ccedil;&otilde;es b&aacute;sicas oferece algumas fun&ccedil;&otilde;es essenciais a Lua.
Se voc&ecirc; n&atilde;o incluir esta biblioteca em sua aplica&ccedil;&atilde;o,
voc&ecirc; deve verificar cuidadosamente se necessita fornecer
implementa&ccedil;&otilde;es para algumas de suas facilidades.


<p>
<hr><h3><a name="pdf-assert"><code>assert (v [, message])</code></a></h3>
Produz um erro quando
o valor de seu argumento <code>v</code> &eacute; falso (i.e., <b>nil</b> ou <b>false</b>);
caso contr&aacute;rio, retorna todos os seus argumentos.
<code>message</code> &eacute; uma mensagem de erro;
quando ausente, a mensagem padr&atilde;o &eacute; "assertion failed!"




<p>
<hr><h3><a name="pdf-collectgarbage"><code>collectgarbage (opt [, arg])</code></a></h3>


<p>
Esta fun&ccedil;&atilde;o &eacute; uma interface gen&eacute;rica para o coletor de lixo.
Ela realiza diferentes fun&ccedil;&otilde;es de acordo com o seu primeiro argumento, <code>opt</code>:



<ul>

<li><b>"stop":</b>
p&aacute;ra o coletor de lixo.
</li>

<li><b>"restart":</b>
reinicia o coletor de lixo.
</li>

<li><b>"collect":</b>
realiza um ciclo de coleta de lixo completo.
</li>

<li><b>"count":</b>
retorna a mem&oacute;ria total que est&aacute; sendo usada por Lua (em Kbytes).
</li>

<li><b>"step":</b>
realiza um passo de coleta de lixo.
O "tamanho" do passo &eacute; controlado por <code>arg</code>
(valores maiores significam mais passos) de maneira n&atilde;o especificada.
Se voc&ecirc; quer controlar o tamanho do passo
voc&ecirc; deve ajustar de maneira experimental o valor de <code>arg</code>.
Retorna <b>true</b> se o passo terminou um ciclo de coleta de lixo.
</li>

<li><b>"setpause":</b>
estabelece <code>arg</code> como o novo valor para a <em>pausa</em> do
coletor (ver <a href="#2.10">&sect;2.10</a>).
Retorna o valor anterior para a <em>pausa</em>.
</li>

<li><b>"setstepmul":</b>
estabelece <code>arg</code> como o novo valor para o <em>multiplicador de passo</em> do
coletor (ver <a href="#2.10">&sect;2.10</a>).
Retorna o valor anterior para a <em>pausa</em>.
</li>

</ul>



<p>
<hr><h3><a name="pdf-dofile"><code>dofile (filename)</code></a></h3>
Abre o arquivo indicado e executa o seu conte&uacute;do como um trecho de c&oacute;digo Lua.
Quando chamada sem argumentos,
<code>dofile</code> executa o conte&uacute;do da entrada padr&atilde;o (<code>stdin</code>).
Retorna todos os valores retornados pelo trecho.
Em caso de erros, <code>dofile</code> propaga o erro
para o seu chamador (isto &eacute;, <code>dofile</code> n&atilde;o executa em modo protegido).



<p>
<hr><h3><a name="pdf-error"><code>error (message [, level])</code></a></h3>
Termina a &uacute;ltima fun&ccedil;&atilde;o protegida chamada
e retorna <code>message</code> como a mensagem de erro.
A fun&ccedil;&atilde;o <code>error</code> nunca retorna.


<p>
Geralmente, <code>error</code> adiciona alguma informa&ccedil;&atilde;o sobre a posi&ccedil;&atilde;o do erro
no in&iacute;cio da mensagem.
O argumento <code>level</code> especifica como obter a posi&ccedil;&atilde;o do erro.
Quando ele &eacute; igual&nbsp;a&nbsp;1 (o padr&atilde;o), a posi&ccedil;&atilde;o do erro &eacute; onde a
fun&ccedil;&atilde;o <code>error</code> foi chamada.
Quando ele&nbsp;&eacute;&nbsp;2, a posi&ccedil;&atilde;o do erro &eacute; onde a fun&ccedil;&atilde;o
que chamou <code>error</code> foi chamada; e assim por diante.
Passando um valor&nbsp;0 para <code>level</code> evita a adi&ccedil;&atilde;o de informa&ccedil;&atilde;o da posi&ccedil;&atilde;o do erro
&agrave; mensagem.



<p>
<hr><h3><a name="pdf-_G"><code>_G</code></a></h3>
Uma vari&aacute;vel global (n&atilde;o uma fun&ccedil;&atilde;o) que
armazena o ambiente global (isto &eacute;, <code>_G._G = _G</code>).
Lua por si s&oacute; n&atilde;o usa esta vari&aacute;vel;
uma modifica&ccedil;&atilde;o do seu valor n&atilde;o afeta qualquer ambiente
e vice-versa.
(Use <a href="#pdf-setfenv"><code>setfenv</code></a> para mudar ambientes.)



<p>
<hr><h3><a name="pdf-getfenv"><code>getfenv ([f])</code></a></h3>
Retorna o ambiente que est&aacute; sendo usado correntemente pela fun&ccedil;&atilde;o.
<code>f</code> pode ser uma fun&ccedil;&atilde;o Lua ou um n&uacute;mero
que especifica a fun&ccedil;&atilde;o naquele n&iacute;vel de pilha:
a fun&ccedil;&atilde;o que chamou <code>getfenv</code> possui n&iacute;vel&nbsp;1.
Se a fun&ccedil;&atilde;o fornecida n&atilde;o &eacute; uma fun&ccedil;&atilde;o Lua
ou se <code>f</code> &eacute; 0,
<code>getfenv</code> retorna o ambiente global.
O valor padr&atilde;o para <code>f</code> &eacute; 1.



<p>
<hr><h3><a name="pdf-getmetatable"><code>getmetatable (object)</code></a></h3>


<p>
Se <code>object</code> n&atilde;o possui uma metatabela, retorna <b>nil</b>.
Caso contr&aacute;rio,
se a metatabela do objeto possui um campo <code>"__metatable"</code>,
retorna o valor associado.
Caso contr&aacute;rio, retorna a metatabela do objeto fornecido.



<p>
<hr><h3><a name="pdf-ipairs"><code>ipairs (t)</code></a></h3>


<p>
Retorna tr&ecirc;s valores: uma fun&ccedil;&atilde;o iteradora, a tabela <code>t</code> e 0,
de modo que a constru&ccedil;&atilde;o

<pre>
     for i,v in ipairs(t) do <em>corpo</em> end
</pre><p>
ir&aacute; iterar sobre os pares (<code>1,t[1]</code>), (<code>2,t[2]</code>), &middot;&middot;&middot;,
at&eacute; a primeira chave inteira ausente da tabela.



<p>
<hr><h3><a name="pdf-load"><code>load (func [, chunkname])</code></a></h3>


<p>
Carrega um trecho usando a fun&ccedil;&atilde;o <code>func</code> para obter seus peda&ccedil;os.
Cada chamada a <code>func</code> deve retornar uma cadeia de caracteres que concatena
com resultados anteriores.
Quando <code>func</code> retorna uma cadeia vazia, <b>nil</b> ou quando n&atilde;o retorna nenhum valor, isso indica o fim do trecho.


<p>
Se n&atilde;o ocorrerem erros,
retorna o trecho compilado como uma fun&ccedil;&atilde;o;
caso contr&aacute;rio, retorna <b>nil</b> mais a mensagem de erro.
O ambiente da fun&ccedil;&atilde;o retornada &eacute; o ambiente global.


<p>
<code>chunkname</code> &eacute; usado como o nome do trecho para mensagens de erro
e informa&ccedil;&atilde;o de depura&ccedil;&atilde;o.
Quando ausente,
o valor padr&atilde;o &eacute; "<code>=(load)</code>".




<p>
<hr><h3><a name="pdf-loadfile"><code>loadfile ([filename])</code></a></h3>


<p>
Similar a <a href="#pdf-load"><code>load</code></a>,
mas obt&eacute;m o trecho do arquivo <code>filename</code>
ou da entrada padr&atilde;o,
se nenhum nome de arquivo &eacute; fornecido.




<p>
<hr><h3><a name="pdf-loadstring"><code>loadstring (string [, chunkname])</code></a></h3>


<p>
Similar a <a href="#pdf-load"><code>load</code></a>,
mas obt&eacute;m o trecho da cadeia fornecida.	


<p>
Para carregar e rodar uma dada cadeia, use a
express&atilde;o idiom&aacute;tica

<pre>
     assert(loadstring(s))()
</pre>

<p>
Quando ausente,
o valor padr&atilde;o para <code>chunkname</code> &eacute; a cadeia fornecida.




<p>
<hr><h3><a name="pdf-next"><code>next (table [, index])</code></a></h3>


<p>
Permite a um programa pecorrer todos os campos de uma tabela.
Seu primeiro argumento &eacute; uma tabela e seu segundo argumento
&eacute; um &iacute;ndice nesta tabela.
<code>next</code> retorna o pr&oacute;ximo &iacute;ndice da tabela
e seu valor associado.
Quando chamada com <b>nil</b> como seu segundo argumento,
<code>next</code> retorna um &iacute;ndice inicial
e seu valor associado.
Quando chamada com o &uacute;ltimo &iacute;ndice
ou com <b>nil</b> em uma tabela vazia,
<code>next</code> retorna <b>nil</b>.
Se o segundo argumento est&aacute; ausente, ent&atilde;o ele &eacute; interpretado como <b>nil</b>.
Em particular,
voc&ecirc; pode usar <code>next(t)</code> para verificar se a tabela est&aacute; vazia.


<p>
A ordem na qual os &iacute;ndices s&atilde;o enumerados n&atilde;o &eacute; especificada,
<em>at&eacute; mesmo para &iacute;ndices num&eacute;ricos</em>.
(Para percorrer uma tabela em ordem num&eacute;rica,
use o <b>for</b> num&eacute;rico ou a fun&ccedil;&atilde;o <a href="#pdf-ipairs"><code>ipairs</code></a>.).


<p>
O comportamento de <code>next</code> &eacute; <em>indefinido</em> se,
durante o percorrimento,
voc&ecirc; atribuir qualquer valor a um campo n&atilde;o existente na tabela.
Voc&ecirc; pode contudo modificar campos existentes.
Em particular, voc&ecirc; pode limpar campos existentes.




<p>
<hr><h3><a name="pdf-pairs"><code>pairs (t)</code></a></h3>


<p>
Retorna tr&ecirc;s valores: a fun&ccedil;&atilde;o <a href="#pdf-next"><code>next</code></a>, a tabela <code>t</code> e <b>nil</b>,
de modo que a constru&ccedil;&atilde;o

<pre>
     for k,v in pairs(t) do <em>corpo</em> end
</pre><p>
ir&aacute; iterar sobre todos os pares chave&ndash;valor da tabela <code>t</code>.


<p>
Veja a fun&ccedil;&atilde;o <a href="#pdf-next"><code>next</code></a> para os cuidados que se deve ter ao modificar
a tabela durante o seu percorrimento.




<p>
<hr><h3><a name="pdf-pcall"><code>pcall (f, arg1, &middot;&middot;&middot;)</code></a></h3>


<p>
Chama a fun&ccedil;&atilde;o <code>f</code> com
os argumentos fornecidos em <em>modo protegido</em>.
Isto significa que qualquer erro dentro&nbsp;de&nbsp;<code>f</code> n&atilde;o &eacute; propagado;
ao inv&eacute;s disso, <code>pcall</code> captura o erro
e retorna um c&oacute;digo indicando o status.
Seu primeiro resultado &eacute; o c&oacute;digo de status (um booleano),
que &eacute; verdadeiro se a chamada aconteceu sem erros.
Neste caso, <code>pcall</code> tamb&eacute;m retorna todos os resultados da chamada,
depois deste primeiro resultado.
No caso de acontecer um erro, <code>pcall</code> retorna <b>false</b> mais a mensagem de erro.




<p>
<hr><h3><a name="pdf-print"><code>print (&middot;&middot;&middot;)</code></a></h3>
Recebe qualquer n&uacute;mero de argumentos
e imprime os seus valores para <code>stdout</code>,
usando a fun&ccedil;&atilde;o <a href="#pdf-tostring"><code>tostring</code></a> para convert&ecirc;-los para cadeias de caracteres.
<code>print</code> n&atilde;o &eacute; projetada para sa&iacute;da formatada,
mas somente como uma maneira r&aacute;pida de mostrar um valor,
tipicamente para depura&ccedil;&atilde;o.
Para sa&iacute;da formatada, use <a href="#pdf-string.format"><code>string.format</code></a>.




<p>
<hr><h3><a name="pdf-rawequal"><code>rawequal (v1, v2)</code></a></h3>
Verifica se <code>v1</code> &eacute; igual a <code>v2</code>,
sem invocar nenhum metam&eacute;todo.
Retorna um booleano.




<p>
<hr><h3><a name="pdf-rawget"><code>rawget (table, index)</code></a></h3>
Obt&eacute;m o valor real de <code>table[index]</code>,
sem invocar nenhum metam&eacute;todo.
<code>table</code> deve ser uma tabela;
<code>index</code> pode ser qualquer valor.




<p>
<hr><h3><a name="pdf-rawset"><code>rawset (table, index, value)</code></a></h3>
Atribui <code>value</code> como o valor real de <code>table[index]</code>,
sem invocar nenhum metam&eacute;todo.
<code>table</code> deve ser uma tabela,
<code>index</code> pode ser qualquer valor diferente de <b>nil</b>
e <code>value</code> pode ser qualquer valor Lua.


<p>
Essa fun&ccedil;&atilde;o retorna <code>table</code>.




<p>
<hr><h3><a name="pdf-select"><code>select (index, &middot;&middot;&middot;)</code></a></h3>


<p>
Se <code>index</code> &eacute; um n&uacute;mero,
retorna todos os argumentos ap&oacute;s o argumento n&uacute;mero <code>index</code>.
Caso contr&aacute;rio, <code>index</code> deve ser a cadeia <code>"#"</code>
e <code>select</code> retorna o n&uacute;mero total de argumentos extras recebidos.




<p>
<hr><h3><a name="pdf-setfenv"><code>setfenv (f, table)</code></a></h3>


<p>
Estabelece o ambiente a ser usado pela fun&ccedil;&atilde;o fornecida.
<code>f</code> pode ser uma fun&ccedil;&atilde;o Lua ou um n&uacute;mero
que especifica a fun&ccedil;&atilde;o naquele n&iacute;vel de pilha:
a fun&ccedil;&atilde;o chamando <code>setfenv</code> possui n&iacute;vel&nbsp;1.
<code>setfenv</code> retorna a fun&ccedil;&atilde;o fornecida.


<p>
Como um caso especial, quando <code>f</code> &eacute; 0 <code>setfenv</code> muda
o ambiente do fluxo de execu&ccedil;&atilde;o corrente.
Neste caso, <code>setfenv</code> n&atilde;o retorna nenhum valor.




<p>
<hr><h3><a name="pdf-setmetatable"><code>setmetatable (table, metatable)</code></a></h3>


<p>
Estabelece a metatabela para a tabela fornecida.
(Voc&ecirc; n&atilde;o pode mudar a metatabela de outros tipos a partir de Lua, somente a partir de&nbsp;C.)
Se <code>metatable</code> &eacute; <b>nil</b>,
remove a metatabela da tabela fornecida.
Se a metatabela original tem um campo <code>"__metatable"</code>,
dispara um erro.


<p>
Essa fun&ccedil;&atilde;o retorna <code>table</code>.




<p>
<hr><h3><a name="pdf-tonumber"><code>tonumber (e [, base])</code></a></h3>
Tenta converter seu argumento para um n&uacute;mero.
Se o argumento j&aacute; &eacute; um n&uacute;mero ou uma cadeia de caracteres que pode ser convertida
para um n&uacute;mero, ent&atilde;o <code>tonumber</code> retorna este n&uacute;mero;
caso contr&aacute;rio, retorna <b>nil</b>.


<p>
Um argumento opcional especifica a base para interpretar o numeral.
A base pode ser qualquer inteiro entre 2 e 36, inclusive.
Em bases acima&nbsp;de&nbsp;10, a letra '<code>A</code>' (mai&uacute;scula ou min&uacute;scula)
representa&nbsp;10, '<code>B</code>' representa&nbsp;11 e assim por diante,
com '<code>Z</code>' representando 35.
Na base 10 (o padr&atilde;o), o n&uacute;mero pode ter uma parte decimal,
bem como uma parte expoente opcional (ver <a href="#2.1">&sect;2.1</a>).
Em outras bases, somente inteiros sem sinal s&atilde;o aceitos.




<p>
<hr><h3><a name="pdf-tostring"><code>tostring (e)</code></a></h3>
Recebe um argumento de qualquer tipo
e o converte para uma cadeia de caracteres em um formato razo&aacute;vel.
Para um controle completo de como n&uacute;meros s&atilde;o convertidos,
use <a href="#pdf-string.format"><code>string.format</code></a>.


<p>
Se a metatabela de <code>e</code> possui um campo <code>"__tostring"</code>,
ent&atilde;o <code>tostring</code> chama o valor correspondente
com <code>e</code> como argumento
e usa o resultado da chamada como o seu resultado.




<p>
<hr><h3><a name="pdf-type"><code>type (v)</code></a></h3>
Retorna o tipo de seu &uacute;nico argumento, codificado como uma cadeia de caracteres.
Os resultados poss&iacute;veis desta fun&ccedil;&atilde;o s&atilde;o	
"<code>nil</code>" (uma cadeia de caracteres, n&atilde;o o valor <b>nil</b>),
"<code>number</code>",
"<code>string</code>",
"<code>boolean</code>",
"<code>table</code>",
"<code>function</code>",
"<code>thread</code>"
e "<code>userdata</code>".




<p>
<hr><h3><a name="pdf-unpack"><code>unpack (list [, i [, j]])</code></a></h3>
Retorna os elementos da tabela fornecida.
Esta fun&ccedil;&atilde;o &eacute; equivalente a

<pre>
     return list[i], list[i+1], &middot;&middot;&middot;, list[j]
</pre><p>
exceto que o c&oacute;digo acima pode ser escrito somente para um n&uacute;mero fixo
de elementos.
Por padr&atilde;o, <code>i</code> &eacute;&nbsp;1 e <code>j</code> &eacute; o comprimento da lista,
como definido pelo operador de comprimento (ver <a href="#2.5.5">&sect;2.5.5</a>).




<p>
<hr><h3><a name="pdf-_VERSION"><code>_VERSION</code></a></h3>
Uma vari&aacute;vel global (n&atilde;o uma fun&ccedil;&atilde;o)
que armazena uma cadeia contendo a vers&atilde;o corrente do interpretador.
O conte&uacute;do corrente desta vari&aacute;vel &eacute; "<code>Lua 5.1</code>".




<p>
<hr><h3><a name="pdf-xpcall"><code>xpcall (f, err)</code></a></h3>


<p>
Esta fun&ccedil;&atilde;o &eacute; similar a <a href="#pdf-pcall"><code>pcall</code></a>,
exceto que voc&ecirc; pode estabelecer um novo tratador de erros.


<p>
<code>xpcall</code> chama a fun&ccedil;&atilde;o <code>f</code> em modo protegido,
usando <code>err</code> como um tratador de erros.
Qualquer erro dentro de <code>f</code> n&atilde;o &eacute; propagado;
ao inv&eacute;s disso, <code>xpcall</code> captura o erro,
chama a fun&ccedil;&atilde;o <code>err</code> com o objeto de erro original
e retorna um c&oacute;digo indicando um status.
Seu primeiro resultado &eacute; o c&oacute;digo de status (um booleano),
que &eacute; verdadeiro se a chamada ocorreu sem erros.
Neste caso, <code>xpcall</code> tamb&eacute;m retorna todos os resultados da chamada,
depois deste primeiro resultado.
Em caso de erro,
<code>xpcall</code> retorna <b>false</b> mais o resultado de <code>err</code>.







<h2>5.2 - <a name="5.2">Manipula&ccedil;&atilde;o de Co-rotinas</a></h2>

<p>
As opera&ccedil;&otilde;es relacionadas a co-rotinas constituem uma sub-biblioteca da
biblioteca b&aacute;sica e est&atilde;o dentro da tabela <a name="pdf-coroutine"><code>coroutine</code></a>.
Veja <a href="#2.11">&sect;2.11</a> para uma descri&ccedil;&atilde;o geral de co-rotinas.


<p>
<hr><h3><a name="pdf-coroutine.create"><code>coroutine.create (f)</code></a></h3>


<p>
Cria uma nova co-rotina, com corpo <code>f</code>.
<code>f</code> deve ser uma fun&ccedil;&atilde;o Lua.
Retorna esta nova co-rotina,
um objeto com tipo <code>"thread"</code>.




<p>
<hr><h3><a name="pdf-coroutine.resume"><code>coroutine.resume (co [, val1, &middot;&middot;&middot;])</code></a></h3>


<p>
Inicia ou continua a execu&ccedil;&atilde;o da co-rotina <code>co</code>.
Na primeira vez que voc&ecirc; "continua" uma co-rotina,
ela come&ccedil;a executando o seu corpo.
Os valores <code>val1</code>, &middot;&middot;&middot; s&atilde;o passados
como os argumentos para o corpo da fun&ccedil;&atilde;o.
Se a co-rotina j&aacute; cedeu a execu&ccedil;&atilde;o antes,
<code>resume</code> a continua;
os valores <code>val1</code>, &middot;&middot;&middot; s&atilde;o passados
como os resultados da cess&atilde;o.


<p>
Se a co-rotina executa sem nenhum erro,
<code>resume</code> retorna <b>true</b> mais quaisquer valores passados para <code>yield</code>
(se a co-rotina cede) ou quaisquer valores retornados pelo corpo da fun&ccedil;&atilde;o
(se a co-rotina termina).
Se h&aacute; qualquer erro,
<code>resume</code> retorna <b>false</b> mais a mensagem de erro.




<p>
<hr><h3><a name="pdf-coroutine.running"><code>coroutine.running ()</code></a></h3>


<p>
Retorna a co-rotina sendo executada
ou <b>nil</b> quando chamada pelo fluxo de execu&ccedil;&atilde;o principal.




<p>
<hr><h3><a name="pdf-coroutine.status"><code>coroutine.status (co)</code></a></h3>


<p>
Retorna o status da co-rotina <code>co</code>, como uma cadeia de caracteres:
<code>"running"</code>,
se a co-rotina est&aacute; executando (isto &eacute;, ela chamou <code>status</code>);
<code>"suspended"</code>, se a co-rotina est&aacute; suspensa em uma chamada a <code>yield</code>
ou se ela n&atilde;o come&ccedil;ou a sua execu&ccedil;&atilde;o ainda;
<code>"normal"</code> se a co-rotina est&aacute; ativa mas n&atilde;o est&aacute; executando
(isto &eacute;, ela continuou outra co-rotina);
e <code>"dead"</code> se a co-rotina terminou sua fun&ccedil;&atilde;o principal
ou se ela parou com um erro.




<p>
<hr><h3><a name="pdf-coroutine.wrap"><code>coroutine.wrap (f)</code></a></h3>


<p>
Cria uma nova co-rotina, com corpo <code>f</code>.
<code>f</code> deve ser uma fun&ccedil;&atilde;o Lua.
Retorna uma fun&ccedil;&atilde;o que recome&ccedil;a a co-rotina cada vez que &eacute; chamada.
Quaisquer argumentos passados para a fun&ccedil;&atilde;o comportam-se como os
argumentos extras para <code>resume</code>.
Retorna os mesmos valores retornados por <code>resume</code>,
exceto o primeiro booleano.
Em caso de erro, propaga o erro.




<p>
<hr><h3><a name="pdf-coroutine.yield"><code>coroutine.yield (&middot;&middot;&middot;)</code></a></h3>


<p>
Suspende a execu&ccedil;&atilde;o da co-rotina chamadora.
A co-rotina n&atilde;o pode estar executando uma fun&ccedil;&atilde;o&nbsp;C,
um metam&eacute;todo ou um iterador.
Quaisquer argumentos para <code>yield</code> s&atilde;o passados como resultados extras para <code>resume</code>.






<h2>5.3 - <a name="5.3">M&oacute;dulos</a></h2>

<p>
A biblioteca de pacotes prov&ecirc; facilidades
b&aacute;sicas para carregar e construir m&oacute;dulos em Lua.
Ela exporta duas de suas fun&ccedil;&otilde;es diretamente no ambiente global:
<a href="#pdf-require"><code>require</code></a> e <a href="#pdf-module"><code>module</code></a>.
Todas as outras fun&ccedil;&otilde;es s&atilde;o exportadas em uma tabela <a name="pdf-package"><code>package</code></a>.


<p>
<hr><h3><a name="pdf-module"><code>module (name [, &middot;&middot;&middot;])</code></a></h3>


<p>
Cria um m&oacute;dulo.
Se h&aacute; uma tabela em <code>package.loaded[name]</code>,
esta tabela &eacute; o m&oacute;dulo.
Caso contr&aacute;rio, se existe uma tabela global <code>t</code> com o nome fornecido,
esta tabela &eacute; o m&oacute;dulo.
Caso contr&aacute;rio cria uma nova tabela <code>t</code> e
a estabelece como o valor da global <code>name</code> e
o valor de <code>package.loaded[name]</code>.
Esta fun&ccedil;&atilde;o tamb&eacute;m inicializa <code>t._NAME</code> com o nome fornecido,
<code>t._M</code> com o m&oacute;dulo (o pr&oacute;prio <code>t</code>)
e <code>t._PACKAGE</code> com o nome do pacote
(o nome do m&oacute;dulo completo menos o &uacute;ltimo componente; veja abaixo).
Finalmente, <code>module</code> estabelece <code>t</code> como o novo ambiente
da fun&ccedil;&atilde;o corrente e o novo valor de <code>package.loaded[name]</code>,
de modo que <a href="#pdf-require"><code>require</code></a> retorna <code>t</code>.


<p>
Se <code>name</code> &eacute; um nome composto
(isto &eacute;, um nome com componentes separados por pontos),
<code>module</code> cria (ou reusa, se elas j&aacute; existem)
tabelas para cada componente.
Por exemplo, se <code>name</code> &eacute; <code>a.b.c</code>,
ent&atilde;o <code>module</code> armazena a tabela do m&oacute;dulo no campo <code>c</code> do
campo <code>b</code> da global <code>a</code>.


<p>
Esta fun&ccedil;&atilde;o pode receber algumas <em>op&ccedil;&otilde;es</em> depois
do nome do m&oacute;dulo,
onde cada op&ccedil;&atilde;o &eacute; uma fun&ccedil;&atilde;o a ser aplicada sobre o m&oacute;dulo.




<p>
<hr><h3><a name="pdf-require"><code>require (modname)</code></a></h3>


<p>
Carrega o m&oacute;dulo fornecido.
Esta fun&ccedil;&atilde;o come&ccedil;a procurando na tabela <a href="#pdf-package.loaded"><code>package.loaded</code></a>
para determinar se <code>modname</code> j&aacute; foi carregado.
Em caso afirmativo, <code>require</code> retorna o valor armazenado
em <code>package.loaded[modname]</code>.
Caso contr&aacute;rio, ela tenta achar um <em>carregador</em> para o m&oacute;dulo.


<p>
Para encontrar um carregador,
<code>require</code> &eacute; guiada pelo array <a href="#pdf-package.loaders"><code>package.loaders</code></a>.
Modificando este array,
podemos mudar como <code>require</code> procura por um m&oacute;dulo.
A seguinte explica&ccedil;&atilde;o &eacute; baseada na configura&ccedil;&atilde;o padr&atilde;o
para <a href="#pdf-package.loaders"><code>package.loaders</code></a>.


<p>
Primeiro <code>require</code> consulta <code>package.preload[modname]</code>.
Se existe um valor nesse campo,
este valor (que deve ser uma fun&ccedil;&atilde;o) &eacute; o carregador.
Caso contr&aacute;rio <code>require</code> busca por um carregador Lua usando o
caminho armazenado em <a href="#pdf-package.path"><code>package.path</code></a>.
Se isso tamb&eacute;m falha, ela busca por um carregador&nbsp;C usando o
caminho armazenado em <a href="#pdf-package.cpath"><code>package.cpath</code></a>.
Se isso tamb&eacute;m falha,
ela tenta um carregador <em>tudo-em-um</em> (ver <a href="#pdf-package.loaders"><code>package.loaders</code></a>).


<p>
Uma vez que um carregador &eacute; encontrado,
<code>require</code> chama o carregador com um &uacute;nico argumento, <code>modname</code>.
Se o carregador retorna qualquer valor,
<code>require</code> atribui o valor retornado a <code>package.loaded[modname]</code>.
Se o carregador n&atilde;o retorna nenhum valor e
n&atilde;o foi atribu&iacute;do nenhum valor a <code>package.loaded[modname]</code>,
ent&atilde;o <code>require</code> atribui <b>true</b> a esta posi&ccedil;&atilde;o.
Em qualquer caso, <code>require</code> retorna o
valor final de <code>package.loaded[modname]</code>.


<p>
Se ocorre um erro durante o carregamento ou a execu&ccedil;&atilde;o do m&oacute;dulo
ou se n&atilde;o &eacute; poss&iacute;vel encontrar um carregador para o m&oacute;dulo,
ent&atilde;o <code>require</code> sinaliza um erro.




<p>
<hr><h3><a name="pdf-package.cpath"><code>package.cpath</code></a></h3>


<p>
O caminho usado por <a href="#pdf-require"><code>require</code></a> para procurar por um carregador&nbsp;C.


<p>
Lua inicializa o caminho&nbsp;C <a href="#pdf-package.cpath"><code>package.cpath</code></a> da mesma forma
que inicializa o caminho Lua <a href="#pdf-package.path"><code>package.path</code></a>,
usando a vari&aacute;vel de ambiente <a name="pdf-LUA_CPATH"><code>LUA_CPATH</code></a>
ou um caminho padr&atilde;o definido em <code>luaconf.h</code>.




<p>

<hr><h3><a name="pdf-package.loaded"><code>package.loaded</code></a></h3>


<p>
Uma tabela usada por <a href="#pdf-require"><code>require</code></a> para controlar quais
m&oacute;dulos j&aacute; foram carregados.
Quando voc&ecirc; requisita um m&oacute;dulo <code>modname</code> e
<code>package.loaded[modname]</code> n&atilde;o &eacute; falso,
<a href="#pdf-require"><code>require</code></a> simplesmente retorna o valor armazenado l&aacute;.




<p>
<hr><h3><a name="pdf-package.loaders"><code>package.loaders</code></a></h3>


<p>
Uma tabela usada por <a href="#pdf-require"><code>require</code></a> para controlar como carregar m&oacute;dulos.


<p>
Cada posi&ccedil;&atilde;o nesta tabela &eacute; uma <em>fun&ccedil;&atilde;o buscadora</em>.
Quando est&aacute; procurando um m&oacute;dulo,
<a href="#pdf-require"><code>require</code></a> chama cada uma destas fun&ccedil;&otilde;es buscadoras em ordem crescente,
com o nome do m&oacute;dulo (o argumento fornecido a <a href="#pdf-require"><code>require</code></a>) como seu
&uacute;nico par&acirc;metro.
A fun&ccedil;&atilde;o pode retornar outra fun&ccedil;&atilde;o (o <em>carregador</em> do m&oacute;dulo)
ou uma cadeia de caracteres explicando porque ela n&atilde;o achou aquele m&oacute;dulo
(ou <b>nil</b> se ela n&atilde;o tem nada a dizer).
Lua inicializa esta tabela com quatro fun&ccedil;&otilde;es.


<p>
A primeira fun&ccedil;&atilde;o buscadora simplesmente procurar um carregador no
tabela <a href="#pdf-package.preload"><code>package.preload</code></a>.


<p>
A segunda fun&ccedil;&atilde;o buscadora procura um carregador como uma biblioteca Lua,
usando o caminho armazenado em <a href="#pdf-package.path"><code>package.path</code></a>.
Um caminho &eacute; uma seq&uuml;&ecirc;ncia de <em>padr&otilde;es</em> separados por ponto-e-v&iacute;rgulas.
Para cada padr&atilde;o,
a fun&ccedil;&atilde;o buscadora ir&aacute; mudar cada ponto
de interroga&ccedil;&atilde;o no padr&atilde;o para <code>filename</code>,
que &eacute; o nome do m&oacute;dulo com cada ponto substitu&iacute;do por um
"separador de diret&oacute;rio" (como "<code>/</code>" no Unix);
ent&atilde;o ela tentar&aacute; abrir o nome do arquivo resultante.
Por exemplo, se o caminho &eacute; a cadeia de caracteres

<pre>
     "./?.lua;./?.lc;/usr/local/?/init.lua"
</pre><p>
a busca por um arquivo Lua para o m&oacute;dulo <code>foo</code>
tentar&aacute; abrir os arquivos
<code>./foo.lua</code>, <code>./foo.lc</code> e
<code>/usr/local/foo/init.lua</code>, nessa ordem.


<p>
A terceira fun&ccedil;&atilde;o buscadora procura um carregador como uma biblioteca&nbsp;C,
usando o caminho fornecido pela vari&aacute;vel <a href="#pdf-package.cpath"><code>package.cpath</code></a>.
Por exemplo,
se o caminho&nbsp;C &eacute; a cadeia

<pre>
     "./?.so;./?.dll;/usr/local/?/init.so"
</pre><p>
a fun&ccedil;&atilde;o buscadora para o m&oacute;dulo <code>foo</code>
tentar&aacute; abrir os arquivos <code>./foo.so</code>, <code>./foo.dll</code>
e <code>/usr/local/foo/init.so</code>, nessa ordem.
Uma vez que ela encontra uma biblioteca&nbsp;C,
esta fun&ccedil;&atilde;o buscadora primeiro usa uma facilidade de liga&ccedil;&atilde;o din&acirc;mica para ligar a
aplica&ccedil;&atilde;o com a biblioteca.
Ent&atilde;o ela tenta encontrar uma fun&ccedil;&atilde;o&nbsp;C dentro da biblioteca para
ser usada como carregador.
O nome desta fun&ccedil;&atilde;o&nbsp;C &eacute; a cadeia "<code>luaopen_</code>"
concatenada com uma c&oacute;pia do nome do m&oacute;dulo onde cada ponto
&eacute; substitu&iacute;do por um sublinhado.
Al&eacute;m disso, se o nome do m&oacute;dulo possui um h&iacute;fen,
seu prefixo at&eacute; (e incluindo) o primeiro h&iacute;fen &eacute; removido.
Por exemplo, se o nome do m&oacute;dulo &eacute; <code>a.v1-b.c</code>,
o nome da fun&ccedil;&atilde;o ser&aacute; <code>luaopen_b_c</code>.


<p>
A quarta fun&ccedil;&atilde;o buscadora tenta um <em>carregador tudo-em-um</em>.
Ela procura no caminho&nbsp;C uma biblioteca para
a raiz do nome do m&oacute;dulo fornecido.
Por exemplo, quando requisitando <code>a.b.c</code>,
ela buscar&aacute; por uma biblioteca&nbsp;C para <code>a</code>.
Se encontrar, ela busca nessa biblioteca por uma fun&ccedil;&atilde;o de abertura para
o subm&oacute;dulo;
no nosso exemplo, seria <code>luaopen_a_b_c</code>.
Com esta facilidade, um pacote pode empacotar v&aacute;rios subm&oacute;dulos&nbsp;C
dentro de uma &uacute;nica biblioteca,
com cada subm&oacute;dulo guardando a sua fun&ccedil;&atilde;o de abertura original.




<p>
<hr><h3><a name="pdf-package.loadlib"><code>package.loadlib (libname, funcname)</code></a></h3>


<p>
Liga dinamicamente o programa hospedeiro com a biblioteca&nbsp;C <code>libname</code>.
Dentro desta biblioteca, procura por uma fun&ccedil;&atilde;o <code>funcname</code>
e retorna essa fun&ccedil;&atilde;o como uma fun&ccedil;&atilde;o&nbsp;C.
(Desse modo, <code>funcname</code> deve seguir o protocolo (ver <a href="#lua_CFunction"><code>lua_CFunction</code></a>)).


<p>
Esta &eacute; uma fun&ccedil;&atilde;o de baixo n&iacute;vel.
Ela contorna completamente o sistema de pacotes e de m&oacute;dulos.
Diferentemente de <a href="#pdf-require"><code>require</code></a>,
ela n&atilde;o realiza qualquer busca de caminho e
n&atilde;o adiciona extens&otilde;es automaticamente.
<code>libname</code> deve ser o nome do arquivo completo da biblioteca&nbsp;C,
incluindo se necess&aacute;rio um caminho e uma extens&atilde;o.
<code>funcname</code> deve ser o nome exato exportado pela biblioteca&nbsp;C
(que pode depender de como o compilador e o ligador&nbsp;C s&atilde;o usados).


<p>
Esta fun&ccedil;&atilde;o n&atilde;o &eacute; provida por ANSI C.
Dessa forma, ela est&aacute; dispon&iacute;vel somente em algumas plataformas
(Windows, Linux, Mac OS X, Solaris, BSD,
mais outros sistemas Unix que d&atilde;o suporte ao padr&atilde;o <code>dlfcn</code>).




<p>
<hr><h3><a name="pdf-package.path"><code>package.path</code></a></h3>


<p>
O caminho usado por <a href="#pdf-require"><code>require</code></a> para buscar um carregador Lua.


<p>
Ao iniciar, Lua inicializa esta vari&aacute;vel com
o valor da vari&aacute;vel de ambiente <a name="pdf-LUA_PATH"><code>LUA_PATH</code></a> ou
com um caminho padr&atilde;o definido em <code>luaconf.h</code>,
se a vari&aacute;vel de ambiente n&atilde;o est&aacute; definida.
Qualquer "<code>;;</code>" no valor da vari&aacute;vel de ambiente
ser&aacute; substitu&iacute;do pelo caminho padr&atilde;o.




<p>
<hr><h3><a name="pdf-package.preload"><code>package.preload</code></a></h3>


<p>
Uma tabela para armazenar carregadores para m&oacute;dulos espec&iacute;ficos
(ver <a href="#pdf-require"><code>require</code></a>).




<p>
<hr><h3><a name="pdf-package.seeall"><code>package.seeall (module)</code></a></h3>


<p>
Estabelece uma metatabela para <code>module</code> com
seu campo <code>__index</code> se referindo ao ambiente global,
de modo que esse m&oacute;dulo herda valores
do ambiente global.
Para ser usada como uma op&ccedil;&atilde;o &agrave; fun&ccedil;&atilde;o <a href="#pdf-module"><code>module</code></a>.







<h2>5.4 - <a name="5.4">Manipula&ccedil;&atilde;o de Cadeias de Caracteres</a></h2>

<p>
Esta biblioteca prov&ecirc; fun&ccedil;&otilde;es gen&eacute;ricas para a manipula&ccedil;&atilde;o de cadeias de caracteres,
tais como encontrar e extrair subcadeias e casamento de padr&otilde;es.
Ao indexar uma cadeia em Lua, o primeiro caractere est&aacute; na posi&ccedil;&atilde;o&nbsp;1
(n&atilde;o na posi&ccedil;&atilde;o&nbsp;0, como em C).
&Iacute;ndices podem ter valores negativos e s&atilde;o interpretados como uma indexa&ccedil;&atilde;o de tr&aacute;s para frente,
a partir do final da cadeia.
Portanto, o &uacute;ltimo caractere est&aacute; na posi&ccedil;&atilde;o -1 e assim por diante.


<p>
A biblioteca de cadeias prov&ecirc; todas as suas fun&ccedil;&otilde;es dentro da tabela
<a name="pdf-string"><code>string</code></a>.
Ela tamb&eacute;m estabelece uma metatabela para cadeias
onde o campo <code>__index</code> aponta para a tabela <code>string</code>.
Em conseq&uuml;&ecirc;ncia disso, voc&ecirc; pode usar as fun&ccedil;&otilde;es de cadeias em um estilo orientado a objetos.
Por exemplo, <code>string.byte(s, i)</code>
pode ser escrito como <code>s:byte(i)</code>.


<p>
A biblioteca de manipula&ccedil;&atilde;o de cadeias assume que cada caracter &eacute; codificado usando um byte.


<p>
<hr><h3><a name="pdf-string.byte"><code>string.byte (s [, i [, j]])</code></a></h3>
Retorna o c&oacute;digo num&eacute;rico interno dos caracteres <code>s[i]</code>,
<code>s[i+1]</code>, &middot;&middot;&middot;, <code>s[j]</code>.
O valor padr&atilde;o para <code>i</code> &eacute;&nbsp;1;
o valor padr&atilde;o para <code>j</code> &eacute;&nbsp;<code>i</code>.


<p>
Note que c&oacute;digos num&eacute;ricos n&atilde;o s&atilde;o necessariamente port&aacute;veis entre plataformas.




<p>
<hr><h3><a name="pdf-string.char"><code>string.char (&middot;&middot;&middot;)</code></a></h3>
Recebe zero ou mais inteiros.
Retorna uma cadeia com comprimento igual ao n&uacute;mero de argumentos,
na qual cada caractere possui um c&oacute;digo num&eacute;rico interno igual
ao seu argumento correspondente.


<p>
Note que c&oacute;digos num&eacute;ricos n&atilde;o s&atilde;o necessariamente port&aacute;veis entre plataformas.




<p>
<hr><h3><a name="pdf-string.dump"><code>string.dump (function)</code></a></h3>


<p>
Retorna uma cadeia contendo a representa&ccedil;&atilde;o bin&aacute;ria da fun&ccedil;&atilde;o fornecida,
de modo que um <a href="#pdf-loadstring"><code>loadstring</code></a> posterior nesta cadeia retorna
uma c&oacute;pia da fun&ccedil;&atilde;o.
<code>function</code> deve ser uma fun&ccedil;&atilde;o Lua sem upvalues.




<p>
<hr><h3><a name="pdf-string.find"><code>string.find (s, pattern [, init [, plain]])</code></a></h3>
Procura o primeiro casamento do padr&atilde;o
<code>pattern</code> na cadeia <code>s</code>.
Se a fun&ccedil;&atilde;o acha um casamento, ent&atilde;o <code>find</code> retorna os &iacute;ndices de&nbsp;<code>s</code>
onde esta ocorr&ecirc;ncia come&ccedil;ou e terminou;
caso contr&aacute;rio, retorna <b>nil</b>.
O terceiro argumento, <code>init</code>, &eacute; um valor num&eacute;rico opcional e especifica
onde iniciar a busca;
seu valor padr&atilde;o &eacute;&nbsp;1 e pode ser negativo.
Um valor <b>true</b> para o quarto argumento, <code>plain</code>, que &eacute; opcional,
desabilita as facilidades de casamento de padr&otilde;es,
de modo que a fun&ccedil;&atilde;o faz uma opera&ccedil;&atilde;o "encontra subcadeia" simples,
sem considerar nenhum caractere em <code>pattern</code> como "m&aacute;gico".
Note que se <code>plain</code> &eacute; fornecido, ent&atilde;o <code>init</code> deve ser fornecido tamb&eacute;m.


<p>
Se o padr&atilde;o possui capturas,
ent&atilde;o em um casamento bem-sucedido
os valores capturados s&atilde;o tamb&eacute;m retornados,
ap&oacute;s os dois &iacute;ndices.




<p>
<hr><h3><a name="pdf-string.format"><code>string.format (formatstring, &middot;&middot;&middot;)</code></a></h3>
Retorna a vers&atilde;o formatada de seu n&uacute;mero vari&aacute;vel de argumentos
seguindo a descri&ccedil;&atilde;o dada no seu primeiro argumento (que deve ser uma cadeia).
O formato da cadeia segue as mesmas regras da fam&iacute;lia <code>printf</code> de
fun&ccedil;&otilde;es&nbsp;C padr&atilde;o.
As &uacute;nicas diferen&ccedil;as s&atilde;o que as op&ccedil;&otilde;es/modificadores
<code>*</code>, <code>l</code>, <code>L</code>, <code>n</code>, <code>p</code>
e <code>h</code> n&atilde;o s&atilde;o oferecidas
e que h&aacute; uma op&ccedil;&atilde;o extra, <code>q</code>.
A op&ccedil;&atilde;o <code>q</code> formata uma cadeia em uma forma adequada para ser lida de volta de
forma segura pelo interpretador Lua;
a cadeia &eacute; escrita entre aspas duplas
e todas as aspas duplas, quebras de linha, barras invertidas
e zeros dentro da cadeia
s&atilde;o corretamente escapados quando escritos.
Por exemplo, a chamada

<pre>
     string.format('%q', 'a string with "quotes" and \n new line')
</pre><p>
produzir&aacute; a cadeia:

<pre>
     "a string with \"quotes\" and \
      new line"
</pre>

<p>
As op&ccedil;&otilde;es <code>c</code>, <code>d</code>, <code>E</code>, <code>e</code>, <code>f</code>,
<code>g</code>, <code>G</code>, <code>i</code>, <code>o</code>, <code>u</code>, <code>X</code> e <code>x</code>
esperam um n&uacute;mero como argumento,
enquanto que <code>q</code> e <code>s</code> esperam uma cadeia.


<p>
Esta fun&ccedil;&atilde;o n&atilde;o aceita valores de cadeias
contendo zeros dentro delas,
exceto quando esses valores s&atilde;o argumentos para a op&ccedil;&atilde;o <code>q</code>.




<p>
<hr><h3><a name="pdf-string.gmatch"><code>string.gmatch (s, pattern)</code></a></h3>
Retorna uma fun&ccedil;&atilde;o iteradora que,
cada vez que &eacute; chamada,
retorna a pr&oacute;xima captura de <code>pattern</code> na cadeia <code>s</code>.
Se <code>pattern</code> n&atilde;o especifica nenhuma captura,
ent&atilde;o o casamento inteiro &eacute; produzido a cada chamada.
	
Como um exemplo, o seguinte la&ccedil;o

<pre>
     s = "hello world from Lua"
     for w in string.gmatch(s, "%a+") do
       print(w)
     end
</pre><p>
ir&aacute; iterar sobre todas as palavras da cadeia <code>s</code>,
imprimindo uma por linha.
O pr&oacute;ximo exemplo coleta todos os pares <code>key=value</code> da
cadeia fornecida e os coloca em uma tabela:

<pre>
     t = {}
     s = "from=world, to=Lua"
     for k, v in string.gmatch(s, "(%w+)=(%w+)") do
       t[k] = v
     end
</pre>

<p>
Para essa fun&ccedil;&atilde;o, um '<code>^</code>' no in&iacute;cio de um padr&atilde;o n&atilde;o
funciona como uma &acirc;ncora, visto que isso iria impedir a itera&ccedil;&atilde;o.




<p>
<hr><h3><a name="pdf-string.gsub"><code>string.gsub (s, pattern, repl [, n])</code></a></h3>
Retorna uma c&oacute;pia de <code>s</code>
na qual todas as (ou as primeiras <code>n</code>, se fornecido)
ocorr&ecirc;ncias de <code>pattern</code> s&atilde;o
substitu&iacute;das por uma cadeia de substitui&ccedil;&atilde;o especificada por <code>repl</code>,
que pode ser uma cadeia, uma tabela ou uma fun&ccedil;&atilde;o.
<code>gsub</code> tamb&eacute;m retorna, como seu segundo valor,
o n&uacute;mero total de substitui&ccedil;&otilde;es que ocorreram.


<p>
Se <code>repl</code> &eacute; uma cadeia, ent&atilde;o seu valor &eacute; usado para a substitui&ccedil;&atilde;o.
O caractere&nbsp;<code>%</code> funciona como um caractere de escape:
qualquer seq&uuml;&ecirc;ncia em <code>repl</code> da forma <code>%<em>n</em></code>,
com <em>n</em> entre 1 e 9,
representa o valor da <em>n</em>-&eacute;sima subcadeia capturada (veja abaixo).
A seq&uuml;&ecirc;ncia <code>%0</code> representa o casamento inteiro.
A seq&uuml;&ecirc;ncia <code>%%</code> representa um <code>%</code>&nbsp;simples.


<p>
Se <code>repl</code> &eacute; uma tabela, ent&atilde;o a tabela &eacute; consultada a cada casamento,
usando a primeira captura como a chave;
se o padr&atilde;o n&atilde;o especifica nenhuma captura,
ent&atilde;o o casamento inteiro &eacute; usado como a chave.


<p>
Se <code>repl</code> &eacute; uma fun&ccedil;&atilde;o, ent&atilde;o esta fun&ccedil;&atilde;o &eacute; chamada toda vez que o
casamento ocorre, com todas as subcadeias capturadas sendo passadas como argumentos,
na ordem em que foram capturadas;
se o padr&atilde;o n&atilde;o especifica nenhuma captura,
ent&atilde;o o casamento inteiro &eacute; passado como um &uacute;nico argumento.


<p>
Se o valor retornado pela consulta &agrave; tabela ou pela chamada de fun&ccedil;&atilde;o
&eacute; uma cadeia ou um n&uacute;mero,
ent&atilde;o esse valor &eacute; usado como a cadeia de substitui&ccedil;&atilde;o;
caso contr&aacute;rio, se ele &eacute; <b>false</b> ou <b>nil</b>,
ent&atilde;o n&atilde;o h&aacute; substitui&ccedil;&atilde;o
(isto &eacute;, o casamento original &eacute; mantido na cadeia).


<p>
Aqui est&atilde;o alguns exemplos:

<pre>
     x = string.gsub("hello world", "(%w+)", "%1 %1")
     --&gt; x="hello hello world world"
     
     x = string.gsub("hello world", "%w+", "%0 %0", 1)
     --&gt; x="hello hello world"
     
     x = string.gsub("hello world from Lua", "(%w+)%s*(%w+)", "%2 %1")
     --&gt; x="world hello Lua from"
     
     x = string.gsub("home = $HOME, user = $USER", "%$(%w+)", os.getenv)
     --&gt; x="home = /home/roberto, user = roberto"
     
     x = string.gsub("4+5 = $return 4+5$", "%$(.-)%$", function (s)
           return loadstring(s)()
         end)
     --&gt; x="4+5 = 9"
     
     local t = {name="lua", version="5.1"}
     x = string.gsub("$name-$version.tar.gz", "%$(%w+)", t)
     --&gt; x="lua-5.1.tar.gz"
</pre>



<p>
<hr><h3><a name="pdf-string.len"><code>string.len (s)</code></a></h3>
Recebe uma cadeia e retorna seu comprimento.
A cadeia vazia <code>""</code> tem comprimento 0.
Zeros dentro da cadeia s&atilde;o contados,
ent&atilde;o <code>"a\000bc\000"</code> possui comprimento 5.




<p>
<hr><h3><a name="pdf-string.lower"><code>string.lower (s)</code></a></h3>
Recebe uma cadeia e retorna uma c&oacute;pia desta cadeia com todas
as letras mai&uacute;sculas convertidas para min&uacute;sculas.
Todos os demais caracteres permanecem iguais.
A defini&ccedil;&atilde;o de o que &eacute; uma letra mai&uacute;scula depende do idioma (<em>locale</em>) corrente.




<p>
<hr><h3><a name="pdf-string.match"><code>string.match (s, pattern [, init])</code></a></h3>
Procura o primeiro <em>casamento</em> de
<code>pattern</code> na cadeia <code>s</code>.
Se encontra um, ent&atilde;o <code>match</code> retorna
as capturas do padr&atilde;o;
caso contr&aacute;rio retorna <b>nil</b>.
Se <code>pattern</code> n&atilde;o especifica nenhuma captura,
ent&atilde;o o casamento inteiro &eacute; retornado.
Um terceiro argumento num&eacute;rico opcional, <code>init</code>, especifica
onde iniciar a busca;
seu valor padr&atilde;o &eacute;&nbsp;1 e pode ser negativo.
	



<p>
<hr><h3><a name="pdf-string.rep"><code>string.rep (s, n)</code></a></h3>
Retorna uma cadeia que &eacute; a concatena&ccedil;&atilde;o de <code>n</code> c&oacute;pias da
cadeia <code>s</code>.




<p>
<hr><h3><a name="pdf-string.reverse"><code>string.reverse (s)</code></a></h3>
Retorna uma cadeia que &eacute; a cadeia <code>s</code> invertida.




<p>
<hr><h3><a name="pdf-string.sub"><code>string.sub (s, i [, j])</code></a></h3>
Retorna uma subcadeia de <code>s</code> que
inicia em <code>i</code> e continua at&eacute; <code>j</code>;
<code>i</code> e <code>j</code> podem ser negativos.
Se <code>j</code> est&aacute; ausente, ent&atilde;o assume-se que ele &eacute; igual a -1
(que &eacute; o mesmo que o comprimento da cadeia).
Em particular,
a chamada <code>string.sub(s,1,j)</code> retorna um prefixo de <code>s</code>
com comprimento <code>j</code>
e <code>string.sub(s, -i)</code> retorna um sufixo de <code>s</code>
com comprimento <code>i</code>.




<p>
<hr><h3><a name="pdf-string.upper"><code>string.upper (s)</code></a></h3>
Recebe uma cadeia e retorna uma c&oacute;pia desta cadeia com todas
as letras min&uacute;sculas convertidas para mai&uacute;sculas.
Todos os demais caracteres permanecem iguais.
A defini&ccedil;&atilde;o de o que &eacute; uma letra min&uacute;scula depende do idioma (<em>locale</em>) corrente.
	



<h3>5.4.1 - <a name="5.4.1">Padr&otilde;es</a></h3>


<h4>Classes de Caracteres:</h4><p>
Uma <em>classe de caracteres</em> &eacute; usada para representar um conjunto de caracteres.
As seguintes combina&ccedil;&otilde;es s&atilde;o permitidas em descri&ccedil;&otilde;es de uma classe de caracteres:

<ul>

<li><b><em>x</em>:</b>
(onde <em>x</em> n&atilde;o &eacute; um dos <em>caracteres m&aacute;gicos</em>
<code>^$()%.[]*+-?</code>)
representa o pr&oacute;prio caractere <em>x</em>.
</li>

<li><b><code>.</code>:</b> (um ponto) representa todos os caracteres.</li>

<li><b><code>%a</code>:</b> representa todas as letras.</li>

<li><b><code>%c</code>:</b> representa todos os caracteres de controle.</li>

<li><b><code>%d</code>:</b> representa todos os d&iacute;gitos.</li>

<li><b><code>%l</code>:</b> representa todas as letras min&uacute;sculas.</li>

<li><b><code>%p</code>:</b> representa todos os caracteres de pontua&ccedil;&atilde;o.</li>

<li><b><code>%s</code>:</b> representa todos os caracteres de espa&ccedil;o.</li>

<li><b><code>%u</code>:</b> representa todas as letras mai&uacute;sculas.</li>

<li><b><code>%w</code>:</b> representa todos os caracteres alfanum&eacute;ricos.</li>

<li><b><code>%x</code>:</b> representa todos os d&iacute;gitos hexadecimais.</li>

<li><b><code>%z</code>:</b> representa o caractere com representa&ccedil;&atilde;o 0.</li>

<li><b><code>%<em>x</em></code>:</b> (onde <em>x</em> &eacute; qualquer caractere n&atilde;o-alfanum&eacute;rico)
representa o caractere <em>x</em>.
Esta &eacute; a maneira padr&atilde;o de escapar os caracteres m&aacute;gicos.
Qualquer caractere de pontua&ccedil;&atilde;o (at&eacute; mesmo os n&atilde;o m&aacute;gicos)
pode ser precedido por um '<code>%</code>'
quando usado para representar a si mesmo em um padr&atilde;o.
</li>

<li><b><code>[<em>set</em>]</code>:</b>
representa a classe que &eacute; a uni&atilde;o de todos
os caracteres em <em>set</em>.
Uma faixa de caracteres pode ser especificada
separando os caracteres finais da faixa com um '<code>-</code>'.
Todas as classes <code>%</code><em>x</em> descritas acima tamb&eacute;m podem ser usadas como
componentes em <em>set</em>.
Todos os outros caracteres em <em>set</em> representam eles mesmos.
Por exemplo, <code>[%w_]</code> (ou <code>[_%w]</code>)
representa todos os caracteres alfanum&eacute;ricos mais o sublinhado,
<code>[0-7]</code> representa os d&iacute;gitos octais
e <code>[0-7%l%-]</code> representa os d&iacute;gitos octais mais
as letras min&uacute;sculas mais o caractere '<code>-</code>'.


<p>
A intera&ccedil;&atilde;o entre faixas e classes n&atilde;o &eacute; definida.
Portanto, padr&otilde;es como <code>[%a-z]</code> ou <code>[a-%%]</code>
n&atilde;o possuem significado.


<p>
</li>

<li><b><code>[^<em>set</em>]</code>:</b>
representa o complemento de <em>set</em>,
onde <em>set</em> &eacute; interpretado como acima.
</li>

</ul><p>
Para todas as classes representadas por uma &uacute;nica letra (<code>%a</code>, <code>%c</code>, etc.),
a letra mai&uacute;scula correspondente representa o complemento da classe.
Por exemplo, <code>%S</code> representa todos os caracteres que n&atilde;o s&atilde;o de espa&ccedil;o.


<p>
As defini&ccedil;&otilde;es de letra, espa&ccedil;o e outros grupos de caracteres
dependem do idioma (<em>locale</em>) corrente.
Em particular, a classe <code>[a-z]</code> pode n&atilde;o ser equivalente a <code>%l</code>.





<h4>Item de Padr&atilde;o:</h4><p>
Um <em>item de padr&atilde;o</em> pode ser

<ul>

<li>
uma classe de um &uacute;nico caractere,
que casa qualquer caractere simples que penten&ccedil;a &agrave; classe;
</li>

<li>
uma classe de um &uacute;nico caractere seguida por '<code>*</code>',
que casa 0 ou mais repeti&ccedil;&otilde;es de caracteres da classe.
Estes itens de repeti&ccedil;&atilde;o sempre casar&atilde;o a maior seq&uuml;&ecirc;ncia poss&iacute;vel;	
</li>

<li>
uma classe de um &uacute;nico caractere seguida por '<code>+</code>',
que casa 1 ou mais repeti&ccedil;&otilde;es de caracteres da classe.
Estes itens de repeti&ccedil;&atilde;o sempre casar&atilde;o a maior seq&uuml;&ecirc;ncia poss&iacute;vel;
</li>

<li>
uma classe de um &uacute;nico caractere seguida por '<code>-</code>',
que tamb&eacute;m casa 0 ou mais repeti&ccedil;&otilde;es de caracteres da classe.
Diferentemente de '<code>*</code>',
estes itens de repeti&ccedil;&atilde;o sempre casar&atilde;o a <em>menor</em> seq&uuml;&ecirc;ncia poss&iacute;vel;
</li>

<li>
uma classe de um &uacute;nico caractere seguida por '<code>?</code>',
que casa 0 ou 1 ocorr&ecirc;ncia de um caractere da classe;
</li>

<li>
<code>%<em>n</em></code>, para <em>n</em> entre 1 e 9;
tal item casa uma subcadeia igual &agrave; <em>n</em>-&eacute;sima cadeia capturada
(veja abaixo);
</li>

<li>
<code>%b<em>xy</em></code>, onde <em>x</em> e <em>y</em> s&atilde;o dois caracteres distintos;
tal item casa cadeias que come&ccedil;am com&nbsp;<em>x</em>, terminam com&nbsp;<em>y</em>
e onde o n&uacute;mero de <em>x</em>s e de <em>y</em>s &eacute; <em>balanceado</em>.
Isto significa que, se algu&eacute;m ler a cadeia da esquerda para a direita,
contando <em>+1</em> para um <em>x</em> e <em>-1</em> para um <em>y</em>,
o <em>y</em> final &eacute; o primeiro <em>y</em> onde o contador alcan&ccedil;a 0.
Por exemplo, o item <code>%b()</code> casa express&otilde;es com
par&ecirc;nteses balanceados.


<p>
</li>

</ul>




<h4>Padr&atilde;o:</h4><p>
Um <em>padr&atilde;o</em> &eacute; uma seq&uuml;&ecirc;ncia de itens de padr&atilde;o.
Um '<code>^</code>' no in&iacute;cio de um padr&atilde;o ancora o casamento no
in&iacute;cio da cadeia sendo usada.
Um '<code>$</code>' no fim de um padr&atilde;o ancora o casamento no
fim da cadeia sendo usada.
Em outras posi&ccedil;&otilde;es,
'<code>^</code>' e '<code>$</code>' n&atilde;o possuem significado especial e representam a si mesmos.





<h4>Capturas:</h4><p>
Um padr&atilde;o pode conter subpadr&otilde;es delimitados por par&ecirc;nteses;
eles descrevem <em>capturas</em>.
Quando um casamento ocorre, as subcadeias da cadeia sendo usada
que casaram com as capturas s&atilde;o armazenadas (<em>capturadas</em>) para uso futuro.
Capturas s&atilde;o numeradas de acordo com os seus par&ecirc;nteses esquerdos.
Por exemplo, no padr&atilde;o <code>"(a*(.)%w(%s*))"</code>,
a parte da cadeia casando <code>"a*(.)%w(%s*)"</code> &eacute;
armazenada como a primeira captura (e portanto tem n&uacute;mero&nbsp;1);
o caractere casando "<code>.</code>" &eacute; capturado com o n&uacute;mero&nbsp;2
e a parte casando "<code>%s*</code>" possui n&uacute;mero&nbsp;3.


<p>
Como um caso especial, a captura vazia <code>()</code> captura
a posi&ccedil;&atilde;o da cadeia corrente (um n&uacute;mero).
Por exemplo, se aplicarmos o padr&atilde;o <code>"()aa()"</code> na
cadeia <code>"flaaap"</code>, haver&aacute; duas capturas: 3&nbsp;e&nbsp;5.


<p>
Um padr&atilde;o n&atilde;o pode conter zeros dentro dele. Use <code>%z</code> como alternativa.











<h2>5.5 - <a name="5.5">Manipula&ccedil;&atilde;o de Tabelas</a></h2><p>
Esta biblioteca prov&ecirc; fun&ccedil;&otilde;es gen&eacute;ricas para manipula&ccedil;&atilde;o de tabelas.
Ela prov&ecirc; todas as suas fun&ccedil;&otilde;es na tabela <a name="pdf-table"><code>table</code></a>.	


<p>
A maioria das fun&ccedil;&otilde;es na biblioteca de tabelas assume que a tabela
representa um array ou uma lista.
Para estas fun&ccedil;&otilde;es, quando falamos sobre o "comprimento" de uma tabela
estamos falando sobre o resultado do operador de comprimento.


<p>
<hr><h3><a name="pdf-table.concat"><code>table.concat (table [, sep [, i [, j]]])</code></a></h3>
Dado um array onde todos os elementos s&atilde;o cadeias ou n&uacute;meros,
retorna <code>table[i]..sep..table[i+1] &middot;&middot;&middot; sep..table[j]</code>.
O valor padr&atilde;o para <code>sep</code> &eacute; a cadeia vazia,
o padr&atilde;o para <code>i</code> &eacute; 1
e o padr&atilde;o para <code>j</code> &eacute; o comprimento da tabela.
Se <code>i</code> &eacute; maior do que <code>j</code>, retorna a cadeia vazia.




<p>
<hr><h3><a name="pdf-table.insert"><code>table.insert (table, [pos,] value)</code></a></h3>


<p>
Insere o elemento <code>value</code> na posi&ccedil;&atilde;o <code>pos</code> de <code>table</code>,
deslocando os outros elementos para abrir espa&ccedil;o, se necess&aacute;rio.
O valor padr&atilde;o para <code>pos</code> &eacute; <code>n+1</code>,
onde <code>n</code> &eacute; o comprimento da tabela (ver <a href="#2.5.5">&sect;2.5.5</a>),
de modo que uma chamada <code>table.insert(t,x)</code> insere <code>x</code> no fim
da tabela <code>t</code>.




<p>
<hr><h3><a name="pdf-table.maxn"><code>table.maxn (table)</code></a></h3>


<p>
Retorna o maior &iacute;ndice num&eacute;rico positivo da tabela fornecida
ou zero se a tabela n&atilde;o possui &iacute;ndices num&eacute;ricos positivos.
(Para realizar seu trabalho esta fun&ccedil;&atilde;o faz um percorrimento linear
da tabela inteira.)




<p>
<hr><h3><a name="pdf-table.remove"><code>table.remove (table [, pos])</code></a></h3>


<p>
Remove de <code>table</code> o elemento na posi&ccedil;&atilde;o <code>pos</code>,
deslocando os outros elementos para preencher o espa&ccedil;o, se necess&aacute;rio.
Retorna o valor do elemento removido.
O valor padr&atilde;o para <code>pos</code> &eacute; <code>n</code>,
onde <code>n</code> &eacute; o comprimento da tabela,
de modo que uma chamada <code>table.remove(t)</code> remove o &uacute;ltimo elemento
da tabela <code>t</code>.




<p>
<hr><h3><a name="pdf-table.sort"><code>table.sort (table [, comp])</code></a></h3>
Ordena os elementos da tabela em uma dada ordem, <em>in-place</em>,
de <code>table[1]</code> at&eacute; <code>table[n]</code>,
onde <code>n</code> &eacute; o comprimento da tabela.
Se <code>comp</code> &eacute; fornecido,
ent&atilde;o ele deve ser uma fun&ccedil;&atilde;o que recebe dois elementos da tabela
e retorna true
quando o primeiro &eacute; menor do que o segundo
(de modo que <code>not comp(a[i+1],a[i])</code> ser&aacute; verdadeiro ap&oacute;s a ordena&ccedil;&atilde;o).
Se <code>comp</code> n&atilde;o &eacute; fornecido,
ent&atilde;o o operador padr&atilde;o de Lua <code>&lt;</code> &eacute; usado em seu lugar.


<p>
O algoritmo de ordena&ccedil;&atilde;o n&atilde;o &eacute; est&aacute;vel;
isto &eacute;, elementos considerados iguais pela ordem fornecida
podem ter suas posi&ccedil;&otilde;es relativas trocadas pela ordena&ccedil;&atilde;o.







<h2>5.6 - <a name="5.6">Fun&ccedil;&otilde;es Matem&aacute;ticas</a></h2>

<p>
Esta biblioteca &eacute; uma interface para a biblioteca matem&aacute;tica de&nbsp;C padr&atilde;o.
Ela prov&ecirc; todas as suas fun&ccedil;&otilde;es na tabela <a name="pdf-math"><code>math</code></a>.	


<p>
<hr><h3><a name="pdf-math.abs"><code>math.abs (x)</code></a></h3>


<p>
Retorna o valor absoluto de <code>x</code>.




<p>
<hr><h3><a name="pdf-math.acos"><code>math.acos (x)</code></a></h3>


<p>
Retorna o arco co-seno de <code>x</code> (em radianos).




<p>
<hr><h3><a name="pdf-math.asin"><code>math.asin (x)</code></a></h3>


<p>
Retorna o arco seno de <code>x</code> (em radianos).




<p>
<hr><h3><a name="pdf-math.atan"><code>math.atan (x)</code></a></h3>


<p>
Retorna o arco tangente de <code>x</code> (em radianos).




<p>
<hr><h3><a name="pdf-math.atan2"><code>math.atan2 (y, x)</code></a></h3>


<p>
Retorna o arco tangente de <code>y/x</code> (em radianos),
mas usa o sinal dos dois par&acirc;metros para achar o
quadrante do resultado.
(Tamb&eacute;m trata corretamente o caso de <code>x</code> ser zero.)




<p>
<hr><h3><a name="pdf-math.ceil"><code>math.ceil (x)</code></a></h3>


<p>
Retorna o menor inteiro maior ou igual a <code>x</code>.




<p>
<hr><h3><a name="pdf-math.cos"><code>math.cos (x)</code></a></h3>


<p>
Retorna o co-seno de <code>x</code> (assume que <code>x</code> est&aacute; em radianos).




<p>
<hr><h3><a name="pdf-math.cosh"><code>math.cosh (x)</code></a></h3>


<p>
Retorna o co-seno hiperb&oacute;lico de <code>x</code>.




<p>
<hr><h3><a name="pdf-math.deg"><code>math.deg (x)</code></a></h3>


<p>
Retorna o &acirc;ngulo <code>x</code> (dado em radianos) em graus.




<p>
<hr><h3><a name="pdf-math.exp"><code>math.exp (x)</code></a></h3>


<p>
Retorna o valor de <em>e<sup>x</sup></em>.




<p>
<hr><h3><a name="pdf-math.floor"><code>math.floor (x)</code></a></h3>


<p>
Retorna o maior inteiro menor ou igual a <code>x</code>.




<p>
<hr><h3><a name="pdf-math.fmod"><code>math.fmod (x, y)</code></a></h3>


<p>
Retorna o resto da divis&atilde;o de <code>x</code> por <code>y</code>
que arredonda o quociente em dire&ccedil;&atilde;o a zero.




<p>
<hr><h3><a name="pdf-math.frexp"><code>math.frexp (x)</code></a></h3>


<p>
Retorna <code>m</code> e <code>e</code> tais que <em>x = m2<sup>e</sup></em>,
<code>e</code> &eacute; um inteiro e o valor absoluto de <code>m</code> est&aacute;
no intervalo <em>[0.5, 1)</em>
(ou zero quando <code>x</code> &eacute; zero).




<p>
<hr><h3><a name="pdf-math.huge"><code>math.huge</code></a></h3>


<p>
O valor de <code>HUGE_VAL</code>,
um valor maior ou igual a qualquer outro valor num&eacute;rico.




<p>
<hr><h3><a name="pdf-math.ldexp"><code>math.ldexp (m, e)</code></a></h3>


<p>
Retorna <em>m2<sup>e</sup></em> (<code>e</code> deve ser um inteiro).




<p>
<hr><h3><a name="pdf-math.log"><code>math.log (x)</code></a></h3>


<p>
Retorna o logaritmo natural de <code>x</code>.




<p>
<hr><h3><a name="pdf-math.log10"><code>math.log10 (x)</code></a></h3>


<p>
Retorna o logaritmo base-10 de <code>x</code>.




<p>
<hr><h3><a name="pdf-math.max"><code>math.max (x, &middot;&middot;&middot;)</code></a></h3>


<p>
Retorna o valor m&aacute;ximo entre os seus argumentos.




<p>
<hr><h3><a name="pdf-math.min"><code>math.min (x, &middot;&middot;&middot;)</code></a></h3>


<p>
Retorna o valor m&iacute;nimo entre os seus argumentos.




<p>
<hr><h3><a name="pdf-math.modf"><code>math.modf (x)</code></a></h3>


<p>
Retorna dois n&uacute;meros,
a parte integral de <code>x</code> e a parte fracion&aacute;ria de <code>x</code>.




<p>
<hr><h3><a name="pdf-math.pi"><code>math.pi</code></a></h3>


<p>
O valor de <em>pi</em>.




<p>
<hr><h3><a name="pdf-math.pow"><code>math.pow (x, y)</code></a></h3>


<p>
Retorna <em>x<sup>y</sup></em>.
(Voc&ecirc; tamb&eacute;m pode usar a express&atilde;o <code>x^y</code> para computar este valor.)




<p>
<hr><h3><a name="pdf-math.rad"><code>math.rad (x)</code></a></h3>


<p>
Retorna o &acirc;ngulo <code>x</code> (dado em graus) em radianos.




<p>
<hr><h3><a name="pdf-math.random"><code>math.random ([m [, n]])</code></a></h3>


<p>
Esta fun&ccedil;&atilde;o &eacute; uma interface para a fun&ccedil;&atilde;o
geradora pseudo-rand&ocirc;mica simples
<code>rand</code> fornecida por ANSI&nbsp;C.
(Nenhuma garantia pode ser dada para suas propriedades estat&iacute;sticas.)


<p>
Quando chamada sem argumentos,
retorna um n&uacute;mero real pseudo-rand&ocirc;mico uniforme
no intervalo <em>[0,1)</em>.  
Quando chamada com um n&uacute;mero inteiro <code>m</code>,
<code>math.random</code> retorna
um inteiro pseudo-rand&ocirc;mico uniforme no intervalo <em>[1, m]</em>.
Quando chamada com dois n&uacute;meros inteiros <code>m</code> e <code>n</code>,
<code>math.random</code> retorna um inteiro
pseudo-rand&ocirc;mico uniforme no intervalo <em>[m, n]</em>.




<p>
<hr><h3><a name="pdf-math.randomseed"><code>math.randomseed (x)</code></a></h3>


<p>
Estabelece <code>x</code> como a "semente"
para o gerador pseudo-rand&ocirc;mico:
sementes iguais produzem seq&uuml;&ecirc;ncias iguais de n&uacute;meros.




<p>
<hr><h3><a name="pdf-math.sin"><code>math.sin (x)</code></a></h3>


<p>
Retorna o seno de <code>x</code> (assume que <code>x</code> est&aacute; em radianos).




<p>
<hr><h3><a name="pdf-math.sinh"><code>math.sinh (x)</code></a></h3>


<p>
Retorna o seno hiperb&oacute;lico de <code>x</code>.




<p>
<hr><h3><a name="pdf-math.sqrt"><code>math.sqrt (x)</code></a></h3>


<p>
Retorna a raiz quadrada de <code>x</code>.
(Voc&ecirc; tamb&eacute;m pode usar a express&atilde;o <code>x^0.5</code> para computar este valor.)




<p>
<hr><h3><a name="pdf-math.tan"><code>math.tan (x)</code></a></h3>


<p>
Retorna a tangente de <code>x</code> (assume que <code>x</code> est&aacute; em radianos).




<p>
<hr><h3><a name="pdf-math.tanh"><code>math.tanh (x)</code></a></h3>


<p>
Retorna a tangente hiperb&oacute;lica de <code>x</code>.







<h2>5.7 - <a name="5.7">Facilidades de Entrada e Sa&iacute;da</a></h2>

<p>
A biblioteca de E/S prov&ecirc; dois estilos diferentes para manipula&ccedil;&atilde;o de arquivos.
O primeiro usa descritores de arquivo impl&iacute;citos;
isto &eacute;, h&aacute; opera&ccedil;&otilde;es para estabelecer um arquivo de entrada padr&atilde;o e um
arquivo de sa&iacute;da padr&atilde;o
e todas as opera&ccedil;&otilde;es de entrada/sa&iacute;da s&atilde;o realizadas sobre estes arquivos.
O segundo estilo usa descritores de arquivo expl&iacute;citos.


<p>
Quando se usa descritores de arquivo impl&iacute;citos,
todas as opera&ccedil;&otilde;es s&atilde;o providas pela tabela <a name="pdf-io"><code>io</code></a>.
Quando se usa descritores de arquivo expl&iacute;citos,
a opera&ccedil;&atilde;o <a href="#pdf-io.open"><code>io.open</code></a> retorna um descritor de arquivo
e ent&atilde;o todas as opera&ccedil;&otilde;es s&atilde;o providas como m&eacute;todos do descritor de arquivo.


<p>
A tabela <code>io</code> tamb&eacute;m fornece
tr&ecirc;s descritores de arquivo pr&eacute;-definidos com os seus significados usuais de C:
<a name="pdf-io.stdin"><code>io.stdin</code></a>, <a name="pdf-io.stdout"><code>io.stdout</code></a> e <a name="pdf-io.stderr"><code>io.stderr</code></a>.
A biblioteca de E/S nunca fecha estes arquivos.


<p>
A menos que dito de modo contr&aacute;rio,
todas as fun&ccedil;&otilde;es de E/S retornam <b>nil</b> em caso de falha
(mais uma mensagem de erro como segundo resultado e
um c&oacute;digo de erro dependente do sistema como um terceiro resultado),
ou algum valor diferente de <b>nil</b> em caso de sucesso.


<p>
<hr><h3><a name="pdf-io.close"><code>io.close ([file])</code></a></h3>


<p>
Equivalente a <code>file:close()</code>.
Quando n&atilde;o recebe <code>file</code>, fecha o arquivo de sa&iacute;da padr&atilde;o.




<p>
<hr><h3><a name="pdf-io.flush"><code>io.flush ()</code></a></h3>


<p>
Equivalente a <code>file:flush</code> no arquivo de sa&iacute;da padr&atilde;o. 




<p>
<hr><h3><a name="pdf-io.input"><code>io.input ([file])</code></a></h3>


<p>
Quando chamada com um nome de arquivo, abre o arquivo com aquele nome (em modo texto)
e estabelece seu manipulador como o arquivo de entrada padr&atilde;o.
Quando chamada com um manipulador de arquivo,
simplesmente estabelece este manipulador de arquivo como o arquivo de entrada padr&atilde;o.
Quando chamada sem par&acirc;metros,
retorna o arquivo de entrada padr&atilde;o corrente.


<p>
Em caso de erros esta fun&ccedil;&atilde;o dispara o erro,
ao inv&eacute;s de retornar um c&oacute;digo de erro.




<p>
<hr><h3><a name="pdf-io.lines"><code>io.lines ([filename])</code></a></h3>


<p>
Abre o nome de arquivo fornecido em modo de leitura
e retorna uma fun&ccedil;&atilde;o iteradora que,
cada vez que &eacute; chamada,
retorna uma nova linha do arquivo.
Portanto, a constru&ccedil;&atilde;o

<pre>
     for line in io.lines(filename) do <em>corpo</em> end
</pre><p>
ir&aacute; iterar sobre todas as linhas do arquivo.
Quando a fun&ccedil;&atilde;o iteradora detecta o fim do arquivo,
ela retorna <b>nil</b> (para finalizar o la&ccedil;o) e automaticamente fecha o arquivo.


<p>
A chamada <code>io.lines()</code> (sem nenhum nome de arquivo) &eacute; equivalente
a <code>io.input():lines()</code>;
isto &eacute;, ela itera sobre as linhas do arquivo de entrada padr&atilde;o.
Neste caso ela n&atilde;o fecha o arquivo quando o la&ccedil;o termina.




<p>
<hr><h3><a name="pdf-io.open"><code>io.open (filename [, mode])</code></a></h3>


<p>
Esta fun&ccedil;&atilde;o abre um arquivo,
no modo especificado na cadeia <code>mode</code>.
Ela retorna um novo manipulador de arquivo
ou, em caso de erros, <b>nil</b> mais uma mensagem de erro.


<p>
A cadeia de caracteres <code>mode</code> pode ser qualquer uma das seguintes:

<ul>
<li><b>"r":</b> modo de leitura (o padr&atilde;o);</li>
<li><b>"w":</b> modo de escrita;</li>
<li><b>"a":</b> modo de adi&ccedil;&atilde;o;</li>
<li><b>"r+":</b> modo de atualiza&ccedil;&atilde;o, todos os dados anteriores s&atilde;o preservados;</li>
<li><b>"w+":</b> modo de atualiza&ccedil;&atilde;o, todos os dados anteriores sao apagados;</li>
<li><b>"a+":</b> modo de atualiza&ccedil;&atilde;o de adi&ccedil;&atilde;o, dados anteriores s&atilde;o preservados,
  a escrita somente &eacute; permitida no fim do arquivo.</li>
</ul><p>
A cadeia <code>mode</code> tamb&eacute;m pode ter um '<code>b</code>' no fim,
que &eacute; necess&aacute;rio em alguns sistemas para abrir o arquivo em modo bin&aacute;rio.
Esta cadeia &eacute; exatamente o que &eacute; usado na
fun&ccedil;&atilde;o padr&atilde;o&nbsp;de&nbsp;C <code>fopen</code>.




<p>
<hr><h3><a name="pdf-io.output"><code>io.output ([file])</code></a></h3>


<p>
Similar a <a href="#pdf-io.input"><code>io.input</code></a>, mas opera sobre o arquivo de sa&iacute;da padr&atilde;o.




<p>
<hr><h3><a name="pdf-io.popen"><code>io.popen (prog [, mode])</code></a></h3>


<p>
Inicia o programa <code>prog</code> em um processo separado e retorna
um manipulador de arquivo que pode ser usado para ler dados deste programa
(se <code>mode</code> &eacute; <code>"r"</code>, o padr&atilde;o)
ou escrever dados para este programa
(se <code>mode</code> &eacute; <code>"w"</code>).


<p>
Esta fun&ccedil;&atilde;o &eacute; dependente do sistema e n&atilde;o est&aacute; dispon&iacute;vel
em todas as plataformas.




<p>
<hr><h3><a name="pdf-io.read"><code>io.read (&middot;&middot;&middot;)</code></a></h3>


<p>
Equivalente a <code>io.input():read</code>.




<p>
<hr><h3><a name="pdf-io.tmpfile"><code>io.tmpfile ()</code></a></h3>


<p>
Retorna um manipulador para um arquivo tempor&aacute;rio.
Este arquivo &eacute; aberto em modo de atualiza&ccedil;&atilde;o
e &eacute; automaticamente removido quando o programa termina.




<p>
<hr><h3><a name="pdf-io.type"><code>io.type (obj)</code></a></h3>


<p>
Verifica se <code>obj</code> &eacute; um manipulador de arquivo v&aacute;lido.
Retorna a cadeia <code>"file"</code> se <code>obj</code> &eacute; um manipulador de arquivo aberto,
<code>"close file"</code> se <code>obj</code> &eacute; um manipulador de arquivo fechado
ou <b>nil</b> se <code>obj</code> n&atilde;o &eacute; um manipulador de arquivo. 




<p>
<hr><h3><a name="pdf-io.write"><code>io.write (&middot;&middot;&middot;)</code></a></h3>


<p>
Equivalente a <code>io.output():write</code>.	




<p>
<hr><h3><a name="pdf-file:close"><code>file:close ()</code></a></h3>


<p>
Fecha <code>file</code>.
Note que arquivos s&atilde;o automaticamente fechados quando
seus manipuladores s&atilde;o coletados pelo coletor de lixo,
mas leva uma quantidade indeterminada de tempo para isso acontecer.




<p>
<hr><h3><a name="pdf-file:flush"><code>file:flush ()</code></a></h3>


<p>
Salva qualquer dado escrito para <code>file</code>.




<p>
<hr><h3><a name="pdf-file:lines"><code>file:lines ()</code></a></h3>


<p>
Retorna uma fun&ccedil;&atilde;o iteradora que,
cada vez que &eacute; chamada,
retorna uma nova linha do arquivo.
Portanto, a constru&ccedil;&atilde;o

<pre>
     for line in file:lines() do <em>corpo</em> end
</pre><p>
ir&aacute; iterar sobre todas as linhas do arquivo.
(Ao contr&aacute;rio de <a href="#pdf-io.lines"><code>io.lines</code></a>, essa fun&ccedil;&atilde;o n&atilde;o fecha o arquivo
quando o la&ccedil;o termina.)




<p>
<hr><h3><a name="pdf-file:read"><code>file:read (&middot;&middot;&middot;)</code></a></h3>


<p>
L&ecirc; o arquivo <code>file</code>,
de acordo com os formatos fornecidos, os quais especificam o que deve ser lido.
Para cada formato,
a fun&ccedil;&atilde;o retorna uma cadeia (ou um n&uacute;mero) com os caracteres lidos
ou <b>nil</b> se ela n&atilde;o pode retornar dados com o formato especificado.
Quando chamada sem formatos,
ela usa o formato padr&atilde;o que l&ecirc; a pr&oacute;xima linha toda
(veja abaixo).


<p>
Os formatos dispon&iacute;veis s&atilde;o

<ul>

<li><b>"*n":</b>
l&ecirc; um n&uacute;mero;
este &eacute; o &uacute;nico formato que retorna um n&uacute;mero ao inv&eacute;s de uma cadeia.
</li>

<li><b>"*a":</b>
l&ecirc; o arquivo inteiro, iniciando na posi&ccedil;&atilde;o corrente.
Quando est&aacute; no final do arquivo, retorna a cadeia vazia.
</li>

<li><b>"*l":</b>
l&ecirc; a pr&oacute;xima linha (pulando o fim de linha),
retornando <b>nil</b> ao final do arquivo.
Este &eacute; o formato padr&atilde;o.
</li>

<li><b><em>number</em>:</b>
l&ecirc; uma cadeia at&eacute; este n&uacute;mero de caracteres,
retornando <b>nil</b> ao final do arquivo.
Se o n&uacute;mero fornecido &eacute; zero,
a fun&ccedil;&atilde;o n&atilde;o l&ecirc; nada e retorna uma cadeia vazia
ou <b>nil</b> quando est&aacute; no fim do arquivo.
</li>

</ul>



<p>
<hr><h3><a name="pdf-file:seek"><code>file:seek ([whence] [, offset])</code></a></h3>


<p>
Estabelece e obt&eacute;m a posi&ccedil;&atilde;o do arquivo,
medida a partir do in&iacute;cio do arquivo,
at&eacute; a posi&ccedil;&atilde;o dada por <code>offset</code> mais uma base
especificada pela cadeia <code>whence</code>, como a seguir:

<ul>
<li><b>"set":</b> base &eacute; a posi&ccedil;&atilde;o 0 (o in&iacute;cio do arquivo);</li>
<li><b>"cur":</b> base &eacute; a posi&ccedil;&atilde;o corrente;</li>
<li><b>"end":</b> base &eacute; o fim do arquivo;</li>
</ul><p>
Em caso de sucesso, a fun&ccedil;&atilde;o <code>seek</code> retorna a posi&ccedil;&atilde;o final do arquivo,
medida em bytes a partir do in&iacute;cio do arquivo.
Se esta fun&ccedil;&atilde;o falha, ela retorna <b>nil</b>,
mais uma cadeia descrevendo o erro.


<p>
O valor padr&atilde;o para <code>whence</code> &eacute; <code>"cur"</code>
e para <code>offset</code> &eacute; 0.
Portanto, a chamada <code>file:seek()</code> retorna a posi&ccedil;&atilde;o
do arquivo corrente, sem modific&aacute;-la;
a chamada <code>file:seek("set")</code> estabelece a posi&ccedil;&atilde;o para o
in&iacute;cio do arquivo (e retorna 0);
e a chamada <code>file:seek("end")</code> estabelece a posi&ccedil;&atilde;o para o
fim do arquivo e retorna seu tamanho.




<p>
<hr><h3><a name="pdf-file:setvbuf"><code>file:setvbuf (mode [, size])</code></a></h3>


<p>
Define o modo de bufferiza&ccedil;&atilde;o para um arquivo de sa&iacute;da.
H&aacute; tr&ecirc;s modos dispon&iacute;veis:

<ul>

<li><b>"no":</b>
nenhuma bufferiza&ccedil;&atilde;o; o resultado de qualquer opera&ccedil;&atilde;o de sa&iacute;da aparece imediatamente.
</li>

<li><b>"full":</b>
bufferiza&ccedil;&atilde;o completa; a opera&ccedil;&atilde;o de sa&iacute;da &eacute; realizada somente
quando o buffer est&aacute; cheio (ou quando voc&ecirc; explicitamente <code>descarrega</code> o arquivo
(ver <a href="#pdf-io.flush"><code>io.flush</code></a>)).
</li>

<li><b>"line":</b>
bufferiza&ccedil;&atilde;o de linha; a sa&iacute;da &eacute; bufferizada at&eacute; que uma nova linha &eacute; produzida
ou h&aacute; qualquer entrada a partir de alguns arquivos especiais
(como um dispositivo de terminal).
</li>

</ul><p>
Para os &uacute;ltimos dois casos, <code>size</code>
especifica o tamanho do buffer, em bytes.
O padr&atilde;o &eacute; um tamanho apropriado.




<p>
<hr><h3><a name="pdf-file:write"><code>file:write (&middot;&middot;&middot;)</code></a></h3>


<p>
Escreve o valor de cada um de seus argumentos para
<code>file</code>.
Os argumentos devem ser cadeias de caracteres ou n&uacute;meros.
Para escrever outros valores,
use <a href="#pdf-tostring"><code>tostring</code></a> ou <a href="#pdf-string.format"><code>string.format</code></a> antes de <code>write</code>.







<h2>5.8 - <a name="5.8">Facilidades do Sistema Operacional</a></h2>

<p>
Esta biblioteca &eacute; implementada atrav&eacute;s da tabela <a name="pdf-os"><code>os</code></a>.


<p>
<hr><h3><a name="pdf-os.clock"><code>os.clock ()</code></a></h3>


<p>
Retorna uma aproxima&ccedil;&atilde;o da quantidade de tempo de CPU, em segundos,
usada pelo programa.




<p>
<hr><h3><a name="pdf-os.date"><code>os.date ([format [, time]])</code></a></h3>


<p>
Retorna uma cadeia ou uma tabela contendo data e hora,
formatada de acordo com a cadeia <code>format</code> fornecida.


<p>
Se o argumento <code>time</code> est&aacute; presente,
este &eacute; o tempo a ser formatado
(veja a fun&ccedil;&atilde;o <a href="#pdf-os.time"><code>os.time</code></a> para uma descri&ccedil;&atilde;o deste valor).
Caso contr&aacute;rio, <code>date</code> formata a hora corrente.


<p>
Se <code>format</code> come&ccedil;a com '<code>!</code>',
ent&atilde;o a data &eacute; formatada no Tempo Universal Coordenado.
Ap&oacute;s esse caractere opcional,
se <code>format</code> &eacute; a cadeia "<code>*t</code>",
ent&atilde;o <code>date</code> retorna uma tabela com os seguintes campos:
<code>year</code> (quatro d&iacute;gitos), <code>month</code> (1--12), <code>day</code> (1--31),
<code>hour</code> (0--23), <code>min</code> (0--59), <code>sec</code> (0--61),
<code>wday</code> (dia da semana, domingo &eacute;&nbsp;1),
<code>yday</code> (dia do ano)
e <code>isdst</code> (flag que indica o hor&aacute;rio de ver&atilde;o, um booleano).


<p>
Se <code>format</code> n&atilde;o &eacute; "<code>*t</code>",
ent&atilde;o <code>date</code> retorna a data como uma cadeia de caracteres,
formatada de acordo com as mesmas regras da fun&ccedil;&atilde;o&nbsp;C <code>strftime</code>.


<p>
Quando chamada sem argumentos,
<code>date</code> retorna uma representa&ccedil;&atilde;o aceit&aacute;vel da data e da hora que depende
do sistema hospedeiro e do idioma (<em>locale</em>) corrente.
(isto &eacute;, <code>os.date()</code> &eacute; equivalente a <code>os.date("%c")</code>).




<p>
<hr><h3><a name="pdf-os.difftime"><code>os.difftime (t2, t1)</code></a></h3>


<p>
Retorna o n&uacute;mero de segundos a partir do tempo <code>t1</code> at&eacute; o tempo <code>t2</code>.
Em POSIX, Windows e alguns outros sistemas,
este valor &eacute; exatamente <code>t2</code><em>-</em><code>t1</code>.




<p>
<hr><h3><a name="pdf-os.execute"><code>os.execute ([command])</code></a></h3>


<p>
Esta fun&ccedil;&atilde;o &eacute; equivalente &agrave; fun&ccedil;&atilde;o&nbsp;C <code>system</code>.
Ela passa <code>command</code> para ser executado por um interpretador de comandos do sistema operacional.
Ela retorna um c&oacute;digo de status, que &eacute; dependente do sistema.
Se <code>command</code> est&aacute; ausente, ent&atilde;o a fun&ccedil;&atilde;o retorna um valor diferente de zero se um interpretrador
de comandos est&aacute; dispon&iacute;vel e zero caso contr&aacute;rio.




<p>
<hr><h3><a name="pdf-os.exit"><code>os.exit ([code])</code></a></h3>


<p>
Chama a fun&ccedil;&atilde;o&nbsp;C <code>exit</code>,
com um c&oacute;digo <code>code</code> opcional,
para terminar o programa hospedeiro.
O valor padr&atilde;o para <code>code</code> &eacute; o c&oacute;digo de sucesso.




<p>
<hr><h3><a name="pdf-os.getenv"><code>os.getenv (varname)</code></a></h3>


<p>
Retorna o valor da vari&aacute;vel de ambiente do processo <code>varname</code>
ou <b>nil</b> se a vari&aacute;vel n&atilde;o est&aacute; definida.	




<p>
<hr><h3><a name="pdf-os.remove"><code>os.remove (filename)</code></a></h3>


<p>
Remove um arquivo ou diret&oacute;rio com o nome fornecido.
Diret&oacute;rios devem estar vazios para serem removidos.
Se esta fun&ccedil;&atilde;o falha, ela retorna <b>nil</b>,
mais uma cadeia descrevendo o erro.




<p>
<hr><h3><a name="pdf-os.rename"><code>os.rename (oldname, newname)</code></a></h3>


<p>
Renomeia um arquivo ou diret&oacute;rio chamado <code>oldname</code> para <code>newname</code>.
Se esta fun&ccedil;&atilde;o falha, ela retorna <b>nil</b>,
mais uma cadeia descrevendo o erro.




<p>
<hr><h3><a name="pdf-os.setlocale"><code>os.setlocale (locale [, category])</code></a></h3>


<p>
Estabelece o idioma (<em>locale</em>) corrente do programa.
<code>locale</code> &eacute; uma cadeia de caracteres especificando um idioma;
<code>category</code> &eacute; uma cadeia opcional descrevendo para qual categoria deve-se mudar:
<code>"all"</code>, <code>"collate"</code>, <code>"ctype"</code>,
<code>"monetary"</code>, <code>"numeric"</code> ou <code>"time"</code>;
a categoria padr&atilde;o &eacute; <code>"all"</code>.
Esta fun&ccedil;&atilde;o retorna o nome do novo idioma
ou <b>nil</b> se a requisi&ccedil;&atilde;o n&atilde;o pode ser honrada.


<p>
Se <code>locale</code> &eacute; a cadeia vazia,
estabelece-se o idioma corrente como um idioma nativo definido pela implementa&ccedil;&atilde;o.
Se <code>locale</code> &eacute; a cadeia "<code>C</code>",
estabelece-se o idioma corrente como o idioma padr&atilde;o de&nbsp;C.


<p>
Quando chamada com <b>nil</b> como o primeiro argumento,
esta fun&ccedil;&atilde;o retorna somente o nome do idioma corrente
para a categoria fornecida.




<p>
<hr><h3><a name="pdf-os.time"><code>os.time ([table])</code></a></h3>


<p>
Retorna o tempo corrente quando chamada sem argumentos
ou um tempo representando a data e a hora especificados pela tabela fornecida.
Esta tabela deve ter campos <code>year</code>, <code>month</code> e <code>day</code>
e pode ter campos <code>hour</code>, <code>min</code>, <code>sec</code> e <code>isdst</code>
(para uma descri&ccedil;&atilde;o destes campos, veja a fun&ccedil;&atilde;o <a href="#pdf-os.date"><code>os.date</code></a>).


<p>
O valor retornado &eacute; um n&uacute;mero, cujo significado depende do seu sistema.
Em POSIX, Windows e alguns outros sistemas, este n&uacute;mero conta o n&uacute;mero
de segundos desde algum tempo de in&iacute;cio dado (a "era").
Em outros sistemas, o significado n&atilde;o &eacute; especificado
e o n&uacute;mero retornado por <code>time</code> pode ser usado somente como um argumento para
<code>date</code> e <code>difftime</code>.




<p>
<hr><h3><a name="pdf-os.tmpname"><code>os.tmpname ()</code></a></h3>


<p>
Retorna uma cadeia de caracteres com o nome de um arquivo que pode
ser usado para um arquivo tempor&aacute;rio.
O arquivo deve ser explicitamente aberto antes de ser usado
e explicitamente removido quando n&atilde;o for mais necess&aacute;rio.


<p>
Em alguns sistemas (POSIX),
esta fun&ccedil;&atilde;o tamb&eacute;m cria um arquivo com esse nome,
para evitar riscos de seguran&ccedil;a.
(Outro usu&aacute;rio pode criar o arquivo com permiss&otilde;es erradas
no intervalo de tempo entre a obten&ccedil;&atilde;o do nome e a cria&ccedil;&atilde;o do arquivo.)
Voc&ecirc; ainda deve abrir o arquivo para poder us&aacute;-lo
e deve remov&ecirc;-lo (mesmo que voc&ecirc; n&atilde;o tenha usado).


<p>
Quando poss&iacute;vel,
voc&ecirc; pode preferir usar <a href="#pdf-io.tmpfile"><code>io.tmpfile</code></a>,
que automaticamente remove o arquivo quando o programa termina.







<h2>5.9 - <a name="5.9">A Biblioteca de Depura&ccedil;&atilde;o</a></h2>

<p>
Esta biblioteca prov&ecirc;
as funcionalidades da interface de depura&ccedil;&atilde;o para programas Lua.
Voc&ecirc; deve ter cuidado ao usar esta biblioteca.
As fun&ccedil;&otilde;es fornecidas aqui devem ser usadas exclusivamente para depura&ccedil;&atilde;o
e tarefas similares, tais como medi&ccedil;&atilde;o (<em>profiling</em>).
Por favor resista &agrave; tenta&ccedil;&atilde;o de us&aacute;-las como uma
ferramenta de programa&ccedil;&atilde;o usual:
elas podem ser muito lentas.
Al&eacute;m disso, v&aacute;rias dessas fun&ccedil;&otilde;es
violam algumas suposi&ccedil;&otilde;es a respeito do c&oacute;digo Lua
(e.g., que vari&aacute;veis locais a uma fun&ccedil;&atilde;o
n&atilde;o podem ser acessadas de fora da fun&ccedil;&atilde;o ou
que metatabelas de objetos userdata n&atilde;o podem ser modificadas por c&oacute;digo Lua)
e portanto podem comprometer c&oacute;digo que, de outro modo, seria seguro. 


<p>
Todas as fun&ccedil;&otilde;es nesta biblioteca s&atilde;o fornecidas
na tabela <a name="pdf-debug"><code>debug</code></a>.
Todas as fun&ccedil;&otilde;es que operam sobre um objeto do tipo thread
possuem um primeiro argumento opcional que &eacute; o
objeto thread sobre o qual a fun&ccedil;&atilde;o deve operar.
O padr&atilde;o &eacute; sempre o fluxo de execu&ccedil;&atilde;o corrente.


<p>
<hr><h3><a name="pdf-debug.debug"><code>debug.debug ()</code></a></h3>


<p>
Entra em um modo interativo com o usu&aacute;rio,
executando cada cadeia de caracteres que o usu&aacute;rio entra.
Usando comandos simples e outros mecanismos de depura&ccedil;&atilde;o,
o usu&aacute;rio pode inspecionar vari&aacute;veis globais e locais,
mudar o valor delas, avaliar express&otilde;es, etc.
Uma linha contendo somente a palavra <code>cont</code> termina esta fun&ccedil;&atilde;o,
de modo que a fun&ccedil;&atilde;o chamadora continua sua execu&ccedil;&atilde;o.


<p>
Note que os comandos para <code>debug.debug</code> n&atilde;o s&atilde;o aninhados de modo l&eacute;xico
dentro de nenhuma fun&ccedil;&atilde;o e portanto n&atilde;o possuem acesso direto a vari&aacute;veis locais.




<p>
<hr><h3><a name="pdf-debug.getfenv"><code>debug.getfenv (o)</code></a></h3>
Retorna o ambiente do objeto <code>o</code>.




<p>
<hr><h3><a name="pdf-debug.gethook"><code>debug.gethook ([thread])</code></a></h3>


<p>
Retorna as configura&ccedil;&otilde;es de gancho correntes do fluxo de execu&ccedil;&atilde;o como tr&ecirc;s valores:
a fun&ccedil;&atilde;o de gancho corrente, a m&aacute;scara de ganho corrente
e a contagem de ganho corrente
(como estabelecido pela fun&ccedil;&atilde;o <a href="#pdf-debug.sethook"><code>debug.sethook</code></a>).




<p>
<hr><h3><a name="pdf-debug.getinfo"><code>debug.getinfo ([thread,] function [, what])</code></a></h3>


<p>
Retorna uma tabela com informa&ccedil;&atilde;o sobre uma fun&ccedil;&atilde;o.
Voc&ecirc; pode fornecer a fun&ccedil;&atilde;o diretamente
ou voc&ecirc; pode fornecer um n&uacute;mero como o valor de <code>function</code>,
que significa a fun&ccedil;&atilde;o executando no n&iacute;vel <code>function</code> da pilha de chamadas
do fluxo de execu&ccedil;&atilde;o fornecido:
n&iacute;vel&nbsp;0 &eacute; a fun&ccedil;&atilde;o corrente (a pr&oacute;pria <code>getinfo</code>);
n&iacute;vel&nbsp;1 &eacute; a fun&ccedil;&atilde;o que chamou <code>getinfo</code>;
e assim por diante.
Se <code>function</code> &eacute; um n&uacute;mero maior do que o n&uacute;mero de fun&ccedil;&otilde;es ativas,
ent&atilde;o <code>getinfo</code> retorna <b>nil</b>.


<p>
A tabela retornada pode conter todos os campos retornados por <a href="#lua_getinfo"><code>lua_getinfo</code></a>,
com a cadeia <code>what</code> descrevendo quais campos devem ser preenchidos.
O padr&atilde;o para <code>what</code> &eacute; obter todas as informa&ccedil;&otilde;es dispon&iacute;veis,
exceto a tabela de linhas v&aacute;lidas.
Se presente,
a op&ccedil;&atilde;o '<code>f</code>'
adiciona um campo chamado <code>func</code> com a pr&oacute;pria fun&ccedil;&atilde;o.
Se presente,
a op&ccedil;&atilde;o '<code>L</code>'
adiciona um campo chamado <code>activelines</code> com a tabela
de linhas v&aacute;lidas.


<p>
Por exemplo, a express&atilde;o <code>debug.getinfo(1,"n").name</code> retorna
uma tabela com um nome para a fun&ccedil;&atilde;o corrente,
se um nome razo&aacute;vel pode ser encontrado,
e a express&atilde;o <code>debug.getinfo(print)</code>
retorna uma tabela com todas as informa&ccedil;&otilde;es dispon&iacute;veis
sobre a fun&ccedil;&atilde;o <a href="#pdf-print"><code>print</code></a>.




<p>
<hr><h3><a name="pdf-debug.getlocal"><code>debug.getlocal ([thread,] level, local)</code></a></h3>


<p>
Esta fun&ccedil;&atilde;o retorna o nome e o valor da vari&aacute;vel local
com &iacute;ndice <code>local</code> da fun&ccedil;&atilde;o no n&iacute;vel <code>level</code> da pilha.
(O primeiro par&acirc;metro ou vari&aacute;vel local possui &iacute;ndice&nbsp;1 e assim por diante,
at&eacute; a &uacute;ltima vari&aacute;vel local ativa.)
A fun&ccedil;&atilde;o retorna <b>nil</b> se n&atilde;o existe uma vari&aacute;vel
local com o &iacute;ndice fornecido
e dispara um erro quando chamada com um <code>level</code> fora da faixa de valores v&aacute;lidos.
(Voc&ecirc; pode chamar <a href="#pdf-debug.getinfo"><code>debug.getinfo</code></a> para verificar se o n&iacute;vel &eacute; v&aacute;lido.)


<p>
Nomes de vari&aacute;veis que come&ccedil;am com '<code>(</code>' (abre par&ecirc;nteses)
representam vari&aacute;veis internas
(vari&aacute;veis de controle de la&ccedil;os, tempor&aacute;rios e locais de fun&ccedil;&otilde;es&nbsp;C).




<p>
<hr><h3><a name="pdf-debug.getmetatable"><code>debug.getmetatable (object)</code></a></h3>


<p>
Retorna a metatabela do <code>object</code> fornecido
ou <b>nil</b> se ele n&atilde;o possui uma metatabela.




<p>
<hr><h3><a name="pdf-debug.getregistry"><code>debug.getregistry ()</code></a></h3>


<p>
Retorna a tabela de registro (ver <a href="#3.5">&sect;3.5</a>).




<p>
<hr><h3><a name="pdf-debug.getupvalue"><code>debug.getupvalue (func, up)</code></a></h3>


<p>
Esta fun&ccedil;&atilde;o retorna o nome e o valor do upvalue
com &iacute;ndice <code>up</code> da fun&ccedil;&atilde;o <code>func</code>.
A fun&ccedil;&atilde;o retorna <b>nil</b> se n&atilde;o h&aacute; um upvalue com o &iacute;ndice fornecido.




<p>
<hr><h3><a name="pdf-debug.setfenv"><code>debug.setfenv (object, table)</code></a></h3>


<p>
Estabelece a tabela <code>table</code> como o ambiente do <code>object</code> fornecido.
Retorna <code>object</code>.




<p>
<hr><h3><a name="pdf-debug.sethook"><code>debug.sethook ([thread,] hook, mask [, count])</code></a></h3>


<p>
Estabelece a fun&ccedil;&atilde;o fornecida como um gancho.
A cadeia <code>mask</code> e o n&uacute;mero <code>count</code> descrevem
quando o gancho ser&aacute; chamado.
A cadeia <code>mask</code> pode ter os seguintes caracteres,
com o respectivo significado:

<ul>
<li><b><code>"c"</code>:</b> o gancho &eacute; chamado toda vez que Lua chama uma fun&ccedil;&atilde;o;</li>
<li><b><code>"r"</code>:</b> o gancho &eacute; chamado toda vez que Lua retorna de uma fun&ccedil;&atilde;o;</li>
<li><b><code>"l"</code>:</b> o gancho &eacute; chamado toda vez que Lua entra uma nova linha de c&oacute;digo.</li>
</ul><p>
Com um <code>count</code> diferente de zero,
o gancho &eacute; chamado ap&oacute;s cada <code>count</code> instru&ccedil;&otilde;es.


<p>
Quando chamada sem argumentos,
<a href="#pdf-debug.sethook"><code>debug.sethook</code></a> desabilita o gancho.


<p>
Quando o gancho &eacute; chamado, seu primeiro par&acirc;metro &eacute; uma cadeia de caracteres
descrevendo o evento que disparou a sua chamada:
<code>"call"</code>, <code>"return"</code> (ou <code>"tail return"</code>,
quando estiver simulando um retorno de uma recurs&atilde;o final),
<code>"line"</code> e <code>"count"</code>.
Para eventos de linha,
o gancho tamb&eacute;m obt&eacute;m o novo n&uacute;mero de linha como seu segundo par&acirc;metro.
Dentro do gancho,
&eacute; poss&iacute;vel chamar <code>getinfo</code> com n&iacute;vel&nbsp;2 para obter mais informa&ccedil;&atilde;o sobre
a fun&ccedil;&atilde;o sendo executada
(n&iacute;vel&nbsp;0 &eacute; a fun&ccedil;&atilde;o <code>getinfo</code>
e n&iacute;vel&nbsp;1 &eacute; a fun&ccedil;&atilde;o de gancho),
a menos que o evento seja <code>"tail return"</code>.
Neste caso, Lua est&aacute; somente simulando o retorno
e uma chamada a <code>getinfo</code> retornar&aacute; dados inv&aacute;lidos.




<p>
<hr><h3><a name="pdf-debug.setlocal"><code>debug.setlocal ([thread,] level, local, value)</code></a></h3>


<p>
Esta fun&ccedil;&atilde;o atribui o valor <code>value</code> &agrave; vari&aacute;vel local
com &iacute;ndice <code>local</code> da fun&ccedil;&atilde;o no n&iacute;vel <code>level</code> da pilha.
A fun&ccedil;&atilde;o retorna <b>nil</b> se n&atilde;o h&aacute; uma vari&aacute;vel
local com o &iacute;ndice fornecido
e dispara um erro quando chamada com um <code>level</code> fora da faixa de valores v&aacute;lidos.
(Voc&ecirc; pode chamar <code>getinfo</code> para verificar se o n&iacute;vel &eacute; v&aacute;lido.)
Caso contr&aacute;rio, a fun&ccedil;&atilde;o retorna o nome da vari&aacute;vel local.




<p>
<hr><h3><a name="pdf-debug.setmetatable"><code>debug.setmetatable (object, table)</code></a></h3>


<p>
Estabelece <code>table</code> como a metatabela do <code>object</code> fornecido
(<code>table</code> pode ser <b>nil</b>).




<p>
<hr><h3><a name="pdf-debug.setupvalue"><code>debug.setupvalue (func, up, value)</code></a></h3>


<p>
Esta fun&ccedil;&atilde;o atribui o valor <code>value</code> ao upvalue
com &iacute;ndice <code>up</code> da fun&ccedil;&atilde;o <code>func</code>.
A fun&ccedil;&atilde;o retorna <b>nil</b> se n&atilde;o h&aacute; um upvalue
com o &iacute;ndice fornecido.
Caso contr&aacute;rio, a fun&ccedil;&atilde;o retorna o nome do upvalue.




<p>
<hr><h3><a name="pdf-debug.traceback"><code>debug.traceback ([thread,] [message] [, level])</code></a></h3>


<p>
Retorna uma cadeia de caracteres com um tra&ccedil;o da pilha de chamadas.
Uma cadeia opcional <code>message</code> &eacute; adicionada
ao in&iacute;cio do tra&ccedil;o.
Um n&uacute;mero opcional <code>level</code> diz em qual n&iacute;vel
iniciar o tra&ccedil;o
(o padr&atilde;o &eacute; 1, a fun&ccedil;&atilde;o chamando <code>traceback</code>).







<h1>6 - <a name="6">O Interpretador de Linha de Comando Lua</a></h1>

<p>
Embora Lua tenha sido projetada como uma linguagem de extens&atilde;o,
para ser embutida em um programa&nbsp;C hospedeiro,
Lua tamb&eacute;m &eacute; freq&uuml;entemente usada como uma linguagem auto-suficiente.
Um interpretador para Lua como uma linguagem auto-suficiente,
chamado simplesmente <code>lua</code>,
&eacute; fornecido com a distribui&ccedil;&atilde;o padr&atilde;o.
Esse interpretador inclui
todas as bibliotecas padr&atilde;o, inclusive a biblioteca de depura&ccedil;&atilde;o.
Seu uso &eacute;:

<pre>
     lua [options] [script [args]]
</pre><p>
As op&ccedil;&otilde;es s&atilde;o:

<ul>
<li><b><code>-e <em>stat</em></code>:</b> executa a cadeia <em>stat</em>;</li>
<li><b><code>-l <em>mod</em></code>:</b> "requisita" <em>mod</em>;</li>
<li><b><code>-i</code>:</b> entra em modo interativo ap&oacute;s executar <em>script</em>;</li>
<li><b><code>-v</code>:</b> imprime informa&ccedil;&atilde;o de vers&atilde;o;</li>
<li><b><code>--</code>:</b> p&aacute;ra de tratar op&ccedil;&otilde;es;</li>
<li><b><code>-</code>:</b> executa <code>stdin</code> como um arquivo e p&aacute;ra de tratar op&ccedil;&otilde;es.</li>
</ul><p>
Ap&oacute;s tratar suas op&ccedil;&otilde;es, <code>lua</code> executa o <em>script</em> fornecido,
passando para ele os <em>args</em> fornecidos como cadeias de argumentos.
Quando chamado sem argumentos,
<code>lua</code> comporta-se como <code>lua -v -i</code>
quando a entrada padr&atilde;o (<code>stdin</code>) &eacute; um terminal
e como <code>lua -</code> em caso contr&aacute;rio.


<p>
Antes de executar qualquer argumento,
o interpretador verifica se h&aacute; uma vari&aacute;vel de ambiente <a name="pdf-LUA_INIT"><code>LUA_INIT</code></a>.
Se seu formato &eacute; <code>@<em>filename</em></code>,
ent&atilde;o <code>lua</code> executa o arquivo.
Caso contr&aacute;rio, <code>lua</code> executa a pr&oacute;pria cadeia de caracteres.


<p>
Todas as op&ccedil;&otilde;es s&atilde;o manipuladas na ordem dada, exceto <code>-i</code>.
Por exemplo, uma invoca&ccedil;&atilde;o como

<pre>
     $ lua -e'a=1' -e 'print(a)' script.lua
</pre><p>
ir&aacute; primeiro atribuir 1 a <code>a</code>, depois imprimir&aacute; o valor de <code>a</code> (que &eacute; '<code>1</code>')
e finalmente executar&aacute; o arquivo <code>script.lua</code> sem argumentos.
(Aqui <code>$</code> &eacute; o <em>prompt</em> do interpretador de comandos. Voc&ecirc; pode ter um prompt diferente.) 


<p>
Antes de come&ccedil;ar a executar o script,
<code>lua</code> guarda todos os argumentos fornecidos na linha de comando
em uma tabela global chamada <code>arg</code>.
O nome do script &eacute; armazenado no &iacute;ndice 0,
o primeiro argumento ap&oacute;s o nome do script fica no &iacute;ndice 1
e assim por diante.
Quaisquer argumentos antes do nome do script
(isto &eacute;, o nome do interpretador mais as op&ccedil;&otilde;es)
ficam em &iacute;ndices negativos.
Por exemplo, na chamada

<pre>
     $ lua -la b.lua t1 t2
</pre><p>
o interpretador primeiro executa o arquivo <code>a.lua</code>,
depois cria a tabela

<pre>
     arg = { [-2] = "lua", [-1] = "-la",
             [0] = "b.lua",
             [1] = "t1", [2] = "t2" }
</pre><p>
e finalmente executa o arquivo <code>b.lua</code>.
O script &eacute; chamado com <code>arg[1]</code>, <code>arg[2]</code>, &middot;&middot;&middot;
como argumentos;
ele tamb&eacute;m pode acessar estes argumentos com a express&atilde;o vararg '<code>...</code>'.


<p>
Em modo interativo,
se voc&ecirc; escrever um comando incompleto,
o interpretador espera que voc&ecirc; o complete
e indica isto atrav&eacute;s de um prompt diferente.


<p>
Se a vari&aacute;vel global <a name="pdf-_PROMPT"><code>_PROMPT</code></a> cont&eacute;m uma cadeia de caracteres,
ent&atilde;o o seu valor &eacute; usado como o prompt.
De maneira similar, se a vari&aacute;vel global <a name="pdf-_PROMPT2"><code>_PROMPT2</code></a> cont&eacute;m uma cadeia,
seu valor &eacute; usado como o prompt secund&aacute;rio
(mostrado durante comandos incompletos).
Portanto, os dois prompts podem ser modificados diretamente na linha de comando
ou em quaisquer programas Lua fazendo uma atribui&ccedil;&atilde;o a <code>_PROMPT</code>.
Veja o exemplo a seguir:

<pre>
     $ lua -e"_PROMPT='myprompt&gt; '" -i
</pre><p>
(O par de aspas mais externo &eacute; para o interpretador de comandos
e o par mais interno &eacute; para Lua.)
Note o uso de <code>-i</code> para entrar em modo interativo;
caso contr&aacute;rio,
o programa iria terminar silenciosamente
logo ap&oacute;s a atribui&ccedil;&atilde;o a <code>_PROMPT</code>.


<p>
Para permitir o uso de Lua como um
interpretador de scripts em sistemas Unix,
o interpretador de linha de comando pula
a primeira linha de um trecho de c&oacute;digo se ele come&ccedil;a com <code>#</code>.
Portanto, scripts Lua podem ser usados como programas execut&aacute;veis
usando <code>chmod +x</code> e a forma&nbsp;<code>#!</code>,
como em

<pre>
     #!/usr/local/bin/lua
</pre><p>
(&Eacute; claro que
a localiza&ccedil;&atilde;o do interpretador Lua pode ser diferente na sua m&aacute;quina.
Se <code>lua</code> est&aacute; em seu <code>PATH</code>,
ent&atilde;o 

<pre>
     #!/usr/bin/env lua
</pre><p>
&eacute; uma solu&ccedil;&atilde;o mais port&aacute;vel.) 



<h1>7 - <a name="7">Incompatibilidades com a Vers&atilde;o Anterior</a></h1>

<p>
Listamos aqui as incompatibilidades que voc&ecirc; pode encontrar quando passando um programa
de Lua&nbsp;5.0 para Lua&nbsp;5.1.
Voc&ecirc; pode evitar a maioria das incompatibilidades compilando Lua com
op&ccedil;&otilde;es apropriadas (veja o arquivo <code>luaconf.h</code>).
Contudo,
todas essas op&ccedil;&otilde;es de compatibilidade ser&atilde;o removidas na pr&oacute;xima vers&atilde;o de Lua.



<h2>7.1 - <a name="7.1">Mudan&ccedil;as na Linguagem</a></h2>
<ul>

<li>
O sistema de vararg mudou do pseudo-argumento <code>arg</code> com uma
tabela com os argumentos extras para a express&atilde;o vararg.
(Veja a op&ccedil;&atilde;o de tempo de compila&ccedil;&atilde;o <code>LUA_COMPAT_VARARG</code> em <code>luaconf.h</code>.)
</li>

<li>
Houve uma mudan&ccedil;a sutil no escopo das vari&aacute;veis
impl&iacute;citas do comando <b>for</b> e do comando <b>repeat</b>.
</li>

<li>
A sintaxe de cadeia longa/coment&aacute;rio longo (<code>[[<em>string</em>]]</code>)
n&atilde;o permite aninhamento.
Voc&ecirc; pode usar a nova sintaxe (<code>[=[<em>string</em>]=]</code>) nesses casos.
(Veja a op&ccedil;&atilde;o de tempo de compila&ccedil;&atilde;o <code>LUA_COMPAT_LSTR</code> em <code>luaconf.h</code>.)
</li>

</ul>




<h2>7.2 - <a name="7.2">Mudan&ccedil;as nas Bibliotecas</a></h2>
<ul>

<li>
A fun&ccedil;&atilde;o <code>string.gfind</code> foi renomeada para <a href="#pdf-string.gmatch"><code>string.gmatch</code></a>.
(Veja a op&ccedil;&atilde;o de tempo de compila&ccedil;&atilde;o <code>LUA_COMPAT_GFIND</code> em <code>luaconf.h</code>.)
</li>

<li>
Quando <a href="#pdf-string.gsub"><code>string.gsub</code></a> &eacute; chamada com uma fun&ccedil;&atilde;o como seu
terceiro argumento,
sempre que esta fun&ccedil;&atilde;o retorna <b>nil</b> ou <b>false</b> a
cadeia de substitui&ccedil;&atilde;o &eacute; o casamento inteiro,
ao inv&eacute;s da cadeia vazia.
</li>

<li>
A fun&ccedil;&atilde;o <code>table.setn</code> est&aacute; ultrapassada e n&atilde;o deve ser usada.
A fun&ccedil;&atilde;o <code>table.getn</code> corresponde
ao novo operador de comprimento (<code>#</code>);
use o operador ao inv&eacute;s da fun&ccedil;&atilde;o.
(Veja a op&ccedil;&atilde;o de tempo de compila&ccedil;&atilde;o <code>LUA_COMPAT_GETN</code> em <code>luaconf.h</code>.)
</li>

<li>
A fun&ccedil;&atilde;o <code>loadlib</code> foi renomeada para <a href="#pdf-package.loadlib"><code>package.loadlib</code></a>.
(Veja a op&ccedil;&atilde;o de tempo de compila&ccedil;&atilde;o <code>LUA_COMPAT_LOADLIB</code> em <code>luaconf.h</code>.)
</li>

<li>
A fun&ccedil;&atilde;o <code>math.mod</code> foi renomeada para <a href="#pdf-math.fmod"><code>math.fmod</code></a>.
(Veja a op&ccedil;&atilde;o de tempo de compila&ccedil;&atilde;o <code>LUA_COMPAT_MOD</code> em <code>luaconf.h</code>.)
</li>

<li>
As fun&ccedil;&otilde;es <code>table.foreach</code> e <code>table.foreachi</code> est&atilde;o ultrapassadas e n&atilde;o devem ser usadas.
Voc&ecirc; pode usar um la&ccedil;o <b>for</b> com <code>pairs</code> ou <code>ipairs</code> ao inv&eacute;s delas.
</li>

<li>
Houve mudan&ccedil;as substanciais na fun&ccedil;&atilde;o <a href="#pdf-require"><code>require</code></a> devido ao
novo sistema de m&oacute;dulos.
O novo comportamento &eacute; basicamente compat&iacute;vel com o antigo,
por&eacute;m agora <code>require</code> obt&eacute;m o caminho de <a href="#pdf-package.path"><code>package.path</code></a> e n&atilde;o mais
de <code>LUA_PATH</code>.
</li>

<li>
A fun&ccedil;&atilde;o <a href="#pdf-collectgarbage"><code>collectgarbage</code></a> possui argumentos diferentes.
A fun&ccedil;&atilde;o <code>gcinfo</code> est&aacute; ultrapassada e n&atilde;o deve ser usada;
use <code>collectgarbage("count")</code> ao inv&eacute;s dela.
</li>

</ul>




<h2>7.3 - <a name="7.3">Mudan&ccedil;as na API</a></h2>
<ul>

<li>
As fun&ccedil;&otilde;es <code>luaopen_*</code> (para abrir bibliotecas)
n&atilde;o podem ser chamadas diretamente,
como uma fun&ccedil;&atilde;o C comum.
Elas devem ser chamadas atrav&eacute;s de Lua,
como uma fun&ccedil;&atilde;o Lua.
</li>

<li>
A fun&ccedil;&atilde;o <code>lua_open</code> foi substitu&iacute;da por <a href="#lua_newstate"><code>lua_newstate</code></a> para
permitir que o usu&aacute;rio defina uma fun&ccedil;&atilde;o de aloca&ccedil;&atilde;o de mem&oacute;ria.
Voc&ecirc; pode usar <a href="#luaL_newstate"><code>luaL_newstate</code></a> da biblioteca padr&atilde;o para
criar um estado com uma fun&ccedil;&atilde;o de aloca&ccedil;&atilde;o padr&atilde;o
(baseada em <code>realloc</code>).
</li>

<li>
As fun&ccedil;&otilde;es <code>luaL_getn</code> e <code>luaL_setn</code>
(da biblioteca auxiliar) est&atilde;o ultrapassadas e n&atilde;o devem ser usadas.
Use <a href="#lua_objlen"><code>lua_objlen</code></a> ao inv&eacute;s de <code>luaL_getn</code>
e nada no lugar de <code>luaL_setn</code>.
</li>

<li>
A fun&ccedil;&atilde;o <code>luaL_openlib</code> foi substitu&iacute;da por <a href="#luaL_register"><code>luaL_register</code></a>.
</li>

<li>
A fun&ccedil;&atilde;o <code>luaL_checkudata</code> agora dispara um erro quando o valor fornecido
n&atilde;o &eacute; um objeto userdata do tipo esperado.
(Em Lua&nbsp;5.0 ela retornava <code>NULL</code>.)
</li>

</ul>
<p>




<h1>8 - <a name="8">A Sintaxe Completa de Lua</a></h1>

<p>
Aqui est&aacute; a sintaxe completa de Lua na nota&ccedil;&atilde;o BNF estendida.
(Ela n&atilde;o descreve as preced&ecirc;ncias dos operadores.)




<pre>

	trecho ::= {comando [`<b>;</b>&acute;]} [ultimocomando [`<b>;</b>&acute;]]

	bloco ::= trecho

	comando ::=  listavar `<b>=</b>&acute; listaexp | 
		 chamadadefuncao | 
		 <b>do</b> bloco <b>end</b> | 
		 <b>while</b> exp <b>do</b> bloco <b>end</b> | 
		 <b>repeat</b> bloco <b>until</b> exp | 
		 <b>if</b> exp <b>then</b> bloco {<b>elseif</b> exp <b>then</b> bloco} [<b>else</b> bloco] <b>end</b> | 
		 <b>for</b> Nome `<b>=</b>&acute; exp `<b>,</b>&acute; exp [`<b>,</b>&acute; exp] <b>do</b> bloco <b>end</b> | 
		 <b>for</b> listadenomes <b>in</b> listaexp <b>do</b> bloco <b>end</b> | 
		 <b>function</b> nomedafuncao corpodafuncao | 
		 <b>local</b> <b>function</b> Nome corpodafuncao | 
		 <b>local</b> listadenomes [`<b>=</b>&acute; listaexp] 

	ultimocomando ::= <b>return</b> [listaexp] | <b>break</b>

	nomedafuncao ::= Nome {`<b>.</b>&acute; Nome} [`<b>:</b>&acute; Nome]

	listavar ::= var {`<b>,</b>&acute; var}

	var ::=  Nome | expprefixo `<b>[</b>&acute; exp `<b>]</b>&acute; | expprefixo `<b>.</b>&acute; Nome 

	listadenomes ::= Nome {`<b>,</b>&acute; Nome}

	listaexp ::= {exp `<b>,</b>&acute;} exp

	exp ::=  <b>nil</b> | <b>false</b> | <b>true</b> | Numero | Cadeia | `<b>...</b>&acute; | funcao | 
		 expprefixo | construtortabela | exp opbin exp | opunaria exp 

	expprefixo ::= var | chamadadefuncao | `<b>(</b>&acute; exp `<b>)</b>&acute;

	chamadadefuncao ::=  expprefixo args | expprefixo `<b>:</b>&acute; Nome args 

	args ::=  `<b>(</b>&acute; [listaexp] `<b>)</b>&acute; | construtortabela | Cadeia 

	funcao ::= <b>function</b> corpodafuncao

	corpodafuncao ::= `<b>(</b>&acute; [listapar] `<b>)</b>&acute; bloco <b>end</b>

	listapar ::= listadenomes [`<b>,</b>&acute; `<b>...</b>&acute;] | `<b>...</b>&acute;

	construtortabela ::= `<b>{</b>&acute; [listadecampos] `<b>}</b>&acute;

	listadecampos ::= campo {separadordecampos campo} [separadordecampos]

	campo ::= `<b>[</b>&acute; exp `<b>]</b>&acute; `<b>=</b>&acute; exp | Nome `<b>=</b>&acute; exp | exp

	separadordecampos ::= `<b>,</b>&acute; | `<b>;</b>&acute;

	opbin ::= `<b>+</b>&acute; | `<b>-</b>&acute; | `<b>*</b>&acute; | `<b>/</b>&acute; | `<b>^</b>&acute; | `<b>%</b>&acute; | `<b>..</b>&acute; | 
		 `<b>&lt;</b>&acute; | `<b>&lt;=</b>&acute; | `<b>&gt;</b>&acute; | `<b>&gt;=</b>&acute; | `<b>==</b>&acute; | `<b>~=</b>&acute; | 
		 <b>and</b> | <b>or</b>

	opunaria ::= `<b>-</b>&acute; | <b>not</b> | `<b>#</b>&acute;

</pre>

<p>






<HR>
<SMALL>
Last update:
Wed Sep 28 01:04:56 BRT 2011
</SMALL>
<!--
Last change: minor edit
-->

</body>
<!-- Mirrored from www.lua.org/manual/5.1/pt/manual.html by HTTrack Website Copier/3.x [XR&CO'2010], Thu, 29 Sep 2011 12:47:35 GMT -->
</html>

